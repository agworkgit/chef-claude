{"ast":null,"code":"import { delay } from \"../utils/delay.js\";\nimport { omit } from \"../utils/omit.js\";\nimport { base64FromBytes } from \"../utils/base64FromBytes.js\";\nimport { TaskProviderHelper } from \"./providerHelper.js\";\nimport { InferenceClientInputError, InferenceClientProviderApiError, InferenceClientProviderOutputError } from \"../errors.js\";\nconst WAVESPEEDAI_API_BASE_URL = \"https://api.wavespeed.ai\";\nclass WavespeedAITask extends TaskProviderHelper {\n  constructor(url) {\n    super(\"wavespeed\", url || WAVESPEEDAI_API_BASE_URL);\n  }\n  makeRoute(params) {\n    return `/api/v3/${params.model}`;\n  }\n  preparePayload(params) {\n    const payload = {\n      ...omit(params.args, [\"inputs\", \"parameters\"]),\n      ...params.args.parameters,\n      prompt: params.args.inputs\n    };\n    // Add LoRA support if adapter is specified in the mapping\n    if (params.mapping?.adapter === \"lora\") {\n      payload.loras = [{\n        path: params.mapping.hfModelId,\n        scale: 1 // Default scale value\n      }];\n    }\n    return payload;\n  }\n  async getResponse(response, url, headers) {\n    if (!url || !headers) {\n      throw new InferenceClientInputError(\"Headers are required for WaveSpeed AI API calls\");\n    }\n    const parsedUrl = new URL(url);\n    const resultPath = new URL(response.data.urls.get).pathname;\n    /// override the base url to use the router.huggingface.co if going through huggingface router\n    const baseUrl = `${parsedUrl.protocol}//${parsedUrl.host}${parsedUrl.host === \"router.huggingface.co\" ? \"/wavespeed\" : \"\"}`;\n    const resultUrl = `${baseUrl}${resultPath}`;\n    // Poll for results until completion\n    while (true) {\n      const resultResponse = await fetch(resultUrl, {\n        headers\n      });\n      if (!resultResponse.ok) {\n        throw new InferenceClientProviderApiError(\"Failed to fetch response status from WaveSpeed AI API\", {\n          url: resultUrl,\n          method: \"GET\"\n        }, {\n          requestId: resultResponse.headers.get(\"x-request-id\") ?? \"\",\n          status: resultResponse.status,\n          body: await resultResponse.text()\n        });\n      }\n      const result = await resultResponse.json();\n      const taskResult = result.data;\n      switch (taskResult.status) {\n        case \"completed\":\n          {\n            // Get the media data from the first output URL\n            if (!taskResult.outputs?.[0]) {\n              throw new InferenceClientProviderOutputError(\"Received malformed response from WaveSpeed AI API: No output URL in completed response\");\n            }\n            const mediaResponse = await fetch(taskResult.outputs[0]);\n            if (!mediaResponse.ok) {\n              throw new InferenceClientProviderApiError(\"Failed to fetch generation output from WaveSpeed AI API\", {\n                url: taskResult.outputs[0],\n                method: \"GET\"\n              }, {\n                requestId: mediaResponse.headers.get(\"x-request-id\") ?? \"\",\n                status: mediaResponse.status,\n                body: await mediaResponse.text()\n              });\n            }\n            return await mediaResponse.blob();\n          }\n        case \"failed\":\n          {\n            throw new InferenceClientProviderOutputError(taskResult.error || \"Task failed\");\n          }\n        default:\n          {\n            // Wait before polling again\n            await delay(500);\n            continue;\n          }\n      }\n    }\n  }\n}\nexport class WavespeedAITextToImageTask extends WavespeedAITask {\n  constructor() {\n    super(WAVESPEEDAI_API_BASE_URL);\n  }\n}\nexport class WavespeedAITextToVideoTask extends WavespeedAITask {\n  constructor() {\n    super(WAVESPEEDAI_API_BASE_URL);\n  }\n}\nexport class WavespeedAIImageToImageTask extends WavespeedAITask {\n  constructor() {\n    super(WAVESPEEDAI_API_BASE_URL);\n  }\n  async preparePayloadAsync(args) {\n    return {\n      ...args,\n      inputs: args.parameters?.prompt,\n      image: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))\n    };\n  }\n}\nexport class WavespeedAIImageToVideoTask extends WavespeedAITask {\n  constructor() {\n    super(WAVESPEEDAI_API_BASE_URL);\n  }\n  async preparePayloadAsync(args) {\n    return {\n      ...args,\n      inputs: args.parameters?.prompt,\n      image: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))\n    };\n  }\n}","map":{"version":3,"names":["delay","omit","base64FromBytes","TaskProviderHelper","InferenceClientInputError","InferenceClientProviderApiError","InferenceClientProviderOutputError","WAVESPEEDAI_API_BASE_URL","WavespeedAITask","constructor","url","makeRoute","params","model","preparePayload","payload","args","parameters","prompt","inputs","mapping","adapter","loras","path","hfModelId","scale","getResponse","response","headers","parsedUrl","URL","resultPath","data","urls","get","pathname","baseUrl","protocol","host","resultUrl","resultResponse","fetch","ok","method","requestId","status","body","text","result","json","taskResult","outputs","mediaResponse","blob","error","WavespeedAITextToImageTask","WavespeedAITextToVideoTask","WavespeedAIImageToImageTask","preparePayloadAsync","image","Uint8Array","ArrayBuffer","arrayBuffer","WavespeedAIImageToVideoTask"],"sources":["/Users/agmacbook/Documents/Courses/Meta - Full Stack/Exercises/meta_fullstack_exercises/6_react_basics/12_review/13_chef_claude/node_modules/@huggingface/inference/dist/esm/providers/wavespeed.js"],"sourcesContent":["import { delay } from \"../utils/delay.js\";\nimport { omit } from \"../utils/omit.js\";\nimport { base64FromBytes } from \"../utils/base64FromBytes.js\";\nimport { TaskProviderHelper } from \"./providerHelper.js\";\nimport { InferenceClientInputError, InferenceClientProviderApiError, InferenceClientProviderOutputError, } from \"../errors.js\";\nconst WAVESPEEDAI_API_BASE_URL = \"https://api.wavespeed.ai\";\nclass WavespeedAITask extends TaskProviderHelper {\n    constructor(url) {\n        super(\"wavespeed\", url || WAVESPEEDAI_API_BASE_URL);\n    }\n    makeRoute(params) {\n        return `/api/v3/${params.model}`;\n    }\n    preparePayload(params) {\n        const payload = {\n            ...omit(params.args, [\"inputs\", \"parameters\"]),\n            ...params.args.parameters,\n            prompt: params.args.inputs,\n        };\n        // Add LoRA support if adapter is specified in the mapping\n        if (params.mapping?.adapter === \"lora\") {\n            payload.loras = [\n                {\n                    path: params.mapping.hfModelId,\n                    scale: 1, // Default scale value\n                },\n            ];\n        }\n        return payload;\n    }\n    async getResponse(response, url, headers) {\n        if (!url || !headers) {\n            throw new InferenceClientInputError(\"Headers are required for WaveSpeed AI API calls\");\n        }\n        const parsedUrl = new URL(url);\n        const resultPath = new URL(response.data.urls.get).pathname;\n        /// override the base url to use the router.huggingface.co if going through huggingface router\n        const baseUrl = `${parsedUrl.protocol}//${parsedUrl.host}${parsedUrl.host === \"router.huggingface.co\" ? \"/wavespeed\" : \"\"}`;\n        const resultUrl = `${baseUrl}${resultPath}`;\n        // Poll for results until completion\n        while (true) {\n            const resultResponse = await fetch(resultUrl, { headers });\n            if (!resultResponse.ok) {\n                throw new InferenceClientProviderApiError(\"Failed to fetch response status from WaveSpeed AI API\", { url: resultUrl, method: \"GET\" }, {\n                    requestId: resultResponse.headers.get(\"x-request-id\") ?? \"\",\n                    status: resultResponse.status,\n                    body: await resultResponse.text(),\n                });\n            }\n            const result = await resultResponse.json();\n            const taskResult = result.data;\n            switch (taskResult.status) {\n                case \"completed\": {\n                    // Get the media data from the first output URL\n                    if (!taskResult.outputs?.[0]) {\n                        throw new InferenceClientProviderOutputError(\"Received malformed response from WaveSpeed AI API: No output URL in completed response\");\n                    }\n                    const mediaResponse = await fetch(taskResult.outputs[0]);\n                    if (!mediaResponse.ok) {\n                        throw new InferenceClientProviderApiError(\"Failed to fetch generation output from WaveSpeed AI API\", { url: taskResult.outputs[0], method: \"GET\" }, {\n                            requestId: mediaResponse.headers.get(\"x-request-id\") ?? \"\",\n                            status: mediaResponse.status,\n                            body: await mediaResponse.text(),\n                        });\n                    }\n                    return await mediaResponse.blob();\n                }\n                case \"failed\": {\n                    throw new InferenceClientProviderOutputError(taskResult.error || \"Task failed\");\n                }\n                default: {\n                    // Wait before polling again\n                    await delay(500);\n                    continue;\n                }\n            }\n        }\n    }\n}\nexport class WavespeedAITextToImageTask extends WavespeedAITask {\n    constructor() {\n        super(WAVESPEEDAI_API_BASE_URL);\n    }\n}\nexport class WavespeedAITextToVideoTask extends WavespeedAITask {\n    constructor() {\n        super(WAVESPEEDAI_API_BASE_URL);\n    }\n}\nexport class WavespeedAIImageToImageTask extends WavespeedAITask {\n    constructor() {\n        super(WAVESPEEDAI_API_BASE_URL);\n    }\n    async preparePayloadAsync(args) {\n        return {\n            ...args,\n            inputs: args.parameters?.prompt,\n            image: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer())),\n        };\n    }\n}\nexport class WavespeedAIImageToVideoTask extends WavespeedAITask {\n    constructor() {\n        super(WAVESPEEDAI_API_BASE_URL);\n    }\n    async preparePayloadAsync(args) {\n        return {\n            ...args,\n            inputs: args.parameters?.prompt,\n            image: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer())),\n        };\n    }\n}\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ,mBAAmB;AACzC,SAASC,IAAI,QAAQ,kBAAkB;AACvC,SAASC,eAAe,QAAQ,6BAA6B;AAC7D,SAASC,kBAAkB,QAAQ,qBAAqB;AACxD,SAASC,yBAAyB,EAAEC,+BAA+B,EAAEC,kCAAkC,QAAS,cAAc;AAC9H,MAAMC,wBAAwB,GAAG,0BAA0B;AAC3D,MAAMC,eAAe,SAASL,kBAAkB,CAAC;EAC7CM,WAAWA,CAACC,GAAG,EAAE;IACb,KAAK,CAAC,WAAW,EAAEA,GAAG,IAAIH,wBAAwB,CAAC;EACvD;EACAI,SAASA,CAACC,MAAM,EAAE;IACd,OAAO,WAAWA,MAAM,CAACC,KAAK,EAAE;EACpC;EACAC,cAAcA,CAACF,MAAM,EAAE;IACnB,MAAMG,OAAO,GAAG;MACZ,GAAGd,IAAI,CAACW,MAAM,CAACI,IAAI,EAAE,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;MAC9C,GAAGJ,MAAM,CAACI,IAAI,CAACC,UAAU;MACzBC,MAAM,EAAEN,MAAM,CAACI,IAAI,CAACG;IACxB,CAAC;IACD;IACA,IAAIP,MAAM,CAACQ,OAAO,EAAEC,OAAO,KAAK,MAAM,EAAE;MACpCN,OAAO,CAACO,KAAK,GAAG,CACZ;QACIC,IAAI,EAAEX,MAAM,CAACQ,OAAO,CAACI,SAAS;QAC9BC,KAAK,EAAE,CAAC,CAAE;MACd,CAAC,CACJ;IACL;IACA,OAAOV,OAAO;EAClB;EACA,MAAMW,WAAWA,CAACC,QAAQ,EAAEjB,GAAG,EAAEkB,OAAO,EAAE;IACtC,IAAI,CAAClB,GAAG,IAAI,CAACkB,OAAO,EAAE;MAClB,MAAM,IAAIxB,yBAAyB,CAAC,iDAAiD,CAAC;IAC1F;IACA,MAAMyB,SAAS,GAAG,IAAIC,GAAG,CAACpB,GAAG,CAAC;IAC9B,MAAMqB,UAAU,GAAG,IAAID,GAAG,CAACH,QAAQ,CAACK,IAAI,CAACC,IAAI,CAACC,GAAG,CAAC,CAACC,QAAQ;IAC3D;IACA,MAAMC,OAAO,GAAG,GAAGP,SAAS,CAACQ,QAAQ,KAAKR,SAAS,CAACS,IAAI,GAAGT,SAAS,CAACS,IAAI,KAAK,uBAAuB,GAAG,YAAY,GAAG,EAAE,EAAE;IAC3H,MAAMC,SAAS,GAAG,GAAGH,OAAO,GAAGL,UAAU,EAAE;IAC3C;IACA,OAAO,IAAI,EAAE;MACT,MAAMS,cAAc,GAAG,MAAMC,KAAK,CAACF,SAAS,EAAE;QAAEX;MAAQ,CAAC,CAAC;MAC1D,IAAI,CAACY,cAAc,CAACE,EAAE,EAAE;QACpB,MAAM,IAAIrC,+BAA+B,CAAC,uDAAuD,EAAE;UAAEK,GAAG,EAAE6B,SAAS;UAAEI,MAAM,EAAE;QAAM,CAAC,EAAE;UAClIC,SAAS,EAAEJ,cAAc,CAACZ,OAAO,CAACM,GAAG,CAAC,cAAc,CAAC,IAAI,EAAE;UAC3DW,MAAM,EAAEL,cAAc,CAACK,MAAM;UAC7BC,IAAI,EAAE,MAAMN,cAAc,CAACO,IAAI,CAAC;QACpC,CAAC,CAAC;MACN;MACA,MAAMC,MAAM,GAAG,MAAMR,cAAc,CAACS,IAAI,CAAC,CAAC;MAC1C,MAAMC,UAAU,GAAGF,MAAM,CAAChB,IAAI;MAC9B,QAAQkB,UAAU,CAACL,MAAM;QACrB,KAAK,WAAW;UAAE;YACd;YACA,IAAI,CAACK,UAAU,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;cAC1B,MAAM,IAAI7C,kCAAkC,CAAC,wFAAwF,CAAC;YAC1I;YACA,MAAM8C,aAAa,GAAG,MAAMX,KAAK,CAACS,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC;YACxD,IAAI,CAACC,aAAa,CAACV,EAAE,EAAE;cACnB,MAAM,IAAIrC,+BAA+B,CAAC,yDAAyD,EAAE;gBAAEK,GAAG,EAAEwC,UAAU,CAACC,OAAO,CAAC,CAAC,CAAC;gBAAER,MAAM,EAAE;cAAM,CAAC,EAAE;gBAChJC,SAAS,EAAEQ,aAAa,CAACxB,OAAO,CAACM,GAAG,CAAC,cAAc,CAAC,IAAI,EAAE;gBAC1DW,MAAM,EAAEO,aAAa,CAACP,MAAM;gBAC5BC,IAAI,EAAE,MAAMM,aAAa,CAACL,IAAI,CAAC;cACnC,CAAC,CAAC;YACN;YACA,OAAO,MAAMK,aAAa,CAACC,IAAI,CAAC,CAAC;UACrC;QACA,KAAK,QAAQ;UAAE;YACX,MAAM,IAAI/C,kCAAkC,CAAC4C,UAAU,CAACI,KAAK,IAAI,aAAa,CAAC;UACnF;QACA;UAAS;YACL;YACA,MAAMtD,KAAK,CAAC,GAAG,CAAC;YAChB;UACJ;MACJ;IACJ;EACJ;AACJ;AACA,OAAO,MAAMuD,0BAA0B,SAAS/C,eAAe,CAAC;EAC5DC,WAAWA,CAAA,EAAG;IACV,KAAK,CAACF,wBAAwB,CAAC;EACnC;AACJ;AACA,OAAO,MAAMiD,0BAA0B,SAAShD,eAAe,CAAC;EAC5DC,WAAWA,CAAA,EAAG;IACV,KAAK,CAACF,wBAAwB,CAAC;EACnC;AACJ;AACA,OAAO,MAAMkD,2BAA2B,SAASjD,eAAe,CAAC;EAC7DC,WAAWA,CAAA,EAAG;IACV,KAAK,CAACF,wBAAwB,CAAC;EACnC;EACA,MAAMmD,mBAAmBA,CAAC1C,IAAI,EAAE;IAC5B,OAAO;MACH,GAAGA,IAAI;MACPG,MAAM,EAAEH,IAAI,CAACC,UAAU,EAAEC,MAAM;MAC/ByC,KAAK,EAAEzD,eAAe,CAAC,IAAI0D,UAAU,CAAC5C,IAAI,CAACG,MAAM,YAAY0C,WAAW,GAAG7C,IAAI,CAACG,MAAM,GAAG,MAAMH,IAAI,CAACG,MAAM,CAAC2C,WAAW,CAAC,CAAC,CAAC;IAC7H,CAAC;EACL;AACJ;AACA,OAAO,MAAMC,2BAA2B,SAASvD,eAAe,CAAC;EAC7DC,WAAWA,CAAA,EAAG;IACV,KAAK,CAACF,wBAAwB,CAAC;EACnC;EACA,MAAMmD,mBAAmBA,CAAC1C,IAAI,EAAE;IAC5B,OAAO;MACH,GAAGA,IAAI;MACPG,MAAM,EAAEH,IAAI,CAACC,UAAU,EAAEC,MAAM;MAC/ByC,KAAK,EAAEzD,eAAe,CAAC,IAAI0D,UAAU,CAAC5C,IAAI,CAACG,MAAM,YAAY0C,WAAW,GAAG7C,IAAI,CAACG,MAAM,GAAG,MAAMH,IAAI,CAACG,MAAM,CAAC2C,WAAW,CAAC,CAAC,CAAC;IAC7H,CAAC;EACL;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}