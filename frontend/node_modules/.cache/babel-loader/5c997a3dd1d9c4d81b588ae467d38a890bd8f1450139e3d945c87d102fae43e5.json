{"ast":null,"code":"// src/lexer.ts\nvar TOKEN_TYPES = Object.freeze({\n  Text: \"Text\",\n  // The text between Jinja statements or expressions\n  NumericLiteral: \"NumericLiteral\",\n  // e.g., 123, 1.0\n  StringLiteral: \"StringLiteral\",\n  // 'string'\n  Identifier: \"Identifier\",\n  // Variables, functions, statements, booleans, etc.\n  Equals: \"Equals\",\n  // =\n  OpenParen: \"OpenParen\",\n  // (\n  CloseParen: \"CloseParen\",\n  // )\n  OpenStatement: \"OpenStatement\",\n  // {%\n  CloseStatement: \"CloseStatement\",\n  // %}\n  OpenExpression: \"OpenExpression\",\n  // {{\n  CloseExpression: \"CloseExpression\",\n  // }}\n  OpenSquareBracket: \"OpenSquareBracket\",\n  // [\n  CloseSquareBracket: \"CloseSquareBracket\",\n  // ]\n  OpenCurlyBracket: \"OpenCurlyBracket\",\n  // {\n  CloseCurlyBracket: \"CloseCurlyBracket\",\n  // }\n  Comma: \"Comma\",\n  // ,\n  Dot: \"Dot\",\n  // .\n  Colon: \"Colon\",\n  // :\n  Pipe: \"Pipe\",\n  // |\n  CallOperator: \"CallOperator\",\n  // ()\n  AdditiveBinaryOperator: \"AdditiveBinaryOperator\",\n  // + - ~\n  MultiplicativeBinaryOperator: \"MultiplicativeBinaryOperator\",\n  // * / %\n  ComparisonBinaryOperator: \"ComparisonBinaryOperator\",\n  // < > <= >= == !=\n  UnaryOperator: \"UnaryOperator\",\n  // ! - +\n  Comment: \"Comment\"\n  // {# ... #}\n});\nvar Token = class {\n  /**\n   * Constructs a new Token.\n   * @param {string} value The raw value as seen inside the source code.\n   * @param {TokenType} type The type of token.\n   */\n  constructor(value, type) {\n    this.value = value;\n    this.type = type;\n  }\n};\nfunction isWord(char) {\n  return /\\w/.test(char);\n}\nfunction isInteger(char) {\n  return /[0-9]/.test(char);\n}\nvar ORDERED_MAPPING_TABLE = [\n// Control sequences\n[\"{%\", TOKEN_TYPES.OpenStatement], [\"%}\", TOKEN_TYPES.CloseStatement], [\"{{\", TOKEN_TYPES.OpenExpression], [\"}}\", TOKEN_TYPES.CloseExpression],\n// Single character tokens\n[\"(\", TOKEN_TYPES.OpenParen], [\")\", TOKEN_TYPES.CloseParen], [\"{\", TOKEN_TYPES.OpenCurlyBracket], [\"}\", TOKEN_TYPES.CloseCurlyBracket], [\"[\", TOKEN_TYPES.OpenSquareBracket], [\"]\", TOKEN_TYPES.CloseSquareBracket], [\",\", TOKEN_TYPES.Comma], [\".\", TOKEN_TYPES.Dot], [\":\", TOKEN_TYPES.Colon], [\"|\", TOKEN_TYPES.Pipe],\n// Comparison operators\n[\"<=\", TOKEN_TYPES.ComparisonBinaryOperator], [\">=\", TOKEN_TYPES.ComparisonBinaryOperator], [\"==\", TOKEN_TYPES.ComparisonBinaryOperator], [\"!=\", TOKEN_TYPES.ComparisonBinaryOperator], [\"<\", TOKEN_TYPES.ComparisonBinaryOperator], [\">\", TOKEN_TYPES.ComparisonBinaryOperator],\n// Arithmetic operators\n[\"+\", TOKEN_TYPES.AdditiveBinaryOperator], [\"-\", TOKEN_TYPES.AdditiveBinaryOperator], [\"~\", TOKEN_TYPES.AdditiveBinaryOperator], [\"*\", TOKEN_TYPES.MultiplicativeBinaryOperator], [\"/\", TOKEN_TYPES.MultiplicativeBinaryOperator], [\"%\", TOKEN_TYPES.MultiplicativeBinaryOperator],\n// Assignment operator\n[\"=\", TOKEN_TYPES.Equals]];\nvar ESCAPE_CHARACTERS = /* @__PURE__ */new Map([[\"n\", \"\\n\"],\n// New line\n[\"t\", \"\t\"],\n// Horizontal tab\n[\"r\", \"\\r\"],\n// Carriage return\n[\"b\", \"\\b\"],\n// Backspace\n[\"f\", \"\\f\"],\n// Form feed\n[\"v\", \"\\v\"],\n// Vertical tab\n[\"'\", \"'\"],\n// Single quote\n['\"', '\"'],\n// Double quote\n[\"\\\\\", \"\\\\\"]\n// Backslash\n]);\nfunction preprocess(template, options = {}) {\n  if (template.endsWith(\"\\n\")) {\n    template = template.slice(0, -1);\n  }\n  if (options.lstrip_blocks) {\n    template = template.replace(/^[ \\t]*({[#%-])/gm, \"$1\");\n  }\n  if (options.trim_blocks) {\n    template = template.replace(/([#%-]})\\n/g, \"$1\");\n  }\n  return template.replace(/-%}\\s*/g, \"%}\").replace(/\\s*{%-/g, \"{%\").replace(/-}}\\s*/g, \"}}\").replace(/\\s*{{-/g, \"{{\").replace(/-#}\\s*/g, \"#}\").replace(/\\s*{#-/g, \"{#\").replace(/{%\\s*(end)?generation\\s*%}/gs, \"\");\n}\nfunction tokenize(source, options = {}) {\n  const tokens = [];\n  const src = preprocess(source, options);\n  let cursorPosition = 0;\n  let curlyBracketDepth = 0;\n  const consumeWhile = predicate => {\n    let str = \"\";\n    while (predicate(src[cursorPosition])) {\n      if (src[cursorPosition] === \"\\\\\") {\n        ++cursorPosition;\n        if (cursorPosition >= src.length) throw new SyntaxError(\"Unexpected end of input\");\n        const escaped = src[cursorPosition++];\n        const unescaped = ESCAPE_CHARACTERS.get(escaped);\n        if (unescaped === void 0) {\n          throw new SyntaxError(`Unexpected escaped character: ${escaped}`);\n        }\n        str += unescaped;\n        continue;\n      }\n      str += src[cursorPosition++];\n      if (cursorPosition >= src.length) throw new SyntaxError(\"Unexpected end of input\");\n    }\n    return str;\n  };\n  main: while (cursorPosition < src.length) {\n    const lastTokenType = tokens.at(-1)?.type;\n    if (lastTokenType === void 0 || lastTokenType === TOKEN_TYPES.CloseStatement || lastTokenType === TOKEN_TYPES.CloseExpression || lastTokenType === TOKEN_TYPES.Comment) {\n      let text = \"\";\n      while (cursorPosition < src.length &&\n      // Keep going until we hit the next Jinja statement or expression\n      !(src[cursorPosition] === \"{\" && (src[cursorPosition + 1] === \"%\" || src[cursorPosition + 1] === \"{\" || src[cursorPosition + 1] === \"#\"))) {\n        text += src[cursorPosition++];\n      }\n      if (text.length > 0) {\n        tokens.push(new Token(text, TOKEN_TYPES.Text));\n        continue;\n      }\n    }\n    if (src[cursorPosition] === \"{\" && src[cursorPosition + 1] === \"#\") {\n      cursorPosition += 2;\n      let comment = \"\";\n      while (src[cursorPosition] !== \"#\" || src[cursorPosition + 1] !== \"}\") {\n        if (cursorPosition + 2 >= src.length) {\n          throw new SyntaxError(\"Missing end of comment tag\");\n        }\n        comment += src[cursorPosition++];\n      }\n      tokens.push(new Token(comment, TOKEN_TYPES.Comment));\n      cursorPosition += 2;\n      continue;\n    }\n    consumeWhile(char2 => /\\s/.test(char2));\n    const char = src[cursorPosition];\n    if (char === \"-\" || char === \"+\") {\n      const lastTokenType2 = tokens.at(-1)?.type;\n      if (lastTokenType2 === TOKEN_TYPES.Text || lastTokenType2 === void 0) {\n        throw new SyntaxError(`Unexpected character: ${char}`);\n      }\n      switch (lastTokenType2) {\n        case TOKEN_TYPES.Identifier:\n        case TOKEN_TYPES.NumericLiteral:\n        case TOKEN_TYPES.StringLiteral:\n        case TOKEN_TYPES.CloseParen:\n        case TOKEN_TYPES.CloseSquareBracket:\n          break;\n        default:\n          {\n            ++cursorPosition;\n            const num = consumeWhile(isInteger);\n            tokens.push(new Token(`${char}${num}`, num.length > 0 ? TOKEN_TYPES.NumericLiteral : TOKEN_TYPES.UnaryOperator));\n            continue;\n          }\n      }\n    }\n    for (const [seq, type] of ORDERED_MAPPING_TABLE) {\n      if (seq === \"}}\" && curlyBracketDepth > 0) {\n        continue;\n      }\n      const slice2 = src.slice(cursorPosition, cursorPosition + seq.length);\n      if (slice2 === seq) {\n        tokens.push(new Token(seq, type));\n        if (type === TOKEN_TYPES.OpenExpression) {\n          curlyBracketDepth = 0;\n        } else if (type === TOKEN_TYPES.OpenCurlyBracket) {\n          ++curlyBracketDepth;\n        } else if (type === TOKEN_TYPES.CloseCurlyBracket) {\n          --curlyBracketDepth;\n        }\n        cursorPosition += seq.length;\n        continue main;\n      }\n    }\n    if (char === \"'\" || char === '\"') {\n      ++cursorPosition;\n      const str = consumeWhile(c => c !== char);\n      tokens.push(new Token(str, TOKEN_TYPES.StringLiteral));\n      ++cursorPosition;\n      continue;\n    }\n    if (isInteger(char)) {\n      let num = consumeWhile(isInteger);\n      if (src[cursorPosition] === \".\" && isInteger(src[cursorPosition + 1])) {\n        ++cursorPosition;\n        const frac = consumeWhile(isInteger);\n        num = `${num}.${frac}`;\n      }\n      tokens.push(new Token(num, TOKEN_TYPES.NumericLiteral));\n      continue;\n    }\n    if (isWord(char)) {\n      const word = consumeWhile(isWord);\n      tokens.push(new Token(word, TOKEN_TYPES.Identifier));\n      continue;\n    }\n    throw new SyntaxError(`Unexpected character: ${char}`);\n  }\n  return tokens;\n}\n\n// src/ast.ts\nvar Statement = class {\n  type = \"Statement\";\n};\nvar Program = class extends Statement {\n  constructor(body) {\n    super();\n    this.body = body;\n  }\n  type = \"Program\";\n};\nvar If = class extends Statement {\n  constructor(test, body, alternate) {\n    super();\n    this.test = test;\n    this.body = body;\n    this.alternate = alternate;\n  }\n  type = \"If\";\n};\nvar For = class extends Statement {\n  constructor(loopvar, iterable, body, defaultBlock) {\n    super();\n    this.loopvar = loopvar;\n    this.iterable = iterable;\n    this.body = body;\n    this.defaultBlock = defaultBlock;\n  }\n  type = \"For\";\n};\nvar Break = class extends Statement {\n  type = \"Break\";\n};\nvar Continue = class extends Statement {\n  type = \"Continue\";\n};\nvar SetStatement = class extends Statement {\n  constructor(assignee, value, body) {\n    super();\n    this.assignee = assignee;\n    this.value = value;\n    this.body = body;\n  }\n  type = \"Set\";\n};\nvar Macro = class extends Statement {\n  constructor(name, args, body) {\n    super();\n    this.name = name;\n    this.args = args;\n    this.body = body;\n  }\n  type = \"Macro\";\n};\nvar Comment = class extends Statement {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  type = \"Comment\";\n};\nvar Expression = class extends Statement {\n  type = \"Expression\";\n};\nvar MemberExpression = class extends Expression {\n  constructor(object, property, computed) {\n    super();\n    this.object = object;\n    this.property = property;\n    this.computed = computed;\n  }\n  type = \"MemberExpression\";\n};\nvar CallExpression = class extends Expression {\n  constructor(callee, args) {\n    super();\n    this.callee = callee;\n    this.args = args;\n  }\n  type = \"CallExpression\";\n};\nvar Identifier = class extends Expression {\n  /**\n   * @param {string} value The name of the identifier\n   */\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  type = \"Identifier\";\n};\nvar Literal = class extends Expression {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  type = \"Literal\";\n};\nvar IntegerLiteral = class extends Literal {\n  type = \"IntegerLiteral\";\n};\nvar FloatLiteral = class extends Literal {\n  type = \"FloatLiteral\";\n};\nvar StringLiteral = class extends Literal {\n  type = \"StringLiteral\";\n};\nvar ArrayLiteral = class extends Literal {\n  type = \"ArrayLiteral\";\n};\nvar TupleLiteral = class extends Literal {\n  type = \"TupleLiteral\";\n};\nvar ObjectLiteral = class extends Literal {\n  type = \"ObjectLiteral\";\n};\nvar BinaryExpression = class extends Expression {\n  constructor(operator, left, right) {\n    super();\n    this.operator = operator;\n    this.left = left;\n    this.right = right;\n  }\n  type = \"BinaryExpression\";\n};\nvar FilterExpression = class extends Expression {\n  constructor(operand, filter) {\n    super();\n    this.operand = operand;\n    this.filter = filter;\n  }\n  type = \"FilterExpression\";\n};\nvar FilterStatement = class extends Statement {\n  constructor(filter, body) {\n    super();\n    this.filter = filter;\n    this.body = body;\n  }\n  type = \"FilterStatement\";\n};\nvar SelectExpression = class extends Expression {\n  constructor(lhs, test) {\n    super();\n    this.lhs = lhs;\n    this.test = test;\n  }\n  type = \"SelectExpression\";\n};\nvar TestExpression = class extends Expression {\n  constructor(operand, negate, test) {\n    super();\n    this.operand = operand;\n    this.negate = negate;\n    this.test = test;\n  }\n  type = \"TestExpression\";\n};\nvar UnaryExpression = class extends Expression {\n  constructor(operator, argument) {\n    super();\n    this.operator = operator;\n    this.argument = argument;\n  }\n  type = \"UnaryExpression\";\n};\nvar SliceExpression = class extends Expression {\n  constructor(start = void 0, stop = void 0, step = void 0) {\n    super();\n    this.start = start;\n    this.stop = stop;\n    this.step = step;\n  }\n  type = \"SliceExpression\";\n};\nvar KeywordArgumentExpression = class extends Expression {\n  constructor(key, value) {\n    super();\n    this.key = key;\n    this.value = value;\n  }\n  type = \"KeywordArgumentExpression\";\n};\nvar SpreadExpression = class extends Expression {\n  constructor(argument) {\n    super();\n    this.argument = argument;\n  }\n  type = \"SpreadExpression\";\n};\nvar CallStatement = class extends Statement {\n  constructor(call, callerArgs, body) {\n    super();\n    this.call = call;\n    this.callerArgs = callerArgs;\n    this.body = body;\n  }\n  type = \"CallStatement\";\n};\nvar Ternary = class extends Expression {\n  constructor(condition, trueExpr, falseExpr) {\n    super();\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n  type = \"Ternary\";\n};\n\n// src/parser.ts\nfunction parse(tokens) {\n  const program = new Program([]);\n  let current = 0;\n  function expect(type, error) {\n    const prev = tokens[current++];\n    if (!prev || prev.type !== type) {\n      throw new Error(`Parser Error: ${error}. ${prev.type} !== ${type}.`);\n    }\n    return prev;\n  }\n  function expectIdentifier(name) {\n    if (!isIdentifier(name)) {\n      throw new SyntaxError(`Expected ${name}`);\n    }\n    ++current;\n  }\n  function parseAny() {\n    switch (tokens[current].type) {\n      case TOKEN_TYPES.Comment:\n        return new Comment(tokens[current++].value);\n      case TOKEN_TYPES.Text:\n        return parseText();\n      case TOKEN_TYPES.OpenStatement:\n        return parseJinjaStatement();\n      case TOKEN_TYPES.OpenExpression:\n        return parseJinjaExpression();\n      default:\n        throw new SyntaxError(`Unexpected token type: ${tokens[current].type}`);\n    }\n  }\n  function is(...types) {\n    return current + types.length <= tokens.length && types.every((type, i) => type === tokens[current + i].type);\n  }\n  function isStatement(...names) {\n    return tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type === TOKEN_TYPES.Identifier && names.includes(tokens[current + 1]?.value);\n  }\n  function isIdentifier(...names) {\n    return current + names.length <= tokens.length && names.every((name, i) => tokens[current + i].type === \"Identifier\" && name === tokens[current + i].value);\n  }\n  function parseText() {\n    return new StringLiteral(expect(TOKEN_TYPES.Text, \"Expected text token\").value);\n  }\n  function parseJinjaStatement() {\n    expect(TOKEN_TYPES.OpenStatement, \"Expected opening statement token\");\n    if (tokens[current].type !== TOKEN_TYPES.Identifier) {\n      throw new SyntaxError(`Unknown statement, got ${tokens[current].type}`);\n    }\n    const name = tokens[current].value;\n    let result;\n    switch (name) {\n      case \"set\":\n        ++current;\n        result = parseSetStatement();\n        break;\n      case \"if\":\n        ++current;\n        result = parseIfStatement();\n        expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n        expectIdentifier(\"endif\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n        break;\n      case \"macro\":\n        ++current;\n        result = parseMacroStatement();\n        expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n        expectIdentifier(\"endmacro\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n        break;\n      case \"for\":\n        ++current;\n        result = parseForStatement();\n        expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n        expectIdentifier(\"endfor\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n        break;\n      case \"call\":\n        {\n          ++current;\n          let callerArgs = null;\n          if (is(TOKEN_TYPES.OpenParen)) {\n            callerArgs = parseArgs();\n          }\n          const callee = parsePrimaryExpression();\n          if (callee.type !== \"Identifier\") {\n            throw new SyntaxError(`Expected identifier following call statement`);\n          }\n          const callArgs = parseArgs();\n          expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n          const body = [];\n          while (!isStatement(\"endcall\")) {\n            body.push(parseAny());\n          }\n          expect(TOKEN_TYPES.OpenStatement, \"Expected '{%'\");\n          expectIdentifier(\"endcall\");\n          expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n          const callExpr = new CallExpression(callee, callArgs);\n          result = new CallStatement(callExpr, callerArgs, body);\n          break;\n        }\n      case \"break\":\n        ++current;\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        result = new Break();\n        break;\n      case \"continue\":\n        ++current;\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        result = new Continue();\n        break;\n      case \"filter\":\n        {\n          ++current;\n          let filterNode = parsePrimaryExpression();\n          if (filterNode instanceof Identifier && is(TOKEN_TYPES.OpenParen)) {\n            filterNode = parseCallExpression(filterNode);\n          }\n          expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n          const filterBody = [];\n          while (!isStatement(\"endfilter\")) {\n            filterBody.push(parseAny());\n          }\n          expect(TOKEN_TYPES.OpenStatement, \"Expected '{%'\");\n          expectIdentifier(\"endfilter\");\n          expect(TOKEN_TYPES.CloseStatement, \"Expected '%}'\");\n          result = new FilterStatement(filterNode, filterBody);\n          break;\n        }\n      default:\n        throw new SyntaxError(`Unknown statement type: ${name}`);\n    }\n    return result;\n  }\n  function parseJinjaExpression() {\n    expect(TOKEN_TYPES.OpenExpression, \"Expected opening expression token\");\n    const result = parseExpression();\n    expect(TOKEN_TYPES.CloseExpression, \"Expected closing expression token\");\n    return result;\n  }\n  function parseSetStatement() {\n    const left = parseExpressionSequence();\n    let value = null;\n    const body = [];\n    if (is(TOKEN_TYPES.Equals)) {\n      ++current;\n      value = parseExpressionSequence();\n    } else {\n      expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n      while (!isStatement(\"endset\")) {\n        body.push(parseAny());\n      }\n      expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n      expectIdentifier(\"endset\");\n    }\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    return new SetStatement(left, value, body);\n  }\n  function parseIfStatement() {\n    const test = parseExpression();\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    const body = [];\n    const alternate = [];\n    while (!isStatement(\"elif\", \"else\", \"endif\")) {\n      body.push(parseAny());\n    }\n    if (isStatement(\"elif\")) {\n      ++current;\n      ++current;\n      const result = parseIfStatement();\n      alternate.push(result);\n    } else if (isStatement(\"else\")) {\n      ++current;\n      ++current;\n      expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n      while (!isStatement(\"endif\")) {\n        alternate.push(parseAny());\n      }\n    }\n    return new If(test, body, alternate);\n  }\n  function parseMacroStatement() {\n    const name = parsePrimaryExpression();\n    if (name.type !== \"Identifier\") {\n      throw new SyntaxError(`Expected identifier following macro statement`);\n    }\n    const args = parseArgs();\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    const body = [];\n    while (!isStatement(\"endmacro\")) {\n      body.push(parseAny());\n    }\n    return new Macro(name, args, body);\n  }\n  function parseExpressionSequence(primary = false) {\n    const fn = primary ? parsePrimaryExpression : parseExpression;\n    const expressions = [fn()];\n    const isTuple = is(TOKEN_TYPES.Comma);\n    while (isTuple) {\n      ++current;\n      expressions.push(fn());\n      if (!is(TOKEN_TYPES.Comma)) {\n        break;\n      }\n    }\n    return isTuple ? new TupleLiteral(expressions) : expressions[0];\n  }\n  function parseForStatement() {\n    const loopVariable = parseExpressionSequence(true);\n    if (!(loopVariable instanceof Identifier || loopVariable instanceof TupleLiteral)) {\n      throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${loopVariable.type} instead`);\n    }\n    if (!isIdentifier(\"in\")) {\n      throw new SyntaxError(\"Expected `in` keyword following loop variable\");\n    }\n    ++current;\n    const iterable = parseExpression();\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    const body = [];\n    while (!isStatement(\"endfor\", \"else\")) {\n      body.push(parseAny());\n    }\n    const alternative = [];\n    if (isStatement(\"else\")) {\n      ++current;\n      ++current;\n      expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n      while (!isStatement(\"endfor\")) {\n        alternative.push(parseAny());\n      }\n    }\n    return new For(loopVariable, iterable, body, alternative);\n  }\n  function parseExpression() {\n    return parseIfExpression();\n  }\n  function parseIfExpression() {\n    const a = parseLogicalOrExpression();\n    if (isIdentifier(\"if\")) {\n      ++current;\n      const test = parseLogicalOrExpression();\n      if (isIdentifier(\"else\")) {\n        ++current;\n        const falseExpr = parseIfExpression();\n        return new Ternary(test, a, falseExpr);\n      } else {\n        return new SelectExpression(a, test);\n      }\n    }\n    return a;\n  }\n  function parseLogicalOrExpression() {\n    let left = parseLogicalAndExpression();\n    while (isIdentifier(\"or\")) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseLogicalAndExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseLogicalAndExpression() {\n    let left = parseLogicalNegationExpression();\n    while (isIdentifier(\"and\")) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseLogicalNegationExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseLogicalNegationExpression() {\n    let right;\n    while (isIdentifier(\"not\")) {\n      const operator = tokens[current];\n      ++current;\n      const arg = parseLogicalNegationExpression();\n      right = new UnaryExpression(operator, arg);\n    }\n    return right ?? parseComparisonExpression();\n  }\n  function parseComparisonExpression() {\n    let left = parseAdditiveExpression();\n    while (true) {\n      let operator;\n      if (isIdentifier(\"not\", \"in\")) {\n        operator = new Token(\"not in\", TOKEN_TYPES.Identifier);\n        current += 2;\n      } else if (isIdentifier(\"in\")) {\n        operator = tokens[current++];\n      } else if (is(TOKEN_TYPES.ComparisonBinaryOperator)) {\n        operator = tokens[current++];\n      } else {\n        break;\n      }\n      const right = parseAdditiveExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseAdditiveExpression() {\n    let left = parseMultiplicativeExpression();\n    while (is(TOKEN_TYPES.AdditiveBinaryOperator)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseMultiplicativeExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseCallMemberExpression() {\n    const member = parseMemberExpression(parsePrimaryExpression());\n    if (is(TOKEN_TYPES.OpenParen)) {\n      return parseCallExpression(member);\n    }\n    return member;\n  }\n  function parseCallExpression(callee) {\n    let expression = new CallExpression(callee, parseArgs());\n    expression = parseMemberExpression(expression);\n    if (is(TOKEN_TYPES.OpenParen)) {\n      expression = parseCallExpression(expression);\n    }\n    return expression;\n  }\n  function parseArgs() {\n    expect(TOKEN_TYPES.OpenParen, \"Expected opening parenthesis for arguments list\");\n    const args = parseArgumentsList();\n    expect(TOKEN_TYPES.CloseParen, \"Expected closing parenthesis for arguments list\");\n    return args;\n  }\n  function parseArgumentsList() {\n    const args = [];\n    while (!is(TOKEN_TYPES.CloseParen)) {\n      let argument;\n      if (tokens[current].type === TOKEN_TYPES.MultiplicativeBinaryOperator && tokens[current].value === \"*\") {\n        ++current;\n        const expr = parseExpression();\n        argument = new SpreadExpression(expr);\n      } else {\n        argument = parseExpression();\n        if (is(TOKEN_TYPES.Equals)) {\n          ++current;\n          if (!(argument instanceof Identifier)) {\n            throw new SyntaxError(`Expected identifier for keyword argument`);\n          }\n          const value = parseExpression();\n          argument = new KeywordArgumentExpression(argument, value);\n        }\n      }\n      args.push(argument);\n      if (is(TOKEN_TYPES.Comma)) {\n        ++current;\n      }\n    }\n    return args;\n  }\n  function parseMemberExpressionArgumentsList() {\n    const slices = [];\n    let isSlice = false;\n    while (!is(TOKEN_TYPES.CloseSquareBracket)) {\n      if (is(TOKEN_TYPES.Colon)) {\n        slices.push(void 0);\n        ++current;\n        isSlice = true;\n      } else {\n        slices.push(parseExpression());\n        if (is(TOKEN_TYPES.Colon)) {\n          ++current;\n          isSlice = true;\n        }\n      }\n    }\n    if (slices.length === 0) {\n      throw new SyntaxError(`Expected at least one argument for member/slice expression`);\n    }\n    if (isSlice) {\n      if (slices.length > 3) {\n        throw new SyntaxError(`Expected 0-3 arguments for slice expression`);\n      }\n      return new SliceExpression(...slices);\n    }\n    return slices[0];\n  }\n  function parseMemberExpression(object) {\n    while (is(TOKEN_TYPES.Dot) || is(TOKEN_TYPES.OpenSquareBracket)) {\n      const operator = tokens[current];\n      ++current;\n      let property;\n      const computed = operator.type === TOKEN_TYPES.OpenSquareBracket;\n      if (computed) {\n        property = parseMemberExpressionArgumentsList();\n        expect(TOKEN_TYPES.CloseSquareBracket, \"Expected closing square bracket\");\n      } else {\n        property = parsePrimaryExpression();\n        if (property.type !== \"Identifier\") {\n          throw new SyntaxError(`Expected identifier following dot operator`);\n        }\n      }\n      object = new MemberExpression(object, property, computed);\n    }\n    return object;\n  }\n  function parseMultiplicativeExpression() {\n    let left = parseTestExpression();\n    while (is(TOKEN_TYPES.MultiplicativeBinaryOperator)) {\n      const operator = tokens[current++];\n      const right = parseTestExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseTestExpression() {\n    let operand = parseFilterExpression();\n    while (isIdentifier(\"is\")) {\n      ++current;\n      const negate = isIdentifier(\"not\");\n      if (negate) {\n        ++current;\n      }\n      const filter = parsePrimaryExpression();\n      if (!(filter instanceof Identifier)) {\n        throw new SyntaxError(`Expected identifier for the test`);\n      }\n      operand = new TestExpression(operand, negate, filter);\n    }\n    return operand;\n  }\n  function parseFilterExpression() {\n    let operand = parseCallMemberExpression();\n    while (is(TOKEN_TYPES.Pipe)) {\n      ++current;\n      let filter = parsePrimaryExpression();\n      if (!(filter instanceof Identifier)) {\n        throw new SyntaxError(`Expected identifier for the filter`);\n      }\n      if (is(TOKEN_TYPES.OpenParen)) {\n        filter = parseCallExpression(filter);\n      }\n      operand = new FilterExpression(operand, filter);\n    }\n    return operand;\n  }\n  function parsePrimaryExpression() {\n    const token = tokens[current++];\n    switch (token.type) {\n      case TOKEN_TYPES.NumericLiteral:\n        {\n          const num = token.value;\n          return num.includes(\".\") ? new FloatLiteral(Number(num)) : new IntegerLiteral(Number(num));\n        }\n      case TOKEN_TYPES.StringLiteral:\n        {\n          let value = token.value;\n          while (is(TOKEN_TYPES.StringLiteral)) {\n            value += tokens[current++].value;\n          }\n          return new StringLiteral(value);\n        }\n      case TOKEN_TYPES.Identifier:\n        return new Identifier(token.value);\n      case TOKEN_TYPES.OpenParen:\n        {\n          const expression = parseExpressionSequence();\n          expect(TOKEN_TYPES.CloseParen, \"Expected closing parenthesis, got ${tokens[current].type} instead.\");\n          return expression;\n        }\n      case TOKEN_TYPES.OpenSquareBracket:\n        {\n          const values = [];\n          while (!is(TOKEN_TYPES.CloseSquareBracket)) {\n            values.push(parseExpression());\n            if (is(TOKEN_TYPES.Comma)) {\n              ++current;\n            }\n          }\n          ++current;\n          return new ArrayLiteral(values);\n        }\n      case TOKEN_TYPES.OpenCurlyBracket:\n        {\n          const values = /* @__PURE__ */new Map();\n          while (!is(TOKEN_TYPES.CloseCurlyBracket)) {\n            const key = parseExpression();\n            expect(TOKEN_TYPES.Colon, \"Expected colon between key and value in object literal\");\n            const value = parseExpression();\n            values.set(key, value);\n            if (is(TOKEN_TYPES.Comma)) {\n              ++current;\n            }\n          }\n          ++current;\n          return new ObjectLiteral(values);\n        }\n      default:\n        throw new SyntaxError(`Unexpected token: ${token.type}`);\n    }\n  }\n  while (current < tokens.length) {\n    program.body.push(parseAny());\n  }\n  return program;\n}\n\n// src/utils.ts\nfunction range(start, stop, step = 1) {\n  if (stop === void 0) {\n    stop = start;\n    start = 0;\n  }\n  const result = [];\n  for (let i = start; i < stop; i += step) {\n    result.push(i);\n  }\n  return result;\n}\nfunction slice(array, start, stop, step = 1) {\n  const direction = Math.sign(step);\n  if (direction >= 0) {\n    start = (start ??= 0) < 0 ? Math.max(array.length + start, 0) : Math.min(start, array.length);\n    stop = (stop ??= array.length) < 0 ? Math.max(array.length + stop, 0) : Math.min(stop, array.length);\n  } else {\n    start = (start ??= array.length - 1) < 0 ? Math.max(array.length + start, -1) : Math.min(start, array.length - 1);\n    stop = (stop ??= -1) < -1 ? Math.max(array.length + stop, -1) : Math.min(stop, array.length - 1);\n  }\n  const result = [];\n  for (let i = start; direction * i < direction * stop; i += step) {\n    result.push(array[i]);\n  }\n  return result;\n}\nfunction titleCase(value) {\n  return value.replace(/\\b\\w/g, c => c.toUpperCase());\n}\nfunction strftime_now(format2) {\n  return strftime(/* @__PURE__ */new Date(), format2);\n}\nfunction strftime(date, format2) {\n  const monthFormatterLong = new Intl.DateTimeFormat(void 0, {\n    month: \"long\"\n  });\n  const monthFormatterShort = new Intl.DateTimeFormat(void 0, {\n    month: \"short\"\n  });\n  const pad2 = n => n < 10 ? \"0\" + n : n.toString();\n  return format2.replace(/%[YmdbBHM%]/g, token => {\n    switch (token) {\n      case \"%Y\":\n        return date.getFullYear().toString();\n      case \"%m\":\n        return pad2(date.getMonth() + 1);\n      case \"%d\":\n        return pad2(date.getDate());\n      case \"%b\":\n        return monthFormatterShort.format(date);\n      case \"%B\":\n        return monthFormatterLong.format(date);\n      case \"%H\":\n        return pad2(date.getHours());\n      case \"%M\":\n        return pad2(date.getMinutes());\n      case \"%%\":\n        return \"%\";\n      default:\n        return token;\n    }\n  });\n}\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction replace(str, oldvalue, newvalue, count) {\n  if (count === 0) return str;\n  let remaining = count == null || count < 0 ? Infinity : count;\n  const pattern = oldvalue.length === 0 ? new RegExp(\"(?=)\", \"gu\") : new RegExp(escapeRegExp(oldvalue), \"gu\");\n  return str.replaceAll(pattern, match => {\n    if (remaining > 0) {\n      --remaining;\n      return newvalue;\n    }\n    return match;\n  });\n}\n\n// src/runtime.ts\nvar BreakControl = class extends Error {};\nvar ContinueControl = class extends Error {};\nvar RuntimeValue = class {\n  type = \"RuntimeValue\";\n  value;\n  /**\n   * A collection of built-in functions for this type.\n   */\n  builtins = /* @__PURE__ */new Map();\n  /**\n   * Creates a new RuntimeValue.\n   */\n  constructor(value = void 0) {\n    this.value = value;\n  }\n  /**\n   * Determines truthiness or falsiness of the runtime value.\n   * This function should be overridden by subclasses if it has custom truthiness criteria.\n   * @returns {BooleanValue} BooleanValue(true) if the value is truthy, BooleanValue(false) otherwise.\n   */\n  __bool__() {\n    return new BooleanValue(!!this.value);\n  }\n  toString() {\n    return String(this.value);\n  }\n};\nvar IntegerValue = class extends RuntimeValue {\n  type = \"IntegerValue\";\n};\nvar FloatValue = class extends RuntimeValue {\n  type = \"FloatValue\";\n  toString() {\n    return this.value % 1 === 0 ? this.value.toFixed(1) : this.value.toString();\n  }\n};\nvar StringValue = class extends RuntimeValue {\n  type = \"StringValue\";\n  builtins = /* @__PURE__ */new Map([[\"upper\", new FunctionValue(() => {\n    return new StringValue(this.value.toUpperCase());\n  })], [\"lower\", new FunctionValue(() => {\n    return new StringValue(this.value.toLowerCase());\n  })], [\"strip\", new FunctionValue(() => {\n    return new StringValue(this.value.trim());\n  })], [\"title\", new FunctionValue(() => {\n    return new StringValue(titleCase(this.value));\n  })], [\"capitalize\", new FunctionValue(() => {\n    return new StringValue(this.value.charAt(0).toUpperCase() + this.value.slice(1));\n  })], [\"length\", new IntegerValue(this.value.length)], [\"rstrip\", new FunctionValue(() => {\n    return new StringValue(this.value.trimEnd());\n  })], [\"lstrip\", new FunctionValue(() => {\n    return new StringValue(this.value.trimStart());\n  })], [\"startswith\", new FunctionValue(args => {\n    if (args.length === 0) {\n      throw new Error(\"startswith() requires at least one argument\");\n    }\n    const pattern = args[0];\n    if (pattern instanceof StringValue) {\n      return new BooleanValue(this.value.startsWith(pattern.value));\n    } else if (pattern instanceof ArrayValue) {\n      for (const item of pattern.value) {\n        if (!(item instanceof StringValue)) {\n          throw new Error(\"startswith() tuple elements must be strings\");\n        }\n        if (this.value.startsWith(item.value)) {\n          return new BooleanValue(true);\n        }\n      }\n      return new BooleanValue(false);\n    }\n    throw new Error(\"startswith() argument must be a string or tuple of strings\");\n  })], [\"endswith\", new FunctionValue(args => {\n    if (args.length === 0) {\n      throw new Error(\"endswith() requires at least one argument\");\n    }\n    const pattern = args[0];\n    if (pattern instanceof StringValue) {\n      return new BooleanValue(this.value.endsWith(pattern.value));\n    } else if (pattern instanceof ArrayValue) {\n      for (const item of pattern.value) {\n        if (!(item instanceof StringValue)) {\n          throw new Error(\"endswith() tuple elements must be strings\");\n        }\n        if (this.value.endsWith(item.value)) {\n          return new BooleanValue(true);\n        }\n      }\n      return new BooleanValue(false);\n    }\n    throw new Error(\"endswith() argument must be a string or tuple of strings\");\n  })], [\"split\",\n  // follows Python's `str.split(sep=None, maxsplit=-1)` function behavior\n  // https://docs.python.org/3.13/library/stdtypes.html#str.split\n  new FunctionValue(args => {\n    const sep = args[0] ?? new NullValue();\n    if (!(sep instanceof StringValue || sep instanceof NullValue)) {\n      throw new Error(\"sep argument must be a string or null\");\n    }\n    const maxsplit = args[1] ?? new IntegerValue(-1);\n    if (!(maxsplit instanceof IntegerValue)) {\n      throw new Error(\"maxsplit argument must be a number\");\n    }\n    let result = [];\n    if (sep instanceof NullValue) {\n      const text = this.value.trimStart();\n      for (const {\n        0: match,\n        index\n      } of text.matchAll(/\\S+/g)) {\n        if (maxsplit.value !== -1 && result.length >= maxsplit.value && index !== void 0) {\n          result.push(match + text.slice(index + match.length));\n          break;\n        }\n        result.push(match);\n      }\n    } else {\n      if (sep.value === \"\") {\n        throw new Error(\"empty separator\");\n      }\n      result = this.value.split(sep.value);\n      if (maxsplit.value !== -1 && result.length > maxsplit.value) {\n        result.push(result.splice(maxsplit.value).join(sep.value));\n      }\n    }\n    return new ArrayValue(result.map(part => new StringValue(part)));\n  })], [\"replace\", new FunctionValue(args => {\n    if (args.length < 2) {\n      throw new Error(\"replace() requires at least two arguments\");\n    }\n    const oldValue = args[0];\n    const newValue = args[1];\n    if (!(oldValue instanceof StringValue && newValue instanceof StringValue)) {\n      throw new Error(\"replace() arguments must be strings\");\n    }\n    let count;\n    if (args.length > 2) {\n      if (args[2].type === \"KeywordArgumentsValue\") {\n        count = args[2].value.get(\"count\") ?? new NullValue();\n      } else {\n        count = args[2];\n      }\n    } else {\n      count = new NullValue();\n    }\n    if (!(count instanceof IntegerValue || count instanceof NullValue)) {\n      throw new Error(\"replace() count argument must be a number or null\");\n    }\n    return new StringValue(replace(this.value, oldValue.value, newValue.value, count.value));\n  })]]);\n};\nvar BooleanValue = class extends RuntimeValue {\n  type = \"BooleanValue\";\n};\nvar ObjectValue = class extends RuntimeValue {\n  type = \"ObjectValue\";\n  /**\n   * NOTE: necessary to override since all JavaScript arrays are considered truthy,\n   * while only non-empty Python arrays are consider truthy.\n   *\n   * e.g.,\n   *  - JavaScript:  {} && 5 -> 5\n   *  - Python:      {} and 5 -> {}\n   */\n  __bool__() {\n    return new BooleanValue(this.value.size > 0);\n  }\n  builtins = /* @__PURE__ */new Map([[\"get\", new FunctionValue(([key, defaultValue]) => {\n    if (!(key instanceof StringValue)) {\n      throw new Error(`Object key must be a string: got ${key.type}`);\n    }\n    return this.value.get(key.value) ?? defaultValue ?? new NullValue();\n  })], [\"items\", new FunctionValue(() => this.items())], [\"keys\", new FunctionValue(() => this.keys())], [\"values\", new FunctionValue(() => this.values())]]);\n  items() {\n    return new ArrayValue(Array.from(this.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value])));\n  }\n  keys() {\n    return new ArrayValue(Array.from(this.value.keys()).map(key => new StringValue(key)));\n  }\n  values() {\n    return new ArrayValue(Array.from(this.value.values()));\n  }\n};\nvar KeywordArgumentsValue = class extends ObjectValue {\n  type = \"KeywordArgumentsValue\";\n};\nvar ArrayValue = class extends RuntimeValue {\n  type = \"ArrayValue\";\n  builtins = /* @__PURE__ */new Map([[\"length\", new IntegerValue(this.value.length)]]);\n  /**\n   * NOTE: necessary to override since all JavaScript arrays are considered truthy,\n   * while only non-empty Python arrays are consider truthy.\n   *\n   * e.g.,\n   *  - JavaScript:  [] && 5 -> 5\n   *  - Python:      [] and 5 -> []\n   */\n  __bool__() {\n    return new BooleanValue(this.value.length > 0);\n  }\n};\nvar TupleValue = class extends ArrayValue {\n  type = \"TupleValue\";\n};\nvar FunctionValue = class extends RuntimeValue {\n  type = \"FunctionValue\";\n};\nvar NullValue = class extends RuntimeValue {\n  type = \"NullValue\";\n};\nvar UndefinedValue = class extends RuntimeValue {\n  type = \"UndefinedValue\";\n};\nvar Environment = class {\n  constructor(parent) {\n    this.parent = parent;\n  }\n  /**\n   * The variables declared in this environment.\n   */\n  variables = /* @__PURE__ */new Map([[\"namespace\", new FunctionValue(args => {\n    if (args.length === 0) {\n      return new ObjectValue(/* @__PURE__ */new Map());\n    }\n    if (args.length !== 1 || !(args[0] instanceof ObjectValue)) {\n      throw new Error(\"`namespace` expects either zero arguments or a single object argument\");\n    }\n    return args[0];\n  })]]);\n  /**\n   * The tests available in this environment.\n   */\n  tests = /* @__PURE__ */new Map([[\"boolean\", operand => operand.type === \"BooleanValue\"], [\"callable\", operand => operand instanceof FunctionValue], [\"odd\", operand => {\n    if (!(operand instanceof IntegerValue)) {\n      throw new Error(`cannot odd on ${operand.type}`);\n    }\n    return operand.value % 2 !== 0;\n  }], [\"even\", operand => {\n    if (!(operand instanceof IntegerValue)) {\n      throw new Error(`cannot even on ${operand.type}`);\n    }\n    return operand.value % 2 === 0;\n  }], [\"false\", operand => operand.type === \"BooleanValue\" && !operand.value], [\"true\", operand => operand.type === \"BooleanValue\" && operand.value], [\"none\", operand => operand.type === \"NullValue\"], [\"string\", operand => operand.type === \"StringValue\"], [\"number\", operand => operand instanceof IntegerValue || operand instanceof FloatValue], [\"integer\", operand => operand instanceof IntegerValue], [\"iterable\", operand => operand.type === \"ArrayValue\" || operand.type === \"StringValue\"], [\"mapping\", operand => operand.type === \"ObjectValue\"], [\"lower\", operand => {\n    const str = operand.value;\n    return operand.type === \"StringValue\" && str === str.toLowerCase();\n  }], [\"upper\", operand => {\n    const str = operand.value;\n    return operand.type === \"StringValue\" && str === str.toUpperCase();\n  }], [\"none\", operand => operand.type === \"NullValue\"], [\"defined\", operand => operand.type !== \"UndefinedValue\"], [\"undefined\", operand => operand.type === \"UndefinedValue\"], [\"equalto\", (a, b) => a.value === b.value], [\"eq\", (a, b) => a.value === b.value]]);\n  /**\n   * Set the value of a variable in the current environment.\n   */\n  set(name, value) {\n    return this.declareVariable(name, convertToRuntimeValues(value));\n  }\n  declareVariable(name, value) {\n    if (this.variables.has(name)) {\n      throw new SyntaxError(`Variable already declared: ${name}`);\n    }\n    this.variables.set(name, value);\n    return value;\n  }\n  // private assignVariable(name: string, value: AnyRuntimeValue): AnyRuntimeValue {\n  // \tconst env = this.resolve(name);\n  // \tenv.variables.set(name, value);\n  // \treturn value;\n  // }\n  /**\n   * Set variable in the current scope.\n   * See https://jinja.palletsprojects.com/en/3.0.x/templates/#assignments for more information.\n   */\n  setVariable(name, value) {\n    this.variables.set(name, value);\n    return value;\n  }\n  /**\n   * Resolve the environment in which the variable is declared.\n   * @param {string} name The name of the variable.\n   * @returns {Environment} The environment in which the variable is declared.\n   */\n  resolve(name) {\n    if (this.variables.has(name)) {\n      return this;\n    }\n    if (this.parent) {\n      return this.parent.resolve(name);\n    }\n    throw new Error(`Unknown variable: ${name}`);\n  }\n  lookupVariable(name) {\n    try {\n      return this.resolve(name).variables.get(name) ?? new UndefinedValue();\n    } catch {\n      return new UndefinedValue();\n    }\n  }\n};\nfunction setupGlobals(env) {\n  env.set(\"false\", false);\n  env.set(\"true\", true);\n  env.set(\"none\", null);\n  env.set(\"raise_exception\", args => {\n    throw new Error(args);\n  });\n  env.set(\"range\", range);\n  env.set(\"strftime_now\", strftime_now);\n  env.set(\"True\", true);\n  env.set(\"False\", false);\n  env.set(\"None\", null);\n}\nvar Interpreter = class {\n  global;\n  constructor(env) {\n    this.global = env ?? new Environment();\n  }\n  /**\n   * Run the program.\n   */\n  run(program) {\n    return this.evaluate(program, this.global);\n  }\n  /**\n   * Evaluates expressions following the binary operation type.\n   */\n  evaluateBinaryExpression(node, environment) {\n    const left = this.evaluate(node.left, environment);\n    switch (node.operator.value) {\n      case \"and\":\n        return left.__bool__().value ? this.evaluate(node.right, environment) : left;\n      case \"or\":\n        return left.__bool__().value ? left : this.evaluate(node.right, environment);\n    }\n    const right = this.evaluate(node.right, environment);\n    switch (node.operator.value) {\n      case \"==\":\n        return new BooleanValue(left.value == right.value);\n      case \"!=\":\n        return new BooleanValue(left.value != right.value);\n    }\n    if (left instanceof UndefinedValue || right instanceof UndefinedValue) {\n      if (right instanceof UndefinedValue && [\"in\", \"not in\"].includes(node.operator.value)) {\n        return new BooleanValue(node.operator.value === \"not in\");\n      }\n      throw new Error(`Cannot perform operation ${node.operator.value} on undefined values`);\n    } else if (left instanceof NullValue || right instanceof NullValue) {\n      throw new Error(\"Cannot perform operation on null values\");\n    } else if (node.operator.value === \"~\") {\n      return new StringValue(left.value.toString() + right.value.toString());\n    } else if ((left instanceof IntegerValue || left instanceof FloatValue) && (right instanceof IntegerValue || right instanceof FloatValue)) {\n      const a = left.value,\n        b = right.value;\n      switch (node.operator.value) {\n        case \"+\":\n        case \"-\":\n        case \"*\":\n          {\n            const res = node.operator.value === \"+\" ? a + b : node.operator.value === \"-\" ? a - b : a * b;\n            const isFloat = left instanceof FloatValue || right instanceof FloatValue;\n            return isFloat ? new FloatValue(res) : new IntegerValue(res);\n          }\n        case \"/\":\n          return new FloatValue(a / b);\n        case \"%\":\n          {\n            const rem = a % b;\n            const isFloat = left instanceof FloatValue || right instanceof FloatValue;\n            return isFloat ? new FloatValue(rem) : new IntegerValue(rem);\n          }\n        case \"<\":\n          return new BooleanValue(a < b);\n        case \">\":\n          return new BooleanValue(a > b);\n        case \">=\":\n          return new BooleanValue(a >= b);\n        case \"<=\":\n          return new BooleanValue(a <= b);\n      }\n    } else if (left instanceof ArrayValue && right instanceof ArrayValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new ArrayValue(left.value.concat(right.value));\n      }\n    } else if (right instanceof ArrayValue) {\n      const member = right.value.find(x => x.value === left.value) !== void 0;\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(member);\n        case \"not in\":\n          return new BooleanValue(!member);\n      }\n    }\n    if (left instanceof StringValue || right instanceof StringValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new StringValue(left.value.toString() + right.value.toString());\n      }\n    }\n    if (left instanceof StringValue && right instanceof StringValue) {\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(right.value.includes(left.value));\n        case \"not in\":\n          return new BooleanValue(!right.value.includes(left.value));\n      }\n    }\n    if (left instanceof StringValue && right instanceof ObjectValue) {\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(right.value.has(left.value));\n        case \"not in\":\n          return new BooleanValue(!right.value.has(left.value));\n      }\n    }\n    throw new SyntaxError(`Unknown operator \"${node.operator.value}\" between ${left.type} and ${right.type}`);\n  }\n  evaluateArguments(args, environment) {\n    const positionalArguments = [];\n    const keywordArguments = /* @__PURE__ */new Map();\n    for (const argument of args) {\n      if (argument.type === \"SpreadExpression\") {\n        const spreadNode = argument;\n        const val = this.evaluate(spreadNode.argument, environment);\n        if (!(val instanceof ArrayValue)) {\n          throw new Error(`Cannot unpack non-iterable type: ${val.type}`);\n        }\n        for (const item of val.value) {\n          positionalArguments.push(item);\n        }\n      } else if (argument.type === \"KeywordArgumentExpression\") {\n        const kwarg = argument;\n        keywordArguments.set(kwarg.key.value, this.evaluate(kwarg.value, environment));\n      } else {\n        if (keywordArguments.size > 0) {\n          throw new Error(\"Positional arguments must come before keyword arguments\");\n        }\n        positionalArguments.push(this.evaluate(argument, environment));\n      }\n    }\n    return [positionalArguments, keywordArguments];\n  }\n  applyFilter(operand, filterNode, environment) {\n    if (filterNode.type === \"Identifier\") {\n      const filter = filterNode;\n      if (filter.value === \"tojson\") {\n        return new StringValue(toJSON(operand));\n      }\n      if (operand instanceof ArrayValue) {\n        switch (filter.value) {\n          case \"list\":\n            return operand;\n          case \"first\":\n            return operand.value[0];\n          case \"last\":\n            return operand.value[operand.value.length - 1];\n          case \"length\":\n            return new IntegerValue(operand.value.length);\n          case \"reverse\":\n            return new ArrayValue(operand.value.reverse());\n          case \"sort\":\n            return new ArrayValue(operand.value.sort((a, b) => {\n              if (a.type !== b.type) {\n                throw new Error(`Cannot compare different types: ${a.type} and ${b.type}`);\n              }\n              switch (a.type) {\n                case \"IntegerValue\":\n                case \"FloatValue\":\n                  return a.value - b.value;\n                case \"StringValue\":\n                  return a.value.localeCompare(b.value);\n                default:\n                  throw new Error(`Cannot compare type: ${a.type}`);\n              }\n            }));\n          case \"join\":\n            return new StringValue(operand.value.map(x => x.value).join(\"\"));\n          case \"string\":\n            return new StringValue(toJSON(operand));\n          case \"unique\":\n            {\n              const seen = /* @__PURE__ */new Set();\n              const output = [];\n              for (const item of operand.value) {\n                if (!seen.has(item.value)) {\n                  seen.add(item.value);\n                  output.push(item);\n                }\n              }\n              return new ArrayValue(output);\n            }\n          default:\n            throw new Error(`Unknown ArrayValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof StringValue) {\n        switch (filter.value) {\n          case \"length\":\n          case \"upper\":\n          case \"lower\":\n          case \"title\":\n          case \"capitalize\":\n            {\n              const builtin = operand.builtins.get(filter.value);\n              if (builtin instanceof FunctionValue) {\n                return builtin.value(/* no arguments */\n                [], environment);\n              } else if (builtin instanceof IntegerValue) {\n                return builtin;\n              } else {\n                throw new Error(`Unknown StringValue filter: ${filter.value}`);\n              }\n            }\n          case \"trim\":\n            return new StringValue(operand.value.trim());\n          case \"indent\":\n            return new StringValue(operand.value.split(\"\\n\").map((x, i) =>\n            // By default, don't indent the first line or empty lines\n            i === 0 || x.length === 0 ? x : \"    \" + x).join(\"\\n\"));\n          case \"join\":\n          case \"string\":\n            return operand;\n          case \"int\":\n            {\n              const val = parseInt(operand.value, 10);\n              return new IntegerValue(isNaN(val) ? 0 : val);\n            }\n          case \"float\":\n            {\n              const val = parseFloat(operand.value);\n              return new FloatValue(isNaN(val) ? 0 : val);\n            }\n          default:\n            throw new Error(`Unknown StringValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof IntegerValue || operand instanceof FloatValue) {\n        switch (filter.value) {\n          case \"abs\":\n            return operand instanceof IntegerValue ? new IntegerValue(Math.abs(operand.value)) : new FloatValue(Math.abs(operand.value));\n          case \"int\":\n            return new IntegerValue(Math.floor(operand.value));\n          case \"float\":\n            return new FloatValue(operand.value);\n          default:\n            throw new Error(`Unknown NumericValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof ObjectValue) {\n        switch (filter.value) {\n          case \"items\":\n            return new ArrayValue(Array.from(operand.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value])));\n          case \"length\":\n            return new IntegerValue(operand.value.size);\n          default:\n            throw new Error(`Unknown ObjectValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof BooleanValue) {\n        switch (filter.value) {\n          case \"bool\":\n            return new BooleanValue(operand.value);\n          case \"int\":\n            return new IntegerValue(operand.value ? 1 : 0);\n          case \"float\":\n            return new FloatValue(operand.value ? 1 : 0);\n          case \"string\":\n            return new StringValue(operand.value ? \"true\" : \"false\");\n          default:\n            throw new Error(`Unknown BooleanValue filter: ${filter.value}`);\n        }\n      }\n      throw new Error(`Cannot apply filter \"${filter.value}\" to type: ${operand.type}`);\n    } else if (filterNode.type === \"CallExpression\") {\n      const filter = filterNode;\n      if (filter.callee.type !== \"Identifier\") {\n        throw new Error(`Unknown filter: ${filter.callee.type}`);\n      }\n      const filterName = filter.callee.value;\n      if (filterName === \"tojson\") {\n        const [, kwargs] = this.evaluateArguments(filter.args, environment);\n        const indent = kwargs.get(\"indent\") ?? new NullValue();\n        if (!(indent instanceof IntegerValue || indent instanceof NullValue)) {\n          throw new Error(\"If set, indent must be a number\");\n        }\n        return new StringValue(toJSON(operand, indent.value));\n      } else if (filterName === \"join\") {\n        let value;\n        if (operand instanceof StringValue) {\n          value = Array.from(operand.value);\n        } else if (operand instanceof ArrayValue) {\n          value = operand.value.map(x => x.value);\n        } else {\n          throw new Error(`Cannot apply filter \"${filterName}\" to type: ${operand.type}`);\n        }\n        const [args, kwargs] = this.evaluateArguments(filter.args, environment);\n        const separator = args.at(0) ?? kwargs.get(\"separator\") ?? new StringValue(\"\");\n        if (!(separator instanceof StringValue)) {\n          throw new Error(\"separator must be a string\");\n        }\n        return new StringValue(value.join(separator.value));\n      } else if (filterName === \"int\" || filterName === \"float\") {\n        const [args, kwargs] = this.evaluateArguments(filter.args, environment);\n        const defaultValue = args.at(0) ?? kwargs.get(\"default\") ?? (filterName === \"int\" ? new IntegerValue(0) : new FloatValue(0));\n        if (operand instanceof StringValue) {\n          const val = filterName === \"int\" ? parseInt(operand.value, 10) : parseFloat(operand.value);\n          return isNaN(val) ? defaultValue : filterName === \"int\" ? new IntegerValue(val) : new FloatValue(val);\n        } else if (operand instanceof IntegerValue || operand instanceof FloatValue) {\n          return operand;\n        } else if (operand instanceof BooleanValue) {\n          return filterName === \"int\" ? new IntegerValue(operand.value ? 1 : 0) : new FloatValue(operand.value ? 1 : 0);\n        } else {\n          throw new Error(`Cannot apply filter \"${filterName}\" to type: ${operand.type}`);\n        }\n      } else if (filterName === \"default\") {\n        const [args, kwargs] = this.evaluateArguments(filter.args, environment);\n        const defaultValue = args[0] ?? new StringValue(\"\");\n        const booleanValue = args[1] ?? kwargs.get(\"boolean\") ?? new BooleanValue(false);\n        if (!(booleanValue instanceof BooleanValue)) {\n          throw new Error(\"`default` filter flag must be a boolean\");\n        }\n        if (operand instanceof UndefinedValue || booleanValue.value && !operand.__bool__().value) {\n          return defaultValue;\n        }\n        return operand;\n      }\n      if (operand instanceof ArrayValue) {\n        switch (filterName) {\n          case \"selectattr\":\n          case \"rejectattr\":\n            {\n              const select = filterName === \"selectattr\";\n              if (operand.value.some(x => !(x instanceof ObjectValue))) {\n                throw new Error(`\\`${filterName}\\` can only be applied to array of objects`);\n              }\n              if (filter.args.some(x => x.type !== \"StringLiteral\")) {\n                throw new Error(`arguments of \\`${filterName}\\` must be strings`);\n              }\n              const [attr, testName, value] = filter.args.map(x => this.evaluate(x, environment));\n              let testFunction;\n              if (testName) {\n                const test = environment.tests.get(testName.value);\n                if (!test) {\n                  throw new Error(`Unknown test: ${testName.value}`);\n                }\n                testFunction = test;\n              } else {\n                testFunction = (...x) => x[0].__bool__().value;\n              }\n              const filtered = operand.value.filter(item => {\n                const a = item.value.get(attr.value);\n                const result = a ? testFunction(a, value) : false;\n                return select ? result : !result;\n              });\n              return new ArrayValue(filtered);\n            }\n          case \"map\":\n            {\n              const [, kwargs] = this.evaluateArguments(filter.args, environment);\n              if (kwargs.has(\"attribute\")) {\n                const attr = kwargs.get(\"attribute\");\n                if (!(attr instanceof StringValue)) {\n                  throw new Error(\"attribute must be a string\");\n                }\n                const defaultValue = kwargs.get(\"default\");\n                const mapped = operand.value.map(item => {\n                  if (!(item instanceof ObjectValue)) {\n                    throw new Error(\"items in map must be an object\");\n                  }\n                  return item.value.get(attr.value) ?? defaultValue ?? new UndefinedValue();\n                });\n                return new ArrayValue(mapped);\n              } else {\n                throw new Error(\"`map` expressions without `attribute` set are not currently supported.\");\n              }\n            }\n        }\n        throw new Error(`Unknown ArrayValue filter: ${filterName}`);\n      } else if (operand instanceof StringValue) {\n        switch (filterName) {\n          case \"indent\":\n            {\n              const [args, kwargs] = this.evaluateArguments(filter.args, environment);\n              const width = args.at(0) ?? kwargs.get(\"width\") ?? new IntegerValue(4);\n              if (!(width instanceof IntegerValue)) {\n                throw new Error(\"width must be a number\");\n              }\n              const first = args.at(1) ?? kwargs.get(\"first\") ?? new BooleanValue(false);\n              const blank = args.at(2) ?? kwargs.get(\"blank\") ?? new BooleanValue(false);\n              const lines = operand.value.split(\"\\n\");\n              const indent = \" \".repeat(width.value);\n              const indented = lines.map((x, i) => !first.value && i === 0 || !blank.value && x.length === 0 ? x : indent + x);\n              return new StringValue(indented.join(\"\\n\"));\n            }\n          case \"replace\":\n            {\n              const replaceFn = operand.builtins.get(\"replace\");\n              if (!(replaceFn instanceof FunctionValue)) {\n                throw new Error(\"replace filter not available\");\n              }\n              const [args, kwargs] = this.evaluateArguments(filter.args, environment);\n              return replaceFn.value([...args, new KeywordArgumentsValue(kwargs)], environment);\n            }\n        }\n        throw new Error(`Unknown StringValue filter: ${filterName}`);\n      } else {\n        throw new Error(`Cannot apply filter \"${filterName}\" to type: ${operand.type}`);\n      }\n    }\n    throw new Error(`Unknown filter: ${filterNode.type}`);\n  }\n  /**\n   * Evaluates expressions following the filter operation type.\n   */\n  evaluateFilterExpression(node, environment) {\n    const operand = this.evaluate(node.operand, environment);\n    return this.applyFilter(operand, node.filter, environment);\n  }\n  /**\n   * Evaluates expressions following the test operation type.\n   */\n  evaluateTestExpression(node, environment) {\n    const operand = this.evaluate(node.operand, environment);\n    const test = environment.tests.get(node.test.value);\n    if (!test) {\n      throw new Error(`Unknown test: ${node.test.value}`);\n    }\n    const result = test(operand);\n    return new BooleanValue(node.negate ? !result : result);\n  }\n  /**\n   * Evaluates expressions following the select operation type.\n   */\n  evaluateSelectExpression(node, environment) {\n    const predicate = this.evaluate(node.test, environment);\n    if (!predicate.__bool__().value) {\n      return new UndefinedValue();\n    }\n    return this.evaluate(node.lhs, environment);\n  }\n  /**\n   * Evaluates expressions following the unary operation type.\n   */\n  evaluateUnaryExpression(node, environment) {\n    const argument = this.evaluate(node.argument, environment);\n    switch (node.operator.value) {\n      case \"not\":\n        return new BooleanValue(!argument.value);\n      default:\n        throw new SyntaxError(`Unknown operator: ${node.operator.value}`);\n    }\n  }\n  evaluateTernaryExpression(node, environment) {\n    const cond = this.evaluate(node.condition, environment);\n    return cond.__bool__().value ? this.evaluate(node.trueExpr, environment) : this.evaluate(node.falseExpr, environment);\n  }\n  evalProgram(program, environment) {\n    return this.evaluateBlock(program.body, environment);\n  }\n  evaluateBlock(statements, environment) {\n    let result = \"\";\n    for (const statement of statements) {\n      const lastEvaluated = this.evaluate(statement, environment);\n      if (lastEvaluated.type !== \"NullValue\" && lastEvaluated.type !== \"UndefinedValue\") {\n        result += lastEvaluated.toString();\n      }\n    }\n    return new StringValue(result);\n  }\n  evaluateIdentifier(node, environment) {\n    return environment.lookupVariable(node.value);\n  }\n  evaluateCallExpression(expr, environment) {\n    const [args, kwargs] = this.evaluateArguments(expr.args, environment);\n    if (kwargs.size > 0) {\n      args.push(new KeywordArgumentsValue(kwargs));\n    }\n    const fn = this.evaluate(expr.callee, environment);\n    if (fn.type !== \"FunctionValue\") {\n      throw new Error(`Cannot call something that is not a function: got ${fn.type}`);\n    }\n    return fn.value(args, environment);\n  }\n  evaluateSliceExpression(object, expr, environment) {\n    if (!(object instanceof ArrayValue || object instanceof StringValue)) {\n      throw new Error(\"Slice object must be an array or string\");\n    }\n    const start = this.evaluate(expr.start, environment);\n    const stop = this.evaluate(expr.stop, environment);\n    const step = this.evaluate(expr.step, environment);\n    if (!(start instanceof IntegerValue || start instanceof UndefinedValue)) {\n      throw new Error(\"Slice start must be numeric or undefined\");\n    }\n    if (!(stop instanceof IntegerValue || stop instanceof UndefinedValue)) {\n      throw new Error(\"Slice stop must be numeric or undefined\");\n    }\n    if (!(step instanceof IntegerValue || step instanceof UndefinedValue)) {\n      throw new Error(\"Slice step must be numeric or undefined\");\n    }\n    if (object instanceof ArrayValue) {\n      return new ArrayValue(slice(object.value, start.value, stop.value, step.value));\n    } else {\n      return new StringValue(slice(Array.from(object.value), start.value, stop.value, step.value).join(\"\"));\n    }\n  }\n  evaluateMemberExpression(expr, environment) {\n    const object = this.evaluate(expr.object, environment);\n    let property;\n    if (expr.computed) {\n      if (expr.property.type === \"SliceExpression\") {\n        return this.evaluateSliceExpression(object, expr.property, environment);\n      } else {\n        property = this.evaluate(expr.property, environment);\n      }\n    } else {\n      property = new StringValue(expr.property.value);\n    }\n    let value;\n    if (object instanceof ObjectValue) {\n      if (!(property instanceof StringValue)) {\n        throw new Error(`Cannot access property with non-string: got ${property.type}`);\n      }\n      value = object.value.get(property.value) ?? object.builtins.get(property.value);\n    } else if (object instanceof ArrayValue || object instanceof StringValue) {\n      if (property instanceof IntegerValue) {\n        value = object.value.at(property.value);\n        if (object instanceof StringValue) {\n          value = new StringValue(object.value.at(property.value));\n        }\n      } else if (property instanceof StringValue) {\n        value = object.builtins.get(property.value);\n      } else {\n        throw new Error(`Cannot access property with non-string/non-number: got ${property.type}`);\n      }\n    } else {\n      if (!(property instanceof StringValue)) {\n        throw new Error(`Cannot access property with non-string: got ${property.type}`);\n      }\n      value = object.builtins.get(property.value);\n    }\n    return value instanceof RuntimeValue ? value : new UndefinedValue();\n  }\n  evaluateSet(node, environment) {\n    const rhs = node.value ? this.evaluate(node.value, environment) : this.evaluateBlock(node.body, environment);\n    if (node.assignee.type === \"Identifier\") {\n      const variableName = node.assignee.value;\n      environment.setVariable(variableName, rhs);\n    } else if (node.assignee.type === \"TupleLiteral\") {\n      const tuple = node.assignee;\n      if (!(rhs instanceof ArrayValue)) {\n        throw new Error(`Cannot unpack non-iterable type in set: ${rhs.type}`);\n      }\n      const arr = rhs.value;\n      if (arr.length !== tuple.value.length) {\n        throw new Error(`Too ${tuple.value.length > arr.length ? \"few\" : \"many\"} items to unpack in set`);\n      }\n      for (let i = 0; i < tuple.value.length; ++i) {\n        const elem = tuple.value[i];\n        if (elem.type !== \"Identifier\") {\n          throw new Error(`Cannot unpack to non-identifier in set: ${elem.type}`);\n        }\n        environment.setVariable(elem.value, arr[i]);\n      }\n    } else if (node.assignee.type === \"MemberExpression\") {\n      const member = node.assignee;\n      const object = this.evaluate(member.object, environment);\n      if (!(object instanceof ObjectValue)) {\n        throw new Error(\"Cannot assign to member of non-object\");\n      }\n      if (member.property.type !== \"Identifier\") {\n        throw new Error(\"Cannot assign to member with non-identifier property\");\n      }\n      object.value.set(member.property.value, rhs);\n    } else {\n      throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(node.assignee)}`);\n    }\n    return new NullValue();\n  }\n  evaluateIf(node, environment) {\n    const test = this.evaluate(node.test, environment);\n    return this.evaluateBlock(test.__bool__().value ? node.body : node.alternate, environment);\n  }\n  evaluateFor(node, environment) {\n    const scope = new Environment(environment);\n    let test, iterable;\n    if (node.iterable.type === \"SelectExpression\") {\n      const select = node.iterable;\n      iterable = this.evaluate(select.lhs, scope);\n      test = select.test;\n    } else {\n      iterable = this.evaluate(node.iterable, scope);\n    }\n    if (!(iterable instanceof ArrayValue || iterable instanceof ObjectValue)) {\n      throw new Error(`Expected iterable or object type in for loop: got ${iterable.type}`);\n    }\n    if (iterable instanceof ObjectValue) {\n      iterable = iterable.keys();\n    }\n    const items = [];\n    const scopeUpdateFunctions = [];\n    for (let i = 0; i < iterable.value.length; ++i) {\n      const loopScope = new Environment(scope);\n      const current = iterable.value[i];\n      let scopeUpdateFunction;\n      if (node.loopvar.type === \"Identifier\") {\n        scopeUpdateFunction = scope2 => scope2.setVariable(node.loopvar.value, current);\n      } else if (node.loopvar.type === \"TupleLiteral\") {\n        const loopvar = node.loopvar;\n        if (current.type !== \"ArrayValue\") {\n          throw new Error(`Cannot unpack non-iterable type: ${current.type}`);\n        }\n        const c = current;\n        if (loopvar.value.length !== c.value.length) {\n          throw new Error(`Too ${loopvar.value.length > c.value.length ? \"few\" : \"many\"} items to unpack`);\n        }\n        scopeUpdateFunction = scope2 => {\n          for (let j = 0; j < loopvar.value.length; ++j) {\n            if (loopvar.value[j].type !== \"Identifier\") {\n              throw new Error(`Cannot unpack non-identifier type: ${loopvar.value[j].type}`);\n            }\n            scope2.setVariable(loopvar.value[j].value, c.value[j]);\n          }\n        };\n      } else {\n        throw new Error(`Invalid loop variable(s): ${node.loopvar.type}`);\n      }\n      if (test) {\n        scopeUpdateFunction(loopScope);\n        const testValue = this.evaluate(test, loopScope);\n        if (!testValue.__bool__().value) {\n          continue;\n        }\n      }\n      items.push(current);\n      scopeUpdateFunctions.push(scopeUpdateFunction);\n    }\n    let result = \"\";\n    let noIteration = true;\n    for (let i = 0; i < items.length; ++i) {\n      const loop = /* @__PURE__ */new Map([[\"index\", new IntegerValue(i + 1)], [\"index0\", new IntegerValue(i)], [\"revindex\", new IntegerValue(items.length - i)], [\"revindex0\", new IntegerValue(items.length - i - 1)], [\"first\", new BooleanValue(i === 0)], [\"last\", new BooleanValue(i === items.length - 1)], [\"length\", new IntegerValue(items.length)], [\"previtem\", i > 0 ? items[i - 1] : new UndefinedValue()], [\"nextitem\", i < items.length - 1 ? items[i + 1] : new UndefinedValue()]]);\n      scope.setVariable(\"loop\", new ObjectValue(loop));\n      scopeUpdateFunctions[i](scope);\n      try {\n        const evaluated = this.evaluateBlock(node.body, scope);\n        result += evaluated.value;\n      } catch (err) {\n        if (err instanceof ContinueControl) {\n          continue;\n        }\n        if (err instanceof BreakControl) {\n          break;\n        }\n        throw err;\n      }\n      noIteration = false;\n    }\n    if (noIteration) {\n      const defaultEvaluated = this.evaluateBlock(node.defaultBlock, scope);\n      result += defaultEvaluated.value;\n    }\n    return new StringValue(result);\n  }\n  /**\n   * See https://jinja.palletsprojects.com/en/3.1.x/templates/#macros for more information.\n   */\n  evaluateMacro(node, environment) {\n    environment.setVariable(node.name.value, new FunctionValue((args, scope) => {\n      const macroScope = new Environment(scope);\n      args = args.slice();\n      let kwargs;\n      if (args.at(-1)?.type === \"KeywordArgumentsValue\") {\n        kwargs = args.pop();\n      }\n      for (let i = 0; i < node.args.length; ++i) {\n        const nodeArg = node.args[i];\n        const passedArg = args[i];\n        if (nodeArg.type === \"Identifier\") {\n          const identifier = nodeArg;\n          if (!passedArg) {\n            throw new Error(`Missing positional argument: ${identifier.value}`);\n          }\n          macroScope.setVariable(identifier.value, passedArg);\n        } else if (nodeArg.type === \"KeywordArgumentExpression\") {\n          const kwarg = nodeArg;\n          const value = passedArg ??\n          // Try positional arguments first\n          kwargs?.value.get(kwarg.key.value) ??\n          // Look in user-passed kwargs\n          this.evaluate(kwarg.value, macroScope);\n          macroScope.setVariable(kwarg.key.value, value);\n        } else {\n          throw new Error(`Unknown argument type: ${nodeArg.type}`);\n        }\n      }\n      return this.evaluateBlock(node.body, macroScope);\n    }));\n    return new NullValue();\n  }\n  evaluateCallStatement(node, environment) {\n    const callerFn = new FunctionValue((callerArgs, callerEnv) => {\n      const callBlockEnv = new Environment(callerEnv);\n      if (node.callerArgs) {\n        for (let i = 0; i < node.callerArgs.length; ++i) {\n          const param = node.callerArgs[i];\n          if (param.type !== \"Identifier\") {\n            throw new Error(`Caller parameter must be an identifier, got ${param.type}`);\n          }\n          callBlockEnv.setVariable(param.value, callerArgs[i] ?? new UndefinedValue());\n        }\n      }\n      return this.evaluateBlock(node.body, callBlockEnv);\n    });\n    const [macroArgs, macroKwargs] = this.evaluateArguments(node.call.args, environment);\n    macroArgs.push(new KeywordArgumentsValue(macroKwargs));\n    const fn = this.evaluate(node.call.callee, environment);\n    if (fn.type !== \"FunctionValue\") {\n      throw new Error(`Cannot call something that is not a function: got ${fn.type}`);\n    }\n    const newEnv = new Environment(environment);\n    newEnv.setVariable(\"caller\", callerFn);\n    return fn.value(macroArgs, newEnv);\n  }\n  evaluateFilterStatement(node, environment) {\n    const rendered = this.evaluateBlock(node.body, environment);\n    return this.applyFilter(rendered, node.filter, environment);\n  }\n  evaluate(statement, environment) {\n    if (!statement) return new UndefinedValue();\n    switch (statement.type) {\n      case \"Program\":\n        return this.evalProgram(statement, environment);\n      case \"Set\":\n        return this.evaluateSet(statement, environment);\n      case \"If\":\n        return this.evaluateIf(statement, environment);\n      case \"For\":\n        return this.evaluateFor(statement, environment);\n      case \"Macro\":\n        return this.evaluateMacro(statement, environment);\n      case \"CallStatement\":\n        return this.evaluateCallStatement(statement, environment);\n      case \"Break\":\n        throw new BreakControl();\n      case \"Continue\":\n        throw new ContinueControl();\n      case \"IntegerLiteral\":\n        return new IntegerValue(statement.value);\n      case \"FloatLiteral\":\n        return new FloatValue(statement.value);\n      case \"StringLiteral\":\n        return new StringValue(statement.value);\n      case \"ArrayLiteral\":\n        return new ArrayValue(statement.value.map(x => this.evaluate(x, environment)));\n      case \"TupleLiteral\":\n        return new TupleValue(statement.value.map(x => this.evaluate(x, environment)));\n      case \"ObjectLiteral\":\n        {\n          const mapping = /* @__PURE__ */new Map();\n          for (const [key, value] of statement.value) {\n            const evaluatedKey = this.evaluate(key, environment);\n            if (!(evaluatedKey instanceof StringValue)) {\n              throw new Error(`Object keys must be strings: got ${evaluatedKey.type}`);\n            }\n            mapping.set(evaluatedKey.value, this.evaluate(value, environment));\n          }\n          return new ObjectValue(mapping);\n        }\n      case \"Identifier\":\n        return this.evaluateIdentifier(statement, environment);\n      case \"CallExpression\":\n        return this.evaluateCallExpression(statement, environment);\n      case \"MemberExpression\":\n        return this.evaluateMemberExpression(statement, environment);\n      case \"UnaryExpression\":\n        return this.evaluateUnaryExpression(statement, environment);\n      case \"BinaryExpression\":\n        return this.evaluateBinaryExpression(statement, environment);\n      case \"FilterExpression\":\n        return this.evaluateFilterExpression(statement, environment);\n      case \"FilterStatement\":\n        return this.evaluateFilterStatement(statement, environment);\n      case \"TestExpression\":\n        return this.evaluateTestExpression(statement, environment);\n      case \"SelectExpression\":\n        return this.evaluateSelectExpression(statement, environment);\n      case \"Ternary\":\n        return this.evaluateTernaryExpression(statement, environment);\n      case \"Comment\":\n        return new NullValue();\n      default:\n        throw new SyntaxError(`Unknown node type: ${statement.type}`);\n    }\n  }\n};\nfunction convertToRuntimeValues(input) {\n  switch (typeof input) {\n    case \"number\":\n      return Number.isInteger(input) ? new IntegerValue(input) : new FloatValue(input);\n    case \"string\":\n      return new StringValue(input);\n    case \"boolean\":\n      return new BooleanValue(input);\n    case \"undefined\":\n      return new UndefinedValue();\n    case \"object\":\n      if (input === null) {\n        return new NullValue();\n      } else if (Array.isArray(input)) {\n        return new ArrayValue(input.map(convertToRuntimeValues));\n      } else {\n        return new ObjectValue(new Map(Object.entries(input).map(([key, value]) => [key, convertToRuntimeValues(value)])));\n      }\n    case \"function\":\n      return new FunctionValue((args, _scope) => {\n        const result = input(...args.map(x => x.value)) ?? null;\n        return convertToRuntimeValues(result);\n      });\n    default:\n      throw new Error(`Cannot convert to runtime value: ${input}`);\n  }\n}\nfunction toJSON(input, indent, depth) {\n  const currentDepth = depth ?? 0;\n  switch (input.type) {\n    case \"NullValue\":\n    case \"UndefinedValue\":\n      return \"null\";\n    case \"IntegerValue\":\n    case \"FloatValue\":\n    case \"StringValue\":\n    case \"BooleanValue\":\n      return JSON.stringify(input.value);\n    case \"ArrayValue\":\n    case \"ObjectValue\":\n      {\n        const indentValue = indent ? \" \".repeat(indent) : \"\";\n        const basePadding = \"\\n\" + indentValue.repeat(currentDepth);\n        const childrenPadding = basePadding + indentValue;\n        if (input.type === \"ArrayValue\") {\n          const core = input.value.map(x => toJSON(x, indent, currentDepth + 1));\n          return indent ? `[${childrenPadding}${core.join(`,${childrenPadding}`)}${basePadding}]` : `[${core.join(\", \")}]`;\n        } else {\n          const core = Array.from(input.value.entries()).map(([key, value]) => {\n            const v = `\"${key}\": ${toJSON(value, indent, currentDepth + 1)}`;\n            return indent ? `${childrenPadding}${v}` : v;\n          });\n          return indent ? `{${core.join(\",\")}${basePadding}}` : `{${core.join(\", \")}}`;\n        }\n      }\n    default:\n      throw new Error(`Cannot convert to JSON: ${input.type}`);\n  }\n}\n\n// src/format.ts\nvar NEWLINE = \"\\n\";\nvar OPEN_STATEMENT = \"{%- \";\nvar CLOSE_STATEMENT = \" -%}\";\nfunction getBinaryOperatorPrecedence(expr) {\n  switch (expr.operator.type) {\n    case \"MultiplicativeBinaryOperator\":\n      return 4;\n    case \"AdditiveBinaryOperator\":\n      return 3;\n    case \"ComparisonBinaryOperator\":\n      return 2;\n    case \"Identifier\":\n      if (expr.operator.value === \"and\") return 1;\n      if (expr.operator.value === \"in\" || expr.operator.value === \"not in\") return 2;\n      return 0;\n  }\n  return 0;\n}\nfunction format(program, indent = \"\t\") {\n  const indentStr = typeof indent === \"number\" ? \" \".repeat(indent) : indent;\n  const body = formatStatements(program.body, 0, indentStr);\n  return body.replace(/\\n$/, \"\");\n}\nfunction createStatement(...text) {\n  return OPEN_STATEMENT + text.join(\" \") + CLOSE_STATEMENT;\n}\nfunction formatStatements(stmts, depth, indentStr) {\n  return stmts.map(stmt => formatStatement(stmt, depth, indentStr)).join(NEWLINE);\n}\nfunction formatStatement(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  switch (node.type) {\n    case \"Program\":\n      return formatStatements(node.body, depth, indentStr);\n    case \"If\":\n      return formatIf(node, depth, indentStr);\n    case \"For\":\n      return formatFor(node, depth, indentStr);\n    case \"Set\":\n      return formatSet(node, depth, indentStr);\n    case \"Macro\":\n      return formatMacro(node, depth, indentStr);\n    case \"Break\":\n      return pad + createStatement(\"break\");\n    case \"Continue\":\n      return pad + createStatement(\"continue\");\n    case \"CallStatement\":\n      return formatCallStatement(node, depth, indentStr);\n    case \"FilterStatement\":\n      return formatFilterStatement(node, depth, indentStr);\n    case \"Comment\":\n      return pad + \"{# \" + node.value + \" #}\";\n    default:\n      return pad + \"{{- \" + formatExpression(node) + \" -}}\";\n  }\n}\nfunction formatIf(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  const clauses = [];\n  let current = node;\n  while (current) {\n    clauses.push({\n      test: current.test,\n      body: current.body\n    });\n    if (current.alternate.length === 1 && current.alternate[0].type === \"If\") {\n      current = current.alternate[0];\n    } else {\n      break;\n    }\n  }\n  let out = pad + createStatement(\"if\", formatExpression(clauses[0].test)) + NEWLINE + formatStatements(clauses[0].body, depth + 1, indentStr);\n  for (let i = 1; i < clauses.length; ++i) {\n    out += NEWLINE + pad + createStatement(\"elif\", formatExpression(clauses[i].test)) + NEWLINE + formatStatements(clauses[i].body, depth + 1, indentStr);\n  }\n  if (current && current.alternate.length > 0) {\n    out += NEWLINE + pad + createStatement(\"else\") + NEWLINE + formatStatements(current.alternate, depth + 1, indentStr);\n  }\n  out += NEWLINE + pad + createStatement(\"endif\");\n  return out;\n}\nfunction formatFor(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  let formattedIterable = \"\";\n  if (node.iterable.type === \"SelectExpression\") {\n    const n = node.iterable;\n    formattedIterable = `${formatExpression(n.lhs)} if ${formatExpression(n.test)}`;\n  } else {\n    formattedIterable = formatExpression(node.iterable);\n  }\n  let out = pad + createStatement(\"for\", formatExpression(node.loopvar), \"in\", formattedIterable) + NEWLINE + formatStatements(node.body, depth + 1, indentStr);\n  if (node.defaultBlock.length > 0) {\n    out += NEWLINE + pad + createStatement(\"else\") + NEWLINE + formatStatements(node.defaultBlock, depth + 1, indentStr);\n  }\n  out += NEWLINE + pad + createStatement(\"endfor\");\n  return out;\n}\nfunction formatSet(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  const left = formatExpression(node.assignee);\n  const right = node.value ? formatExpression(node.value) : \"\";\n  const value = pad + createStatement(\"set\", `${left}${node.value ? \" = \" + right : \"\"}`);\n  if (node.body.length === 0) {\n    return value;\n  }\n  return value + NEWLINE + formatStatements(node.body, depth + 1, indentStr) + NEWLINE + pad + createStatement(\"endset\");\n}\nfunction formatMacro(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  const args = node.args.map(formatExpression).join(\", \");\n  return pad + createStatement(\"macro\", `${node.name.value}(${args})`) + NEWLINE + formatStatements(node.body, depth + 1, indentStr) + NEWLINE + pad + createStatement(\"endmacro\");\n}\nfunction formatCallStatement(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  const params = node.callerArgs && node.callerArgs.length > 0 ? `(${node.callerArgs.map(formatExpression).join(\", \")})` : \"\";\n  const callExpr = formatExpression(node.call);\n  let out = pad + createStatement(`call${params}`, callExpr) + NEWLINE;\n  out += formatStatements(node.body, depth + 1, indentStr) + NEWLINE;\n  out += pad + createStatement(\"endcall\");\n  return out;\n}\nfunction formatFilterStatement(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  const spec = node.filter.type === \"Identifier\" ? node.filter.value : formatExpression(node.filter);\n  let out = pad + createStatement(\"filter\", spec) + NEWLINE;\n  out += formatStatements(node.body, depth + 1, indentStr) + NEWLINE;\n  out += pad + createStatement(\"endfilter\");\n  return out;\n}\nfunction formatExpression(node, parentPrec = -1) {\n  switch (node.type) {\n    case \"SpreadExpression\":\n      {\n        const n = node;\n        return `*${formatExpression(n.argument)}`;\n      }\n    case \"Identifier\":\n      return node.value;\n    case \"IntegerLiteral\":\n      return `${node.value}`;\n    case \"FloatLiteral\":\n      return `${node.value}`;\n    case \"StringLiteral\":\n      return JSON.stringify(node.value);\n    case \"BinaryExpression\":\n      {\n        const n = node;\n        const thisPrecedence = getBinaryOperatorPrecedence(n);\n        const left = formatExpression(n.left, thisPrecedence);\n        const right = formatExpression(n.right, thisPrecedence + 1);\n        const expr = `${left} ${n.operator.value} ${right}`;\n        return thisPrecedence < parentPrec ? `(${expr})` : expr;\n      }\n    case \"UnaryExpression\":\n      {\n        const n = node;\n        const val = n.operator.value + (n.operator.value === \"not\" ? \" \" : \"\") + formatExpression(n.argument, Infinity);\n        return val;\n      }\n    case \"CallExpression\":\n      {\n        const n = node;\n        const args = n.args.map(formatExpression).join(\", \");\n        return `${formatExpression(n.callee)}(${args})`;\n      }\n    case \"MemberExpression\":\n      {\n        const n = node;\n        let obj = formatExpression(n.object);\n        if (![\"Identifier\", \"MemberExpression\", \"CallExpression\", \"StringLiteral\", \"IntegerLiteral\", \"FloatLiteral\", \"ArrayLiteral\", \"TupleLiteral\", \"ObjectLiteral\"].includes(n.object.type)) {\n          obj = `(${obj})`;\n        }\n        let prop = formatExpression(n.property);\n        if (!n.computed && n.property.type !== \"Identifier\") {\n          prop = `(${prop})`;\n        }\n        return n.computed ? `${obj}[${prop}]` : `${obj}.${prop}`;\n      }\n    case \"FilterExpression\":\n      {\n        const n = node;\n        const operand = formatExpression(n.operand, Infinity);\n        if (n.filter.type === \"CallExpression\") {\n          return `${operand} | ${formatExpression(n.filter)}`;\n        }\n        return `${operand} | ${n.filter.value}`;\n      }\n    case \"SelectExpression\":\n      {\n        const n = node;\n        return `${formatExpression(n.lhs)} if ${formatExpression(n.test)}`;\n      }\n    case \"TestExpression\":\n      {\n        const n = node;\n        return `${formatExpression(n.operand)} is${n.negate ? \" not\" : \"\"} ${n.test.value}`;\n      }\n    case \"ArrayLiteral\":\n    case \"TupleLiteral\":\n      {\n        const elems = node.value.map(formatExpression);\n        const brackets = node.type === \"ArrayLiteral\" ? \"[]\" : \"()\";\n        return `${brackets[0]}${elems.join(\", \")}${brackets[1]}`;\n      }\n    case \"ObjectLiteral\":\n      {\n        const entries = Array.from(node.value.entries()).map(([k, v]) => `${formatExpression(k)}: ${formatExpression(v)}`);\n        return `{${entries.join(\", \")}}`;\n      }\n    case \"SliceExpression\":\n      {\n        const n = node;\n        const s = n.start ? formatExpression(n.start) : \"\";\n        const t = n.stop ? formatExpression(n.stop) : \"\";\n        const st = n.step ? `:${formatExpression(n.step)}` : \"\";\n        return `${s}:${t}${st}`;\n      }\n    case \"KeywordArgumentExpression\":\n      {\n        const n = node;\n        return `${n.key.value}=${formatExpression(n.value)}`;\n      }\n    case \"Ternary\":\n      {\n        const n = node;\n        const expr = `${formatExpression(n.trueExpr)} if ${formatExpression(n.condition, 0)} else ${formatExpression(n.falseExpr)}`;\n        return parentPrec > -1 ? `(${expr})` : expr;\n      }\n    default:\n      throw new Error(`Unknown expression type: ${node.type}`);\n  }\n}\n\n// src/index.ts\nvar Template = class {\n  parsed;\n  /**\n   * @param {string} template The template string\n   */\n  constructor(template) {\n    const tokens = tokenize(template, {\n      lstrip_blocks: true,\n      trim_blocks: true\n    });\n    this.parsed = parse(tokens);\n  }\n  render(items) {\n    const env = new Environment();\n    setupGlobals(env);\n    if (items) {\n      for (const [key, value] of Object.entries(items)) {\n        env.set(key, value);\n      }\n    }\n    const interpreter = new Interpreter(env);\n    const result = interpreter.run(this.parsed);\n    return result.value;\n  }\n  format(options) {\n    return format(this.parsed, options?.indent || \"\t\");\n  }\n};\nexport { Environment, Interpreter, Template, parse, tokenize };","map":{"version":3,"names":["TOKEN_TYPES","Object","freeze","Text","NumericLiteral","StringLiteral","Identifier","Equals","OpenParen","CloseParen","OpenStatement","CloseStatement","OpenExpression","CloseExpression","OpenSquareBracket","CloseSquareBracket","OpenCurlyBracket","CloseCurlyBracket","Comma","Dot","Colon","Pipe","CallOperator","AdditiveBinaryOperator","MultiplicativeBinaryOperator","ComparisonBinaryOperator","UnaryOperator","Comment","Token","constructor","value","type","isWord","char","test","isInteger","ORDERED_MAPPING_TABLE","ESCAPE_CHARACTERS","Map","preprocess","template","options","endsWith","slice","lstrip_blocks","replace","trim_blocks","tokenize","source","tokens","src","cursorPosition","curlyBracketDepth","consumeWhile","predicate","str","length","SyntaxError","escaped","unescaped","get","main","lastTokenType","at","text","push","comment","char2","lastTokenType2","num","seq","slice2","c","frac","word","Statement","Program","body","If","alternate","For","loopvar","iterable","defaultBlock","Break","Continue","SetStatement","assignee","Macro","name","args","Expression","MemberExpression","object","property","computed","CallExpression","callee","Literal","IntegerLiteral","FloatLiteral","ArrayLiteral","TupleLiteral","ObjectLiteral","BinaryExpression","operator","left","right","FilterExpression","operand","filter","FilterStatement","SelectExpression","lhs","TestExpression","negate","UnaryExpression","argument","SliceExpression","start","stop","step","KeywordArgumentExpression","key","SpreadExpression","CallStatement","call","callerArgs","Ternary","condition","trueExpr","falseExpr","parse","program","current","expect","error","prev","Error","expectIdentifier","isIdentifier","parseAny","parseText","parseJinjaStatement","parseJinjaExpression","is","types","every","i","isStatement","names","includes","result","parseSetStatement","parseIfStatement","parseMacroStatement","parseForStatement","parseArgs","parsePrimaryExpression","callArgs","callExpr","filterNode","parseCallExpression","filterBody","parseExpression","parseExpressionSequence","primary","fn","expressions","isTuple","loopVariable","alternative","parseIfExpression","a","parseLogicalOrExpression","parseLogicalAndExpression","parseLogicalNegationExpression","arg","parseComparisonExpression","parseAdditiveExpression","parseMultiplicativeExpression","parseCallMemberExpression","member","parseMemberExpression","expression","parseArgumentsList","expr","parseMemberExpressionArgumentsList","slices","isSlice","parseTestExpression","parseFilterExpression","token","Number","values","set","range","array","direction","Math","sign","max","min","titleCase","toUpperCase","strftime_now","format2","strftime","Date","date","monthFormatterLong","Intl","DateTimeFormat","month","monthFormatterShort","pad2","n","toString","getFullYear","getMonth","getDate","format","getHours","getMinutes","escapeRegExp","s","oldvalue","newvalue","count","remaining","Infinity","pattern","RegExp","replaceAll","match","BreakControl","ContinueControl","RuntimeValue","builtins","__bool__","BooleanValue","String","IntegerValue","FloatValue","toFixed","StringValue","FunctionValue","toLowerCase","trim","charAt","trimEnd","trimStart","startsWith","ArrayValue","item","sep","NullValue","maxsplit","index","matchAll","split","splice","join","map","part","oldValue","newValue","ObjectValue","size","defaultValue","items","keys","Array","from","entries","KeywordArgumentsValue","TupleValue","UndefinedValue","Environment","parent","variables","tests","b","declareVariable","convertToRuntimeValues","has","setVariable","resolve","lookupVariable","setupGlobals","env","Interpreter","global","run","evaluate","evaluateBinaryExpression","node","environment","res","isFloat","rem","concat","find","x","evaluateArguments","positionalArguments","keywordArguments","spreadNode","val","kwarg","applyFilter","toJSON","reverse","sort","localeCompare","seen","Set","output","add","builtin","parseInt","isNaN","parseFloat","abs","floor","filterName","kwargs","indent","separator","booleanValue","select","some","attr","testName","testFunction","filtered","mapped","width","first","blank","lines","repeat","indented","replaceFn","evaluateFilterExpression","evaluateTestExpression","evaluateSelectExpression","evaluateUnaryExpression","evaluateTernaryExpression","cond","evalProgram","evaluateBlock","statements","statement","lastEvaluated","evaluateIdentifier","evaluateCallExpression","evaluateSliceExpression","evaluateMemberExpression","evaluateSet","rhs","variableName","tuple","arr","elem","JSON","stringify","evaluateIf","evaluateFor","scope","scopeUpdateFunctions","loopScope","scopeUpdateFunction","scope2","j","testValue","noIteration","loop","evaluated","err","defaultEvaluated","evaluateMacro","macroScope","pop","nodeArg","passedArg","identifier","evaluateCallStatement","callerFn","callerEnv","callBlockEnv","param","macroArgs","macroKwargs","newEnv","evaluateFilterStatement","rendered","mapping","evaluatedKey","input","isArray","_scope","depth","currentDepth","indentValue","basePadding","childrenPadding","core","v","NEWLINE","OPEN_STATEMENT","CLOSE_STATEMENT","getBinaryOperatorPrecedence","indentStr","formatStatements","createStatement","stmts","stmt","formatStatement","pad","formatIf","formatFor","formatSet","formatMacro","formatCallStatement","formatFilterStatement","formatExpression","clauses","out","formattedIterable","params","spec","parentPrec","thisPrecedence","obj","prop","elems","brackets","k","t","st","Template","parsed","render","interpreter"],"sources":["/Users/agmacbook/Documents/Courses/Meta - Full Stack/Exercises/meta_fullstack_exercises/6_react_basics/12_review/13_chef_claude/node_modules/@huggingface/jinja/dist/index.js"],"sourcesContent":["// src/lexer.ts\nvar TOKEN_TYPES = Object.freeze({\n  Text: \"Text\",\n  // The text between Jinja statements or expressions\n  NumericLiteral: \"NumericLiteral\",\n  // e.g., 123, 1.0\n  StringLiteral: \"StringLiteral\",\n  // 'string'\n  Identifier: \"Identifier\",\n  // Variables, functions, statements, booleans, etc.\n  Equals: \"Equals\",\n  // =\n  OpenParen: \"OpenParen\",\n  // (\n  CloseParen: \"CloseParen\",\n  // )\n  OpenStatement: \"OpenStatement\",\n  // {%\n  CloseStatement: \"CloseStatement\",\n  // %}\n  OpenExpression: \"OpenExpression\",\n  // {{\n  CloseExpression: \"CloseExpression\",\n  // }}\n  OpenSquareBracket: \"OpenSquareBracket\",\n  // [\n  CloseSquareBracket: \"CloseSquareBracket\",\n  // ]\n  OpenCurlyBracket: \"OpenCurlyBracket\",\n  // {\n  CloseCurlyBracket: \"CloseCurlyBracket\",\n  // }\n  Comma: \"Comma\",\n  // ,\n  Dot: \"Dot\",\n  // .\n  Colon: \"Colon\",\n  // :\n  Pipe: \"Pipe\",\n  // |\n  CallOperator: \"CallOperator\",\n  // ()\n  AdditiveBinaryOperator: \"AdditiveBinaryOperator\",\n  // + - ~\n  MultiplicativeBinaryOperator: \"MultiplicativeBinaryOperator\",\n  // * / %\n  ComparisonBinaryOperator: \"ComparisonBinaryOperator\",\n  // < > <= >= == !=\n  UnaryOperator: \"UnaryOperator\",\n  // ! - +\n  Comment: \"Comment\"\n  // {# ... #}\n});\nvar Token = class {\n  /**\n   * Constructs a new Token.\n   * @param {string} value The raw value as seen inside the source code.\n   * @param {TokenType} type The type of token.\n   */\n  constructor(value, type) {\n    this.value = value;\n    this.type = type;\n  }\n};\nfunction isWord(char) {\n  return /\\w/.test(char);\n}\nfunction isInteger(char) {\n  return /[0-9]/.test(char);\n}\nvar ORDERED_MAPPING_TABLE = [\n  // Control sequences\n  [\"{%\", TOKEN_TYPES.OpenStatement],\n  [\"%}\", TOKEN_TYPES.CloseStatement],\n  [\"{{\", TOKEN_TYPES.OpenExpression],\n  [\"}}\", TOKEN_TYPES.CloseExpression],\n  // Single character tokens\n  [\"(\", TOKEN_TYPES.OpenParen],\n  [\")\", TOKEN_TYPES.CloseParen],\n  [\"{\", TOKEN_TYPES.OpenCurlyBracket],\n  [\"}\", TOKEN_TYPES.CloseCurlyBracket],\n  [\"[\", TOKEN_TYPES.OpenSquareBracket],\n  [\"]\", TOKEN_TYPES.CloseSquareBracket],\n  [\",\", TOKEN_TYPES.Comma],\n  [\".\", TOKEN_TYPES.Dot],\n  [\":\", TOKEN_TYPES.Colon],\n  [\"|\", TOKEN_TYPES.Pipe],\n  // Comparison operators\n  [\"<=\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\">=\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\"==\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\"!=\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\"<\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\">\", TOKEN_TYPES.ComparisonBinaryOperator],\n  // Arithmetic operators\n  [\"+\", TOKEN_TYPES.AdditiveBinaryOperator],\n  [\"-\", TOKEN_TYPES.AdditiveBinaryOperator],\n  [\"~\", TOKEN_TYPES.AdditiveBinaryOperator],\n  [\"*\", TOKEN_TYPES.MultiplicativeBinaryOperator],\n  [\"/\", TOKEN_TYPES.MultiplicativeBinaryOperator],\n  [\"%\", TOKEN_TYPES.MultiplicativeBinaryOperator],\n  // Assignment operator\n  [\"=\", TOKEN_TYPES.Equals]\n];\nvar ESCAPE_CHARACTERS = /* @__PURE__ */ new Map([\n  [\"n\", \"\\n\"],\n  // New line\n  [\"t\", \"\t\"],\n  // Horizontal tab\n  [\"r\", \"\\r\"],\n  // Carriage return\n  [\"b\", \"\\b\"],\n  // Backspace\n  [\"f\", \"\\f\"],\n  // Form feed\n  [\"v\", \"\\v\"],\n  // Vertical tab\n  [\"'\", \"'\"],\n  // Single quote\n  ['\"', '\"'],\n  // Double quote\n  [\"\\\\\", \"\\\\\"]\n  // Backslash\n]);\nfunction preprocess(template, options = {}) {\n  if (template.endsWith(\"\\n\")) {\n    template = template.slice(0, -1);\n  }\n  if (options.lstrip_blocks) {\n    template = template.replace(/^[ \\t]*({[#%-])/gm, \"$1\");\n  }\n  if (options.trim_blocks) {\n    template = template.replace(/([#%-]})\\n/g, \"$1\");\n  }\n  return template.replace(/-%}\\s*/g, \"%}\").replace(/\\s*{%-/g, \"{%\").replace(/-}}\\s*/g, \"}}\").replace(/\\s*{{-/g, \"{{\").replace(/-#}\\s*/g, \"#}\").replace(/\\s*{#-/g, \"{#\").replace(/{%\\s*(end)?generation\\s*%}/gs, \"\");\n}\nfunction tokenize(source, options = {}) {\n  const tokens = [];\n  const src = preprocess(source, options);\n  let cursorPosition = 0;\n  let curlyBracketDepth = 0;\n  const consumeWhile = (predicate) => {\n    let str = \"\";\n    while (predicate(src[cursorPosition])) {\n      if (src[cursorPosition] === \"\\\\\") {\n        ++cursorPosition;\n        if (cursorPosition >= src.length)\n          throw new SyntaxError(\"Unexpected end of input\");\n        const escaped = src[cursorPosition++];\n        const unescaped = ESCAPE_CHARACTERS.get(escaped);\n        if (unescaped === void 0) {\n          throw new SyntaxError(`Unexpected escaped character: ${escaped}`);\n        }\n        str += unescaped;\n        continue;\n      }\n      str += src[cursorPosition++];\n      if (cursorPosition >= src.length)\n        throw new SyntaxError(\"Unexpected end of input\");\n    }\n    return str;\n  };\n  main:\n    while (cursorPosition < src.length) {\n      const lastTokenType = tokens.at(-1)?.type;\n      if (lastTokenType === void 0 || lastTokenType === TOKEN_TYPES.CloseStatement || lastTokenType === TOKEN_TYPES.CloseExpression || lastTokenType === TOKEN_TYPES.Comment) {\n        let text = \"\";\n        while (cursorPosition < src.length && // Keep going until we hit the next Jinja statement or expression\n        !(src[cursorPosition] === \"{\" && (src[cursorPosition + 1] === \"%\" || src[cursorPosition + 1] === \"{\" || src[cursorPosition + 1] === \"#\"))) {\n          text += src[cursorPosition++];\n        }\n        if (text.length > 0) {\n          tokens.push(new Token(text, TOKEN_TYPES.Text));\n          continue;\n        }\n      }\n      if (src[cursorPosition] === \"{\" && src[cursorPosition + 1] === \"#\") {\n        cursorPosition += 2;\n        let comment = \"\";\n        while (src[cursorPosition] !== \"#\" || src[cursorPosition + 1] !== \"}\") {\n          if (cursorPosition + 2 >= src.length) {\n            throw new SyntaxError(\"Missing end of comment tag\");\n          }\n          comment += src[cursorPosition++];\n        }\n        tokens.push(new Token(comment, TOKEN_TYPES.Comment));\n        cursorPosition += 2;\n        continue;\n      }\n      consumeWhile((char2) => /\\s/.test(char2));\n      const char = src[cursorPosition];\n      if (char === \"-\" || char === \"+\") {\n        const lastTokenType2 = tokens.at(-1)?.type;\n        if (lastTokenType2 === TOKEN_TYPES.Text || lastTokenType2 === void 0) {\n          throw new SyntaxError(`Unexpected character: ${char}`);\n        }\n        switch (lastTokenType2) {\n          case TOKEN_TYPES.Identifier:\n          case TOKEN_TYPES.NumericLiteral:\n          case TOKEN_TYPES.StringLiteral:\n          case TOKEN_TYPES.CloseParen:\n          case TOKEN_TYPES.CloseSquareBracket:\n            break;\n          default: {\n            ++cursorPosition;\n            const num = consumeWhile(isInteger);\n            tokens.push(\n              new Token(`${char}${num}`, num.length > 0 ? TOKEN_TYPES.NumericLiteral : TOKEN_TYPES.UnaryOperator)\n            );\n            continue;\n          }\n        }\n      }\n      for (const [seq, type] of ORDERED_MAPPING_TABLE) {\n        if (seq === \"}}\" && curlyBracketDepth > 0) {\n          continue;\n        }\n        const slice2 = src.slice(cursorPosition, cursorPosition + seq.length);\n        if (slice2 === seq) {\n          tokens.push(new Token(seq, type));\n          if (type === TOKEN_TYPES.OpenExpression) {\n            curlyBracketDepth = 0;\n          } else if (type === TOKEN_TYPES.OpenCurlyBracket) {\n            ++curlyBracketDepth;\n          } else if (type === TOKEN_TYPES.CloseCurlyBracket) {\n            --curlyBracketDepth;\n          }\n          cursorPosition += seq.length;\n          continue main;\n        }\n      }\n      if (char === \"'\" || char === '\"') {\n        ++cursorPosition;\n        const str = consumeWhile((c) => c !== char);\n        tokens.push(new Token(str, TOKEN_TYPES.StringLiteral));\n        ++cursorPosition;\n        continue;\n      }\n      if (isInteger(char)) {\n        let num = consumeWhile(isInteger);\n        if (src[cursorPosition] === \".\" && isInteger(src[cursorPosition + 1])) {\n          ++cursorPosition;\n          const frac = consumeWhile(isInteger);\n          num = `${num}.${frac}`;\n        }\n        tokens.push(new Token(num, TOKEN_TYPES.NumericLiteral));\n        continue;\n      }\n      if (isWord(char)) {\n        const word = consumeWhile(isWord);\n        tokens.push(new Token(word, TOKEN_TYPES.Identifier));\n        continue;\n      }\n      throw new SyntaxError(`Unexpected character: ${char}`);\n    }\n  return tokens;\n}\n\n// src/ast.ts\nvar Statement = class {\n  type = \"Statement\";\n};\nvar Program = class extends Statement {\n  constructor(body) {\n    super();\n    this.body = body;\n  }\n  type = \"Program\";\n};\nvar If = class extends Statement {\n  constructor(test, body, alternate) {\n    super();\n    this.test = test;\n    this.body = body;\n    this.alternate = alternate;\n  }\n  type = \"If\";\n};\nvar For = class extends Statement {\n  constructor(loopvar, iterable, body, defaultBlock) {\n    super();\n    this.loopvar = loopvar;\n    this.iterable = iterable;\n    this.body = body;\n    this.defaultBlock = defaultBlock;\n  }\n  type = \"For\";\n};\nvar Break = class extends Statement {\n  type = \"Break\";\n};\nvar Continue = class extends Statement {\n  type = \"Continue\";\n};\nvar SetStatement = class extends Statement {\n  constructor(assignee, value, body) {\n    super();\n    this.assignee = assignee;\n    this.value = value;\n    this.body = body;\n  }\n  type = \"Set\";\n};\nvar Macro = class extends Statement {\n  constructor(name, args, body) {\n    super();\n    this.name = name;\n    this.args = args;\n    this.body = body;\n  }\n  type = \"Macro\";\n};\nvar Comment = class extends Statement {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  type = \"Comment\";\n};\nvar Expression = class extends Statement {\n  type = \"Expression\";\n};\nvar MemberExpression = class extends Expression {\n  constructor(object, property, computed) {\n    super();\n    this.object = object;\n    this.property = property;\n    this.computed = computed;\n  }\n  type = \"MemberExpression\";\n};\nvar CallExpression = class extends Expression {\n  constructor(callee, args) {\n    super();\n    this.callee = callee;\n    this.args = args;\n  }\n  type = \"CallExpression\";\n};\nvar Identifier = class extends Expression {\n  /**\n   * @param {string} value The name of the identifier\n   */\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  type = \"Identifier\";\n};\nvar Literal = class extends Expression {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  type = \"Literal\";\n};\nvar IntegerLiteral = class extends Literal {\n  type = \"IntegerLiteral\";\n};\nvar FloatLiteral = class extends Literal {\n  type = \"FloatLiteral\";\n};\nvar StringLiteral = class extends Literal {\n  type = \"StringLiteral\";\n};\nvar ArrayLiteral = class extends Literal {\n  type = \"ArrayLiteral\";\n};\nvar TupleLiteral = class extends Literal {\n  type = \"TupleLiteral\";\n};\nvar ObjectLiteral = class extends Literal {\n  type = \"ObjectLiteral\";\n};\nvar BinaryExpression = class extends Expression {\n  constructor(operator, left, right) {\n    super();\n    this.operator = operator;\n    this.left = left;\n    this.right = right;\n  }\n  type = \"BinaryExpression\";\n};\nvar FilterExpression = class extends Expression {\n  constructor(operand, filter) {\n    super();\n    this.operand = operand;\n    this.filter = filter;\n  }\n  type = \"FilterExpression\";\n};\nvar FilterStatement = class extends Statement {\n  constructor(filter, body) {\n    super();\n    this.filter = filter;\n    this.body = body;\n  }\n  type = \"FilterStatement\";\n};\nvar SelectExpression = class extends Expression {\n  constructor(lhs, test) {\n    super();\n    this.lhs = lhs;\n    this.test = test;\n  }\n  type = \"SelectExpression\";\n};\nvar TestExpression = class extends Expression {\n  constructor(operand, negate, test) {\n    super();\n    this.operand = operand;\n    this.negate = negate;\n    this.test = test;\n  }\n  type = \"TestExpression\";\n};\nvar UnaryExpression = class extends Expression {\n  constructor(operator, argument) {\n    super();\n    this.operator = operator;\n    this.argument = argument;\n  }\n  type = \"UnaryExpression\";\n};\nvar SliceExpression = class extends Expression {\n  constructor(start = void 0, stop = void 0, step = void 0) {\n    super();\n    this.start = start;\n    this.stop = stop;\n    this.step = step;\n  }\n  type = \"SliceExpression\";\n};\nvar KeywordArgumentExpression = class extends Expression {\n  constructor(key, value) {\n    super();\n    this.key = key;\n    this.value = value;\n  }\n  type = \"KeywordArgumentExpression\";\n};\nvar SpreadExpression = class extends Expression {\n  constructor(argument) {\n    super();\n    this.argument = argument;\n  }\n  type = \"SpreadExpression\";\n};\nvar CallStatement = class extends Statement {\n  constructor(call, callerArgs, body) {\n    super();\n    this.call = call;\n    this.callerArgs = callerArgs;\n    this.body = body;\n  }\n  type = \"CallStatement\";\n};\nvar Ternary = class extends Expression {\n  constructor(condition, trueExpr, falseExpr) {\n    super();\n    this.condition = condition;\n    this.trueExpr = trueExpr;\n    this.falseExpr = falseExpr;\n  }\n  type = \"Ternary\";\n};\n\n// src/parser.ts\nfunction parse(tokens) {\n  const program = new Program([]);\n  let current = 0;\n  function expect(type, error) {\n    const prev = tokens[current++];\n    if (!prev || prev.type !== type) {\n      throw new Error(`Parser Error: ${error}. ${prev.type} !== ${type}.`);\n    }\n    return prev;\n  }\n  function expectIdentifier(name) {\n    if (!isIdentifier(name)) {\n      throw new SyntaxError(`Expected ${name}`);\n    }\n    ++current;\n  }\n  function parseAny() {\n    switch (tokens[current].type) {\n      case TOKEN_TYPES.Comment:\n        return new Comment(tokens[current++].value);\n      case TOKEN_TYPES.Text:\n        return parseText();\n      case TOKEN_TYPES.OpenStatement:\n        return parseJinjaStatement();\n      case TOKEN_TYPES.OpenExpression:\n        return parseJinjaExpression();\n      default:\n        throw new SyntaxError(`Unexpected token type: ${tokens[current].type}`);\n    }\n  }\n  function is(...types) {\n    return current + types.length <= tokens.length && types.every((type, i) => type === tokens[current + i].type);\n  }\n  function isStatement(...names) {\n    return tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type === TOKEN_TYPES.Identifier && names.includes(tokens[current + 1]?.value);\n  }\n  function isIdentifier(...names) {\n    return current + names.length <= tokens.length && names.every((name, i) => tokens[current + i].type === \"Identifier\" && name === tokens[current + i].value);\n  }\n  function parseText() {\n    return new StringLiteral(expect(TOKEN_TYPES.Text, \"Expected text token\").value);\n  }\n  function parseJinjaStatement() {\n    expect(TOKEN_TYPES.OpenStatement, \"Expected opening statement token\");\n    if (tokens[current].type !== TOKEN_TYPES.Identifier) {\n      throw new SyntaxError(`Unknown statement, got ${tokens[current].type}`);\n    }\n    const name = tokens[current].value;\n    let result;\n    switch (name) {\n      case \"set\":\n        ++current;\n        result = parseSetStatement();\n        break;\n      case \"if\":\n        ++current;\n        result = parseIfStatement();\n        expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n        expectIdentifier(\"endif\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n        break;\n      case \"macro\":\n        ++current;\n        result = parseMacroStatement();\n        expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n        expectIdentifier(\"endmacro\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n        break;\n      case \"for\":\n        ++current;\n        result = parseForStatement();\n        expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n        expectIdentifier(\"endfor\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n        break;\n      case \"call\": {\n        ++current;\n        let callerArgs = null;\n        if (is(TOKEN_TYPES.OpenParen)) {\n          callerArgs = parseArgs();\n        }\n        const callee = parsePrimaryExpression();\n        if (callee.type !== \"Identifier\") {\n          throw new SyntaxError(`Expected identifier following call statement`);\n        }\n        const callArgs = parseArgs();\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        const body = [];\n        while (!isStatement(\"endcall\")) {\n          body.push(parseAny());\n        }\n        expect(TOKEN_TYPES.OpenStatement, \"Expected '{%'\");\n        expectIdentifier(\"endcall\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        const callExpr = new CallExpression(callee, callArgs);\n        result = new CallStatement(callExpr, callerArgs, body);\n        break;\n      }\n      case \"break\":\n        ++current;\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        result = new Break();\n        break;\n      case \"continue\":\n        ++current;\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        result = new Continue();\n        break;\n      case \"filter\": {\n        ++current;\n        let filterNode = parsePrimaryExpression();\n        if (filterNode instanceof Identifier && is(TOKEN_TYPES.OpenParen)) {\n          filterNode = parseCallExpression(filterNode);\n        }\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        const filterBody = [];\n        while (!isStatement(\"endfilter\")) {\n          filterBody.push(parseAny());\n        }\n        expect(TOKEN_TYPES.OpenStatement, \"Expected '{%'\");\n        expectIdentifier(\"endfilter\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected '%}'\");\n        result = new FilterStatement(filterNode, filterBody);\n        break;\n      }\n      default:\n        throw new SyntaxError(`Unknown statement type: ${name}`);\n    }\n    return result;\n  }\n  function parseJinjaExpression() {\n    expect(TOKEN_TYPES.OpenExpression, \"Expected opening expression token\");\n    const result = parseExpression();\n    expect(TOKEN_TYPES.CloseExpression, \"Expected closing expression token\");\n    return result;\n  }\n  function parseSetStatement() {\n    const left = parseExpressionSequence();\n    let value = null;\n    const body = [];\n    if (is(TOKEN_TYPES.Equals)) {\n      ++current;\n      value = parseExpressionSequence();\n    } else {\n      expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n      while (!isStatement(\"endset\")) {\n        body.push(parseAny());\n      }\n      expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n      expectIdentifier(\"endset\");\n    }\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    return new SetStatement(left, value, body);\n  }\n  function parseIfStatement() {\n    const test = parseExpression();\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    const body = [];\n    const alternate = [];\n    while (!isStatement(\"elif\", \"else\", \"endif\")) {\n      body.push(parseAny());\n    }\n    if (isStatement(\"elif\")) {\n      ++current;\n      ++current;\n      const result = parseIfStatement();\n      alternate.push(result);\n    } else if (isStatement(\"else\")) {\n      ++current;\n      ++current;\n      expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n      while (!isStatement(\"endif\")) {\n        alternate.push(parseAny());\n      }\n    }\n    return new If(test, body, alternate);\n  }\n  function parseMacroStatement() {\n    const name = parsePrimaryExpression();\n    if (name.type !== \"Identifier\") {\n      throw new SyntaxError(`Expected identifier following macro statement`);\n    }\n    const args = parseArgs();\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    const body = [];\n    while (!isStatement(\"endmacro\")) {\n      body.push(parseAny());\n    }\n    return new Macro(name, args, body);\n  }\n  function parseExpressionSequence(primary = false) {\n    const fn = primary ? parsePrimaryExpression : parseExpression;\n    const expressions = [fn()];\n    const isTuple = is(TOKEN_TYPES.Comma);\n    while (isTuple) {\n      ++current;\n      expressions.push(fn());\n      if (!is(TOKEN_TYPES.Comma)) {\n        break;\n      }\n    }\n    return isTuple ? new TupleLiteral(expressions) : expressions[0];\n  }\n  function parseForStatement() {\n    const loopVariable = parseExpressionSequence(true);\n    if (!(loopVariable instanceof Identifier || loopVariable instanceof TupleLiteral)) {\n      throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${loopVariable.type} instead`);\n    }\n    if (!isIdentifier(\"in\")) {\n      throw new SyntaxError(\"Expected `in` keyword following loop variable\");\n    }\n    ++current;\n    const iterable = parseExpression();\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    const body = [];\n    while (!isStatement(\"endfor\", \"else\")) {\n      body.push(parseAny());\n    }\n    const alternative = [];\n    if (isStatement(\"else\")) {\n      ++current;\n      ++current;\n      expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n      while (!isStatement(\"endfor\")) {\n        alternative.push(parseAny());\n      }\n    }\n    return new For(loopVariable, iterable, body, alternative);\n  }\n  function parseExpression() {\n    return parseIfExpression();\n  }\n  function parseIfExpression() {\n    const a = parseLogicalOrExpression();\n    if (isIdentifier(\"if\")) {\n      ++current;\n      const test = parseLogicalOrExpression();\n      if (isIdentifier(\"else\")) {\n        ++current;\n        const falseExpr = parseIfExpression();\n        return new Ternary(test, a, falseExpr);\n      } else {\n        return new SelectExpression(a, test);\n      }\n    }\n    return a;\n  }\n  function parseLogicalOrExpression() {\n    let left = parseLogicalAndExpression();\n    while (isIdentifier(\"or\")) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseLogicalAndExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseLogicalAndExpression() {\n    let left = parseLogicalNegationExpression();\n    while (isIdentifier(\"and\")) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseLogicalNegationExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseLogicalNegationExpression() {\n    let right;\n    while (isIdentifier(\"not\")) {\n      const operator = tokens[current];\n      ++current;\n      const arg = parseLogicalNegationExpression();\n      right = new UnaryExpression(operator, arg);\n    }\n    return right ?? parseComparisonExpression();\n  }\n  function parseComparisonExpression() {\n    let left = parseAdditiveExpression();\n    while (true) {\n      let operator;\n      if (isIdentifier(\"not\", \"in\")) {\n        operator = new Token(\"not in\", TOKEN_TYPES.Identifier);\n        current += 2;\n      } else if (isIdentifier(\"in\")) {\n        operator = tokens[current++];\n      } else if (is(TOKEN_TYPES.ComparisonBinaryOperator)) {\n        operator = tokens[current++];\n      } else {\n        break;\n      }\n      const right = parseAdditiveExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseAdditiveExpression() {\n    let left = parseMultiplicativeExpression();\n    while (is(TOKEN_TYPES.AdditiveBinaryOperator)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseMultiplicativeExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseCallMemberExpression() {\n    const member = parseMemberExpression(parsePrimaryExpression());\n    if (is(TOKEN_TYPES.OpenParen)) {\n      return parseCallExpression(member);\n    }\n    return member;\n  }\n  function parseCallExpression(callee) {\n    let expression = new CallExpression(callee, parseArgs());\n    expression = parseMemberExpression(expression);\n    if (is(TOKEN_TYPES.OpenParen)) {\n      expression = parseCallExpression(expression);\n    }\n    return expression;\n  }\n  function parseArgs() {\n    expect(TOKEN_TYPES.OpenParen, \"Expected opening parenthesis for arguments list\");\n    const args = parseArgumentsList();\n    expect(TOKEN_TYPES.CloseParen, \"Expected closing parenthesis for arguments list\");\n    return args;\n  }\n  function parseArgumentsList() {\n    const args = [];\n    while (!is(TOKEN_TYPES.CloseParen)) {\n      let argument;\n      if (tokens[current].type === TOKEN_TYPES.MultiplicativeBinaryOperator && tokens[current].value === \"*\") {\n        ++current;\n        const expr = parseExpression();\n        argument = new SpreadExpression(expr);\n      } else {\n        argument = parseExpression();\n        if (is(TOKEN_TYPES.Equals)) {\n          ++current;\n          if (!(argument instanceof Identifier)) {\n            throw new SyntaxError(`Expected identifier for keyword argument`);\n          }\n          const value = parseExpression();\n          argument = new KeywordArgumentExpression(argument, value);\n        }\n      }\n      args.push(argument);\n      if (is(TOKEN_TYPES.Comma)) {\n        ++current;\n      }\n    }\n    return args;\n  }\n  function parseMemberExpressionArgumentsList() {\n    const slices = [];\n    let isSlice = false;\n    while (!is(TOKEN_TYPES.CloseSquareBracket)) {\n      if (is(TOKEN_TYPES.Colon)) {\n        slices.push(void 0);\n        ++current;\n        isSlice = true;\n      } else {\n        slices.push(parseExpression());\n        if (is(TOKEN_TYPES.Colon)) {\n          ++current;\n          isSlice = true;\n        }\n      }\n    }\n    if (slices.length === 0) {\n      throw new SyntaxError(`Expected at least one argument for member/slice expression`);\n    }\n    if (isSlice) {\n      if (slices.length > 3) {\n        throw new SyntaxError(`Expected 0-3 arguments for slice expression`);\n      }\n      return new SliceExpression(...slices);\n    }\n    return slices[0];\n  }\n  function parseMemberExpression(object) {\n    while (is(TOKEN_TYPES.Dot) || is(TOKEN_TYPES.OpenSquareBracket)) {\n      const operator = tokens[current];\n      ++current;\n      let property;\n      const computed = operator.type === TOKEN_TYPES.OpenSquareBracket;\n      if (computed) {\n        property = parseMemberExpressionArgumentsList();\n        expect(TOKEN_TYPES.CloseSquareBracket, \"Expected closing square bracket\");\n      } else {\n        property = parsePrimaryExpression();\n        if (property.type !== \"Identifier\") {\n          throw new SyntaxError(`Expected identifier following dot operator`);\n        }\n      }\n      object = new MemberExpression(object, property, computed);\n    }\n    return object;\n  }\n  function parseMultiplicativeExpression() {\n    let left = parseTestExpression();\n    while (is(TOKEN_TYPES.MultiplicativeBinaryOperator)) {\n      const operator = tokens[current++];\n      const right = parseTestExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseTestExpression() {\n    let operand = parseFilterExpression();\n    while (isIdentifier(\"is\")) {\n      ++current;\n      const negate = isIdentifier(\"not\");\n      if (negate) {\n        ++current;\n      }\n      const filter = parsePrimaryExpression();\n      if (!(filter instanceof Identifier)) {\n        throw new SyntaxError(`Expected identifier for the test`);\n      }\n      operand = new TestExpression(operand, negate, filter);\n    }\n    return operand;\n  }\n  function parseFilterExpression() {\n    let operand = parseCallMemberExpression();\n    while (is(TOKEN_TYPES.Pipe)) {\n      ++current;\n      let filter = parsePrimaryExpression();\n      if (!(filter instanceof Identifier)) {\n        throw new SyntaxError(`Expected identifier for the filter`);\n      }\n      if (is(TOKEN_TYPES.OpenParen)) {\n        filter = parseCallExpression(filter);\n      }\n      operand = new FilterExpression(operand, filter);\n    }\n    return operand;\n  }\n  function parsePrimaryExpression() {\n    const token = tokens[current++];\n    switch (token.type) {\n      case TOKEN_TYPES.NumericLiteral: {\n        const num = token.value;\n        return num.includes(\".\") ? new FloatLiteral(Number(num)) : new IntegerLiteral(Number(num));\n      }\n      case TOKEN_TYPES.StringLiteral: {\n        let value = token.value;\n        while (is(TOKEN_TYPES.StringLiteral)) {\n          value += tokens[current++].value;\n        }\n        return new StringLiteral(value);\n      }\n      case TOKEN_TYPES.Identifier:\n        return new Identifier(token.value);\n      case TOKEN_TYPES.OpenParen: {\n        const expression = parseExpressionSequence();\n        expect(TOKEN_TYPES.CloseParen, \"Expected closing parenthesis, got ${tokens[current].type} instead.\");\n        return expression;\n      }\n      case TOKEN_TYPES.OpenSquareBracket: {\n        const values = [];\n        while (!is(TOKEN_TYPES.CloseSquareBracket)) {\n          values.push(parseExpression());\n          if (is(TOKEN_TYPES.Comma)) {\n            ++current;\n          }\n        }\n        ++current;\n        return new ArrayLiteral(values);\n      }\n      case TOKEN_TYPES.OpenCurlyBracket: {\n        const values = /* @__PURE__ */ new Map();\n        while (!is(TOKEN_TYPES.CloseCurlyBracket)) {\n          const key = parseExpression();\n          expect(TOKEN_TYPES.Colon, \"Expected colon between key and value in object literal\");\n          const value = parseExpression();\n          values.set(key, value);\n          if (is(TOKEN_TYPES.Comma)) {\n            ++current;\n          }\n        }\n        ++current;\n        return new ObjectLiteral(values);\n      }\n      default:\n        throw new SyntaxError(`Unexpected token: ${token.type}`);\n    }\n  }\n  while (current < tokens.length) {\n    program.body.push(parseAny());\n  }\n  return program;\n}\n\n// src/utils.ts\nfunction range(start, stop, step = 1) {\n  if (stop === void 0) {\n    stop = start;\n    start = 0;\n  }\n  const result = [];\n  for (let i = start; i < stop; i += step) {\n    result.push(i);\n  }\n  return result;\n}\nfunction slice(array, start, stop, step = 1) {\n  const direction = Math.sign(step);\n  if (direction >= 0) {\n    start = (start ??= 0) < 0 ? Math.max(array.length + start, 0) : Math.min(start, array.length);\n    stop = (stop ??= array.length) < 0 ? Math.max(array.length + stop, 0) : Math.min(stop, array.length);\n  } else {\n    start = (start ??= array.length - 1) < 0 ? Math.max(array.length + start, -1) : Math.min(start, array.length - 1);\n    stop = (stop ??= -1) < -1 ? Math.max(array.length + stop, -1) : Math.min(stop, array.length - 1);\n  }\n  const result = [];\n  for (let i = start; direction * i < direction * stop; i += step) {\n    result.push(array[i]);\n  }\n  return result;\n}\nfunction titleCase(value) {\n  return value.replace(/\\b\\w/g, (c) => c.toUpperCase());\n}\nfunction strftime_now(format2) {\n  return strftime(/* @__PURE__ */ new Date(), format2);\n}\nfunction strftime(date, format2) {\n  const monthFormatterLong = new Intl.DateTimeFormat(void 0, { month: \"long\" });\n  const monthFormatterShort = new Intl.DateTimeFormat(void 0, { month: \"short\" });\n  const pad2 = (n) => n < 10 ? \"0\" + n : n.toString();\n  return format2.replace(/%[YmdbBHM%]/g, (token) => {\n    switch (token) {\n      case \"%Y\":\n        return date.getFullYear().toString();\n      case \"%m\":\n        return pad2(date.getMonth() + 1);\n      case \"%d\":\n        return pad2(date.getDate());\n      case \"%b\":\n        return monthFormatterShort.format(date);\n      case \"%B\":\n        return monthFormatterLong.format(date);\n      case \"%H\":\n        return pad2(date.getHours());\n      case \"%M\":\n        return pad2(date.getMinutes());\n      case \"%%\":\n        return \"%\";\n      default:\n        return token;\n    }\n  });\n}\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction replace(str, oldvalue, newvalue, count) {\n  if (count === 0)\n    return str;\n  let remaining = count == null || count < 0 ? Infinity : count;\n  const pattern = oldvalue.length === 0 ? new RegExp(\"(?=)\", \"gu\") : new RegExp(escapeRegExp(oldvalue), \"gu\");\n  return str.replaceAll(pattern, (match) => {\n    if (remaining > 0) {\n      --remaining;\n      return newvalue;\n    }\n    return match;\n  });\n}\n\n// src/runtime.ts\nvar BreakControl = class extends Error {\n};\nvar ContinueControl = class extends Error {\n};\nvar RuntimeValue = class {\n  type = \"RuntimeValue\";\n  value;\n  /**\n   * A collection of built-in functions for this type.\n   */\n  builtins = /* @__PURE__ */ new Map();\n  /**\n   * Creates a new RuntimeValue.\n   */\n  constructor(value = void 0) {\n    this.value = value;\n  }\n  /**\n   * Determines truthiness or falsiness of the runtime value.\n   * This function should be overridden by subclasses if it has custom truthiness criteria.\n   * @returns {BooleanValue} BooleanValue(true) if the value is truthy, BooleanValue(false) otherwise.\n   */\n  __bool__() {\n    return new BooleanValue(!!this.value);\n  }\n  toString() {\n    return String(this.value);\n  }\n};\nvar IntegerValue = class extends RuntimeValue {\n  type = \"IntegerValue\";\n};\nvar FloatValue = class extends RuntimeValue {\n  type = \"FloatValue\";\n  toString() {\n    return this.value % 1 === 0 ? this.value.toFixed(1) : this.value.toString();\n  }\n};\nvar StringValue = class extends RuntimeValue {\n  type = \"StringValue\";\n  builtins = /* @__PURE__ */ new Map([\n    [\n      \"upper\",\n      new FunctionValue(() => {\n        return new StringValue(this.value.toUpperCase());\n      })\n    ],\n    [\n      \"lower\",\n      new FunctionValue(() => {\n        return new StringValue(this.value.toLowerCase());\n      })\n    ],\n    [\n      \"strip\",\n      new FunctionValue(() => {\n        return new StringValue(this.value.trim());\n      })\n    ],\n    [\n      \"title\",\n      new FunctionValue(() => {\n        return new StringValue(titleCase(this.value));\n      })\n    ],\n    [\n      \"capitalize\",\n      new FunctionValue(() => {\n        return new StringValue(this.value.charAt(0).toUpperCase() + this.value.slice(1));\n      })\n    ],\n    [\"length\", new IntegerValue(this.value.length)],\n    [\n      \"rstrip\",\n      new FunctionValue(() => {\n        return new StringValue(this.value.trimEnd());\n      })\n    ],\n    [\n      \"lstrip\",\n      new FunctionValue(() => {\n        return new StringValue(this.value.trimStart());\n      })\n    ],\n    [\n      \"startswith\",\n      new FunctionValue((args) => {\n        if (args.length === 0) {\n          throw new Error(\"startswith() requires at least one argument\");\n        }\n        const pattern = args[0];\n        if (pattern instanceof StringValue) {\n          return new BooleanValue(this.value.startsWith(pattern.value));\n        } else if (pattern instanceof ArrayValue) {\n          for (const item of pattern.value) {\n            if (!(item instanceof StringValue)) {\n              throw new Error(\"startswith() tuple elements must be strings\");\n            }\n            if (this.value.startsWith(item.value)) {\n              return new BooleanValue(true);\n            }\n          }\n          return new BooleanValue(false);\n        }\n        throw new Error(\"startswith() argument must be a string or tuple of strings\");\n      })\n    ],\n    [\n      \"endswith\",\n      new FunctionValue((args) => {\n        if (args.length === 0) {\n          throw new Error(\"endswith() requires at least one argument\");\n        }\n        const pattern = args[0];\n        if (pattern instanceof StringValue) {\n          return new BooleanValue(this.value.endsWith(pattern.value));\n        } else if (pattern instanceof ArrayValue) {\n          for (const item of pattern.value) {\n            if (!(item instanceof StringValue)) {\n              throw new Error(\"endswith() tuple elements must be strings\");\n            }\n            if (this.value.endsWith(item.value)) {\n              return new BooleanValue(true);\n            }\n          }\n          return new BooleanValue(false);\n        }\n        throw new Error(\"endswith() argument must be a string or tuple of strings\");\n      })\n    ],\n    [\n      \"split\",\n      // follows Python's `str.split(sep=None, maxsplit=-1)` function behavior\n      // https://docs.python.org/3.13/library/stdtypes.html#str.split\n      new FunctionValue((args) => {\n        const sep = args[0] ?? new NullValue();\n        if (!(sep instanceof StringValue || sep instanceof NullValue)) {\n          throw new Error(\"sep argument must be a string or null\");\n        }\n        const maxsplit = args[1] ?? new IntegerValue(-1);\n        if (!(maxsplit instanceof IntegerValue)) {\n          throw new Error(\"maxsplit argument must be a number\");\n        }\n        let result = [];\n        if (sep instanceof NullValue) {\n          const text = this.value.trimStart();\n          for (const { 0: match, index } of text.matchAll(/\\S+/g)) {\n            if (maxsplit.value !== -1 && result.length >= maxsplit.value && index !== void 0) {\n              result.push(match + text.slice(index + match.length));\n              break;\n            }\n            result.push(match);\n          }\n        } else {\n          if (sep.value === \"\") {\n            throw new Error(\"empty separator\");\n          }\n          result = this.value.split(sep.value);\n          if (maxsplit.value !== -1 && result.length > maxsplit.value) {\n            result.push(result.splice(maxsplit.value).join(sep.value));\n          }\n        }\n        return new ArrayValue(result.map((part) => new StringValue(part)));\n      })\n    ],\n    [\n      \"replace\",\n      new FunctionValue((args) => {\n        if (args.length < 2) {\n          throw new Error(\"replace() requires at least two arguments\");\n        }\n        const oldValue = args[0];\n        const newValue = args[1];\n        if (!(oldValue instanceof StringValue && newValue instanceof StringValue)) {\n          throw new Error(\"replace() arguments must be strings\");\n        }\n        let count;\n        if (args.length > 2) {\n          if (args[2].type === \"KeywordArgumentsValue\") {\n            count = args[2].value.get(\"count\") ?? new NullValue();\n          } else {\n            count = args[2];\n          }\n        } else {\n          count = new NullValue();\n        }\n        if (!(count instanceof IntegerValue || count instanceof NullValue)) {\n          throw new Error(\"replace() count argument must be a number or null\");\n        }\n        return new StringValue(replace(this.value, oldValue.value, newValue.value, count.value));\n      })\n    ]\n  ]);\n};\nvar BooleanValue = class extends RuntimeValue {\n  type = \"BooleanValue\";\n};\nvar ObjectValue = class extends RuntimeValue {\n  type = \"ObjectValue\";\n  /**\n   * NOTE: necessary to override since all JavaScript arrays are considered truthy,\n   * while only non-empty Python arrays are consider truthy.\n   *\n   * e.g.,\n   *  - JavaScript:  {} && 5 -> 5\n   *  - Python:      {} and 5 -> {}\n   */\n  __bool__() {\n    return new BooleanValue(this.value.size > 0);\n  }\n  builtins = /* @__PURE__ */ new Map([\n    [\n      \"get\",\n      new FunctionValue(([key, defaultValue]) => {\n        if (!(key instanceof StringValue)) {\n          throw new Error(`Object key must be a string: got ${key.type}`);\n        }\n        return this.value.get(key.value) ?? defaultValue ?? new NullValue();\n      })\n    ],\n    [\"items\", new FunctionValue(() => this.items())],\n    [\"keys\", new FunctionValue(() => this.keys())],\n    [\"values\", new FunctionValue(() => this.values())]\n  ]);\n  items() {\n    return new ArrayValue(\n      Array.from(this.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value]))\n    );\n  }\n  keys() {\n    return new ArrayValue(Array.from(this.value.keys()).map((key) => new StringValue(key)));\n  }\n  values() {\n    return new ArrayValue(Array.from(this.value.values()));\n  }\n};\nvar KeywordArgumentsValue = class extends ObjectValue {\n  type = \"KeywordArgumentsValue\";\n};\nvar ArrayValue = class extends RuntimeValue {\n  type = \"ArrayValue\";\n  builtins = /* @__PURE__ */ new Map([[\"length\", new IntegerValue(this.value.length)]]);\n  /**\n   * NOTE: necessary to override since all JavaScript arrays are considered truthy,\n   * while only non-empty Python arrays are consider truthy.\n   *\n   * e.g.,\n   *  - JavaScript:  [] && 5 -> 5\n   *  - Python:      [] and 5 -> []\n   */\n  __bool__() {\n    return new BooleanValue(this.value.length > 0);\n  }\n};\nvar TupleValue = class extends ArrayValue {\n  type = \"TupleValue\";\n};\nvar FunctionValue = class extends RuntimeValue {\n  type = \"FunctionValue\";\n};\nvar NullValue = class extends RuntimeValue {\n  type = \"NullValue\";\n};\nvar UndefinedValue = class extends RuntimeValue {\n  type = \"UndefinedValue\";\n};\nvar Environment = class {\n  constructor(parent) {\n    this.parent = parent;\n  }\n  /**\n   * The variables declared in this environment.\n   */\n  variables = /* @__PURE__ */ new Map([\n    [\n      \"namespace\",\n      new FunctionValue((args) => {\n        if (args.length === 0) {\n          return new ObjectValue(/* @__PURE__ */ new Map());\n        }\n        if (args.length !== 1 || !(args[0] instanceof ObjectValue)) {\n          throw new Error(\"`namespace` expects either zero arguments or a single object argument\");\n        }\n        return args[0];\n      })\n    ]\n  ]);\n  /**\n   * The tests available in this environment.\n   */\n  tests = /* @__PURE__ */ new Map([\n    [\"boolean\", (operand) => operand.type === \"BooleanValue\"],\n    [\"callable\", (operand) => operand instanceof FunctionValue],\n    [\n      \"odd\",\n      (operand) => {\n        if (!(operand instanceof IntegerValue)) {\n          throw new Error(`cannot odd on ${operand.type}`);\n        }\n        return operand.value % 2 !== 0;\n      }\n    ],\n    [\n      \"even\",\n      (operand) => {\n        if (!(operand instanceof IntegerValue)) {\n          throw new Error(`cannot even on ${operand.type}`);\n        }\n        return operand.value % 2 === 0;\n      }\n    ],\n    [\"false\", (operand) => operand.type === \"BooleanValue\" && !operand.value],\n    [\"true\", (operand) => operand.type === \"BooleanValue\" && operand.value],\n    [\"none\", (operand) => operand.type === \"NullValue\"],\n    [\"string\", (operand) => operand.type === \"StringValue\"],\n    [\"number\", (operand) => operand instanceof IntegerValue || operand instanceof FloatValue],\n    [\"integer\", (operand) => operand instanceof IntegerValue],\n    [\"iterable\", (operand) => operand.type === \"ArrayValue\" || operand.type === \"StringValue\"],\n    [\"mapping\", (operand) => operand.type === \"ObjectValue\"],\n    [\n      \"lower\",\n      (operand) => {\n        const str = operand.value;\n        return operand.type === \"StringValue\" && str === str.toLowerCase();\n      }\n    ],\n    [\n      \"upper\",\n      (operand) => {\n        const str = operand.value;\n        return operand.type === \"StringValue\" && str === str.toUpperCase();\n      }\n    ],\n    [\"none\", (operand) => operand.type === \"NullValue\"],\n    [\"defined\", (operand) => operand.type !== \"UndefinedValue\"],\n    [\"undefined\", (operand) => operand.type === \"UndefinedValue\"],\n    [\"equalto\", (a, b) => a.value === b.value],\n    [\"eq\", (a, b) => a.value === b.value]\n  ]);\n  /**\n   * Set the value of a variable in the current environment.\n   */\n  set(name, value) {\n    return this.declareVariable(name, convertToRuntimeValues(value));\n  }\n  declareVariable(name, value) {\n    if (this.variables.has(name)) {\n      throw new SyntaxError(`Variable already declared: ${name}`);\n    }\n    this.variables.set(name, value);\n    return value;\n  }\n  // private assignVariable(name: string, value: AnyRuntimeValue): AnyRuntimeValue {\n  // \tconst env = this.resolve(name);\n  // \tenv.variables.set(name, value);\n  // \treturn value;\n  // }\n  /**\n   * Set variable in the current scope.\n   * See https://jinja.palletsprojects.com/en/3.0.x/templates/#assignments for more information.\n   */\n  setVariable(name, value) {\n    this.variables.set(name, value);\n    return value;\n  }\n  /**\n   * Resolve the environment in which the variable is declared.\n   * @param {string} name The name of the variable.\n   * @returns {Environment} The environment in which the variable is declared.\n   */\n  resolve(name) {\n    if (this.variables.has(name)) {\n      return this;\n    }\n    if (this.parent) {\n      return this.parent.resolve(name);\n    }\n    throw new Error(`Unknown variable: ${name}`);\n  }\n  lookupVariable(name) {\n    try {\n      return this.resolve(name).variables.get(name) ?? new UndefinedValue();\n    } catch {\n      return new UndefinedValue();\n    }\n  }\n};\nfunction setupGlobals(env) {\n  env.set(\"false\", false);\n  env.set(\"true\", true);\n  env.set(\"none\", null);\n  env.set(\"raise_exception\", (args) => {\n    throw new Error(args);\n  });\n  env.set(\"range\", range);\n  env.set(\"strftime_now\", strftime_now);\n  env.set(\"True\", true);\n  env.set(\"False\", false);\n  env.set(\"None\", null);\n}\nvar Interpreter = class {\n  global;\n  constructor(env) {\n    this.global = env ?? new Environment();\n  }\n  /**\n   * Run the program.\n   */\n  run(program) {\n    return this.evaluate(program, this.global);\n  }\n  /**\n   * Evaluates expressions following the binary operation type.\n   */\n  evaluateBinaryExpression(node, environment) {\n    const left = this.evaluate(node.left, environment);\n    switch (node.operator.value) {\n      case \"and\":\n        return left.__bool__().value ? this.evaluate(node.right, environment) : left;\n      case \"or\":\n        return left.__bool__().value ? left : this.evaluate(node.right, environment);\n    }\n    const right = this.evaluate(node.right, environment);\n    switch (node.operator.value) {\n      case \"==\":\n        return new BooleanValue(left.value == right.value);\n      case \"!=\":\n        return new BooleanValue(left.value != right.value);\n    }\n    if (left instanceof UndefinedValue || right instanceof UndefinedValue) {\n      if (right instanceof UndefinedValue && [\"in\", \"not in\"].includes(node.operator.value)) {\n        return new BooleanValue(node.operator.value === \"not in\");\n      }\n      throw new Error(`Cannot perform operation ${node.operator.value} on undefined values`);\n    } else if (left instanceof NullValue || right instanceof NullValue) {\n      throw new Error(\"Cannot perform operation on null values\");\n    } else if (node.operator.value === \"~\") {\n      return new StringValue(left.value.toString() + right.value.toString());\n    } else if ((left instanceof IntegerValue || left instanceof FloatValue) && (right instanceof IntegerValue || right instanceof FloatValue)) {\n      const a = left.value, b = right.value;\n      switch (node.operator.value) {\n        case \"+\":\n        case \"-\":\n        case \"*\": {\n          const res = node.operator.value === \"+\" ? a + b : node.operator.value === \"-\" ? a - b : a * b;\n          const isFloat = left instanceof FloatValue || right instanceof FloatValue;\n          return isFloat ? new FloatValue(res) : new IntegerValue(res);\n        }\n        case \"/\":\n          return new FloatValue(a / b);\n        case \"%\": {\n          const rem = a % b;\n          const isFloat = left instanceof FloatValue || right instanceof FloatValue;\n          return isFloat ? new FloatValue(rem) : new IntegerValue(rem);\n        }\n        case \"<\":\n          return new BooleanValue(a < b);\n        case \">\":\n          return new BooleanValue(a > b);\n        case \">=\":\n          return new BooleanValue(a >= b);\n        case \"<=\":\n          return new BooleanValue(a <= b);\n      }\n    } else if (left instanceof ArrayValue && right instanceof ArrayValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new ArrayValue(left.value.concat(right.value));\n      }\n    } else if (right instanceof ArrayValue) {\n      const member = right.value.find((x) => x.value === left.value) !== void 0;\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(member);\n        case \"not in\":\n          return new BooleanValue(!member);\n      }\n    }\n    if (left instanceof StringValue || right instanceof StringValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new StringValue(left.value.toString() + right.value.toString());\n      }\n    }\n    if (left instanceof StringValue && right instanceof StringValue) {\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(right.value.includes(left.value));\n        case \"not in\":\n          return new BooleanValue(!right.value.includes(left.value));\n      }\n    }\n    if (left instanceof StringValue && right instanceof ObjectValue) {\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(right.value.has(left.value));\n        case \"not in\":\n          return new BooleanValue(!right.value.has(left.value));\n      }\n    }\n    throw new SyntaxError(`Unknown operator \"${node.operator.value}\" between ${left.type} and ${right.type}`);\n  }\n  evaluateArguments(args, environment) {\n    const positionalArguments = [];\n    const keywordArguments = /* @__PURE__ */ new Map();\n    for (const argument of args) {\n      if (argument.type === \"SpreadExpression\") {\n        const spreadNode = argument;\n        const val = this.evaluate(spreadNode.argument, environment);\n        if (!(val instanceof ArrayValue)) {\n          throw new Error(`Cannot unpack non-iterable type: ${val.type}`);\n        }\n        for (const item of val.value) {\n          positionalArguments.push(item);\n        }\n      } else if (argument.type === \"KeywordArgumentExpression\") {\n        const kwarg = argument;\n        keywordArguments.set(kwarg.key.value, this.evaluate(kwarg.value, environment));\n      } else {\n        if (keywordArguments.size > 0) {\n          throw new Error(\"Positional arguments must come before keyword arguments\");\n        }\n        positionalArguments.push(this.evaluate(argument, environment));\n      }\n    }\n    return [positionalArguments, keywordArguments];\n  }\n  applyFilter(operand, filterNode, environment) {\n    if (filterNode.type === \"Identifier\") {\n      const filter = filterNode;\n      if (filter.value === \"tojson\") {\n        return new StringValue(toJSON(operand));\n      }\n      if (operand instanceof ArrayValue) {\n        switch (filter.value) {\n          case \"list\":\n            return operand;\n          case \"first\":\n            return operand.value[0];\n          case \"last\":\n            return operand.value[operand.value.length - 1];\n          case \"length\":\n            return new IntegerValue(operand.value.length);\n          case \"reverse\":\n            return new ArrayValue(operand.value.reverse());\n          case \"sort\":\n            return new ArrayValue(\n              operand.value.sort((a, b) => {\n                if (a.type !== b.type) {\n                  throw new Error(`Cannot compare different types: ${a.type} and ${b.type}`);\n                }\n                switch (a.type) {\n                  case \"IntegerValue\":\n                  case \"FloatValue\":\n                    return a.value - b.value;\n                  case \"StringValue\":\n                    return a.value.localeCompare(b.value);\n                  default:\n                    throw new Error(`Cannot compare type: ${a.type}`);\n                }\n              })\n            );\n          case \"join\":\n            return new StringValue(operand.value.map((x) => x.value).join(\"\"));\n          case \"string\":\n            return new StringValue(toJSON(operand));\n          case \"unique\": {\n            const seen = /* @__PURE__ */ new Set();\n            const output = [];\n            for (const item of operand.value) {\n              if (!seen.has(item.value)) {\n                seen.add(item.value);\n                output.push(item);\n              }\n            }\n            return new ArrayValue(output);\n          }\n          default:\n            throw new Error(`Unknown ArrayValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof StringValue) {\n        switch (filter.value) {\n          case \"length\":\n          case \"upper\":\n          case \"lower\":\n          case \"title\":\n          case \"capitalize\": {\n            const builtin = operand.builtins.get(filter.value);\n            if (builtin instanceof FunctionValue) {\n              return builtin.value(\n                /* no arguments */\n                [],\n                environment\n              );\n            } else if (builtin instanceof IntegerValue) {\n              return builtin;\n            } else {\n              throw new Error(`Unknown StringValue filter: ${filter.value}`);\n            }\n          }\n          case \"trim\":\n            return new StringValue(operand.value.trim());\n          case \"indent\":\n            return new StringValue(\n              operand.value.split(\"\\n\").map(\n                (x, i) => (\n                  // By default, don't indent the first line or empty lines\n                  i === 0 || x.length === 0 ? x : \"    \" + x\n                )\n              ).join(\"\\n\")\n            );\n          case \"join\":\n          case \"string\":\n            return operand;\n          case \"int\": {\n            const val = parseInt(operand.value, 10);\n            return new IntegerValue(isNaN(val) ? 0 : val);\n          }\n          case \"float\": {\n            const val = parseFloat(operand.value);\n            return new FloatValue(isNaN(val) ? 0 : val);\n          }\n          default:\n            throw new Error(`Unknown StringValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof IntegerValue || operand instanceof FloatValue) {\n        switch (filter.value) {\n          case \"abs\":\n            return operand instanceof IntegerValue ? new IntegerValue(Math.abs(operand.value)) : new FloatValue(Math.abs(operand.value));\n          case \"int\":\n            return new IntegerValue(Math.floor(operand.value));\n          case \"float\":\n            return new FloatValue(operand.value);\n          default:\n            throw new Error(`Unknown NumericValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof ObjectValue) {\n        switch (filter.value) {\n          case \"items\":\n            return new ArrayValue(\n              Array.from(operand.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value]))\n            );\n          case \"length\":\n            return new IntegerValue(operand.value.size);\n          default:\n            throw new Error(`Unknown ObjectValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof BooleanValue) {\n        switch (filter.value) {\n          case \"bool\":\n            return new BooleanValue(operand.value);\n          case \"int\":\n            return new IntegerValue(operand.value ? 1 : 0);\n          case \"float\":\n            return new FloatValue(operand.value ? 1 : 0);\n          case \"string\":\n            return new StringValue(operand.value ? \"true\" : \"false\");\n          default:\n            throw new Error(`Unknown BooleanValue filter: ${filter.value}`);\n        }\n      }\n      throw new Error(`Cannot apply filter \"${filter.value}\" to type: ${operand.type}`);\n    } else if (filterNode.type === \"CallExpression\") {\n      const filter = filterNode;\n      if (filter.callee.type !== \"Identifier\") {\n        throw new Error(`Unknown filter: ${filter.callee.type}`);\n      }\n      const filterName = filter.callee.value;\n      if (filterName === \"tojson\") {\n        const [, kwargs] = this.evaluateArguments(filter.args, environment);\n        const indent = kwargs.get(\"indent\") ?? new NullValue();\n        if (!(indent instanceof IntegerValue || indent instanceof NullValue)) {\n          throw new Error(\"If set, indent must be a number\");\n        }\n        return new StringValue(toJSON(operand, indent.value));\n      } else if (filterName === \"join\") {\n        let value;\n        if (operand instanceof StringValue) {\n          value = Array.from(operand.value);\n        } else if (operand instanceof ArrayValue) {\n          value = operand.value.map((x) => x.value);\n        } else {\n          throw new Error(`Cannot apply filter \"${filterName}\" to type: ${operand.type}`);\n        }\n        const [args, kwargs] = this.evaluateArguments(filter.args, environment);\n        const separator = args.at(0) ?? kwargs.get(\"separator\") ?? new StringValue(\"\");\n        if (!(separator instanceof StringValue)) {\n          throw new Error(\"separator must be a string\");\n        }\n        return new StringValue(value.join(separator.value));\n      } else if (filterName === \"int\" || filterName === \"float\") {\n        const [args, kwargs] = this.evaluateArguments(filter.args, environment);\n        const defaultValue = args.at(0) ?? kwargs.get(\"default\") ?? (filterName === \"int\" ? new IntegerValue(0) : new FloatValue(0));\n        if (operand instanceof StringValue) {\n          const val = filterName === \"int\" ? parseInt(operand.value, 10) : parseFloat(operand.value);\n          return isNaN(val) ? defaultValue : filterName === \"int\" ? new IntegerValue(val) : new FloatValue(val);\n        } else if (operand instanceof IntegerValue || operand instanceof FloatValue) {\n          return operand;\n        } else if (operand instanceof BooleanValue) {\n          return filterName === \"int\" ? new IntegerValue(operand.value ? 1 : 0) : new FloatValue(operand.value ? 1 : 0);\n        } else {\n          throw new Error(`Cannot apply filter \"${filterName}\" to type: ${operand.type}`);\n        }\n      } else if (filterName === \"default\") {\n        const [args, kwargs] = this.evaluateArguments(filter.args, environment);\n        const defaultValue = args[0] ?? new StringValue(\"\");\n        const booleanValue = args[1] ?? kwargs.get(\"boolean\") ?? new BooleanValue(false);\n        if (!(booleanValue instanceof BooleanValue)) {\n          throw new Error(\"`default` filter flag must be a boolean\");\n        }\n        if (operand instanceof UndefinedValue || booleanValue.value && !operand.__bool__().value) {\n          return defaultValue;\n        }\n        return operand;\n      }\n      if (operand instanceof ArrayValue) {\n        switch (filterName) {\n          case \"selectattr\":\n          case \"rejectattr\": {\n            const select = filterName === \"selectattr\";\n            if (operand.value.some((x) => !(x instanceof ObjectValue))) {\n              throw new Error(`\\`${filterName}\\` can only be applied to array of objects`);\n            }\n            if (filter.args.some((x) => x.type !== \"StringLiteral\")) {\n              throw new Error(`arguments of \\`${filterName}\\` must be strings`);\n            }\n            const [attr, testName, value] = filter.args.map((x) => this.evaluate(x, environment));\n            let testFunction;\n            if (testName) {\n              const test = environment.tests.get(testName.value);\n              if (!test) {\n                throw new Error(`Unknown test: ${testName.value}`);\n              }\n              testFunction = test;\n            } else {\n              testFunction = (...x) => x[0].__bool__().value;\n            }\n            const filtered = operand.value.filter((item) => {\n              const a = item.value.get(attr.value);\n              const result = a ? testFunction(a, value) : false;\n              return select ? result : !result;\n            });\n            return new ArrayValue(filtered);\n          }\n          case \"map\": {\n            const [, kwargs] = this.evaluateArguments(filter.args, environment);\n            if (kwargs.has(\"attribute\")) {\n              const attr = kwargs.get(\"attribute\");\n              if (!(attr instanceof StringValue)) {\n                throw new Error(\"attribute must be a string\");\n              }\n              const defaultValue = kwargs.get(\"default\");\n              const mapped = operand.value.map((item) => {\n                if (!(item instanceof ObjectValue)) {\n                  throw new Error(\"items in map must be an object\");\n                }\n                return item.value.get(attr.value) ?? defaultValue ?? new UndefinedValue();\n              });\n              return new ArrayValue(mapped);\n            } else {\n              throw new Error(\"`map` expressions without `attribute` set are not currently supported.\");\n            }\n          }\n        }\n        throw new Error(`Unknown ArrayValue filter: ${filterName}`);\n      } else if (operand instanceof StringValue) {\n        switch (filterName) {\n          case \"indent\": {\n            const [args, kwargs] = this.evaluateArguments(filter.args, environment);\n            const width = args.at(0) ?? kwargs.get(\"width\") ?? new IntegerValue(4);\n            if (!(width instanceof IntegerValue)) {\n              throw new Error(\"width must be a number\");\n            }\n            const first = args.at(1) ?? kwargs.get(\"first\") ?? new BooleanValue(false);\n            const blank = args.at(2) ?? kwargs.get(\"blank\") ?? new BooleanValue(false);\n            const lines = operand.value.split(\"\\n\");\n            const indent = \" \".repeat(width.value);\n            const indented = lines.map(\n              (x, i) => !first.value && i === 0 || !blank.value && x.length === 0 ? x : indent + x\n            );\n            return new StringValue(indented.join(\"\\n\"));\n          }\n          case \"replace\": {\n            const replaceFn = operand.builtins.get(\"replace\");\n            if (!(replaceFn instanceof FunctionValue)) {\n              throw new Error(\"replace filter not available\");\n            }\n            const [args, kwargs] = this.evaluateArguments(filter.args, environment);\n            return replaceFn.value([...args, new KeywordArgumentsValue(kwargs)], environment);\n          }\n        }\n        throw new Error(`Unknown StringValue filter: ${filterName}`);\n      } else {\n        throw new Error(`Cannot apply filter \"${filterName}\" to type: ${operand.type}`);\n      }\n    }\n    throw new Error(`Unknown filter: ${filterNode.type}`);\n  }\n  /**\n   * Evaluates expressions following the filter operation type.\n   */\n  evaluateFilterExpression(node, environment) {\n    const operand = this.evaluate(node.operand, environment);\n    return this.applyFilter(operand, node.filter, environment);\n  }\n  /**\n   * Evaluates expressions following the test operation type.\n   */\n  evaluateTestExpression(node, environment) {\n    const operand = this.evaluate(node.operand, environment);\n    const test = environment.tests.get(node.test.value);\n    if (!test) {\n      throw new Error(`Unknown test: ${node.test.value}`);\n    }\n    const result = test(operand);\n    return new BooleanValue(node.negate ? !result : result);\n  }\n  /**\n   * Evaluates expressions following the select operation type.\n   */\n  evaluateSelectExpression(node, environment) {\n    const predicate = this.evaluate(node.test, environment);\n    if (!predicate.__bool__().value) {\n      return new UndefinedValue();\n    }\n    return this.evaluate(node.lhs, environment);\n  }\n  /**\n   * Evaluates expressions following the unary operation type.\n   */\n  evaluateUnaryExpression(node, environment) {\n    const argument = this.evaluate(node.argument, environment);\n    switch (node.operator.value) {\n      case \"not\":\n        return new BooleanValue(!argument.value);\n      default:\n        throw new SyntaxError(`Unknown operator: ${node.operator.value}`);\n    }\n  }\n  evaluateTernaryExpression(node, environment) {\n    const cond = this.evaluate(node.condition, environment);\n    return cond.__bool__().value ? this.evaluate(node.trueExpr, environment) : this.evaluate(node.falseExpr, environment);\n  }\n  evalProgram(program, environment) {\n    return this.evaluateBlock(program.body, environment);\n  }\n  evaluateBlock(statements, environment) {\n    let result = \"\";\n    for (const statement of statements) {\n      const lastEvaluated = this.evaluate(statement, environment);\n      if (lastEvaluated.type !== \"NullValue\" && lastEvaluated.type !== \"UndefinedValue\") {\n        result += lastEvaluated.toString();\n      }\n    }\n    return new StringValue(result);\n  }\n  evaluateIdentifier(node, environment) {\n    return environment.lookupVariable(node.value);\n  }\n  evaluateCallExpression(expr, environment) {\n    const [args, kwargs] = this.evaluateArguments(expr.args, environment);\n    if (kwargs.size > 0) {\n      args.push(new KeywordArgumentsValue(kwargs));\n    }\n    const fn = this.evaluate(expr.callee, environment);\n    if (fn.type !== \"FunctionValue\") {\n      throw new Error(`Cannot call something that is not a function: got ${fn.type}`);\n    }\n    return fn.value(args, environment);\n  }\n  evaluateSliceExpression(object, expr, environment) {\n    if (!(object instanceof ArrayValue || object instanceof StringValue)) {\n      throw new Error(\"Slice object must be an array or string\");\n    }\n    const start = this.evaluate(expr.start, environment);\n    const stop = this.evaluate(expr.stop, environment);\n    const step = this.evaluate(expr.step, environment);\n    if (!(start instanceof IntegerValue || start instanceof UndefinedValue)) {\n      throw new Error(\"Slice start must be numeric or undefined\");\n    }\n    if (!(stop instanceof IntegerValue || stop instanceof UndefinedValue)) {\n      throw new Error(\"Slice stop must be numeric or undefined\");\n    }\n    if (!(step instanceof IntegerValue || step instanceof UndefinedValue)) {\n      throw new Error(\"Slice step must be numeric or undefined\");\n    }\n    if (object instanceof ArrayValue) {\n      return new ArrayValue(slice(object.value, start.value, stop.value, step.value));\n    } else {\n      return new StringValue(slice(Array.from(object.value), start.value, stop.value, step.value).join(\"\"));\n    }\n  }\n  evaluateMemberExpression(expr, environment) {\n    const object = this.evaluate(expr.object, environment);\n    let property;\n    if (expr.computed) {\n      if (expr.property.type === \"SliceExpression\") {\n        return this.evaluateSliceExpression(object, expr.property, environment);\n      } else {\n        property = this.evaluate(expr.property, environment);\n      }\n    } else {\n      property = new StringValue(expr.property.value);\n    }\n    let value;\n    if (object instanceof ObjectValue) {\n      if (!(property instanceof StringValue)) {\n        throw new Error(`Cannot access property with non-string: got ${property.type}`);\n      }\n      value = object.value.get(property.value) ?? object.builtins.get(property.value);\n    } else if (object instanceof ArrayValue || object instanceof StringValue) {\n      if (property instanceof IntegerValue) {\n        value = object.value.at(property.value);\n        if (object instanceof StringValue) {\n          value = new StringValue(object.value.at(property.value));\n        }\n      } else if (property instanceof StringValue) {\n        value = object.builtins.get(property.value);\n      } else {\n        throw new Error(`Cannot access property with non-string/non-number: got ${property.type}`);\n      }\n    } else {\n      if (!(property instanceof StringValue)) {\n        throw new Error(`Cannot access property with non-string: got ${property.type}`);\n      }\n      value = object.builtins.get(property.value);\n    }\n    return value instanceof RuntimeValue ? value : new UndefinedValue();\n  }\n  evaluateSet(node, environment) {\n    const rhs = node.value ? this.evaluate(node.value, environment) : this.evaluateBlock(node.body, environment);\n    if (node.assignee.type === \"Identifier\") {\n      const variableName = node.assignee.value;\n      environment.setVariable(variableName, rhs);\n    } else if (node.assignee.type === \"TupleLiteral\") {\n      const tuple = node.assignee;\n      if (!(rhs instanceof ArrayValue)) {\n        throw new Error(`Cannot unpack non-iterable type in set: ${rhs.type}`);\n      }\n      const arr = rhs.value;\n      if (arr.length !== tuple.value.length) {\n        throw new Error(`Too ${tuple.value.length > arr.length ? \"few\" : \"many\"} items to unpack in set`);\n      }\n      for (let i = 0; i < tuple.value.length; ++i) {\n        const elem = tuple.value[i];\n        if (elem.type !== \"Identifier\") {\n          throw new Error(`Cannot unpack to non-identifier in set: ${elem.type}`);\n        }\n        environment.setVariable(elem.value, arr[i]);\n      }\n    } else if (node.assignee.type === \"MemberExpression\") {\n      const member = node.assignee;\n      const object = this.evaluate(member.object, environment);\n      if (!(object instanceof ObjectValue)) {\n        throw new Error(\"Cannot assign to member of non-object\");\n      }\n      if (member.property.type !== \"Identifier\") {\n        throw new Error(\"Cannot assign to member with non-identifier property\");\n      }\n      object.value.set(member.property.value, rhs);\n    } else {\n      throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(node.assignee)}`);\n    }\n    return new NullValue();\n  }\n  evaluateIf(node, environment) {\n    const test = this.evaluate(node.test, environment);\n    return this.evaluateBlock(test.__bool__().value ? node.body : node.alternate, environment);\n  }\n  evaluateFor(node, environment) {\n    const scope = new Environment(environment);\n    let test, iterable;\n    if (node.iterable.type === \"SelectExpression\") {\n      const select = node.iterable;\n      iterable = this.evaluate(select.lhs, scope);\n      test = select.test;\n    } else {\n      iterable = this.evaluate(node.iterable, scope);\n    }\n    if (!(iterable instanceof ArrayValue || iterable instanceof ObjectValue)) {\n      throw new Error(`Expected iterable or object type in for loop: got ${iterable.type}`);\n    }\n    if (iterable instanceof ObjectValue) {\n      iterable = iterable.keys();\n    }\n    const items = [];\n    const scopeUpdateFunctions = [];\n    for (let i = 0; i < iterable.value.length; ++i) {\n      const loopScope = new Environment(scope);\n      const current = iterable.value[i];\n      let scopeUpdateFunction;\n      if (node.loopvar.type === \"Identifier\") {\n        scopeUpdateFunction = (scope2) => scope2.setVariable(node.loopvar.value, current);\n      } else if (node.loopvar.type === \"TupleLiteral\") {\n        const loopvar = node.loopvar;\n        if (current.type !== \"ArrayValue\") {\n          throw new Error(`Cannot unpack non-iterable type: ${current.type}`);\n        }\n        const c = current;\n        if (loopvar.value.length !== c.value.length) {\n          throw new Error(`Too ${loopvar.value.length > c.value.length ? \"few\" : \"many\"} items to unpack`);\n        }\n        scopeUpdateFunction = (scope2) => {\n          for (let j = 0; j < loopvar.value.length; ++j) {\n            if (loopvar.value[j].type !== \"Identifier\") {\n              throw new Error(`Cannot unpack non-identifier type: ${loopvar.value[j].type}`);\n            }\n            scope2.setVariable(loopvar.value[j].value, c.value[j]);\n          }\n        };\n      } else {\n        throw new Error(`Invalid loop variable(s): ${node.loopvar.type}`);\n      }\n      if (test) {\n        scopeUpdateFunction(loopScope);\n        const testValue = this.evaluate(test, loopScope);\n        if (!testValue.__bool__().value) {\n          continue;\n        }\n      }\n      items.push(current);\n      scopeUpdateFunctions.push(scopeUpdateFunction);\n    }\n    let result = \"\";\n    let noIteration = true;\n    for (let i = 0; i < items.length; ++i) {\n      const loop = /* @__PURE__ */ new Map([\n        [\"index\", new IntegerValue(i + 1)],\n        [\"index0\", new IntegerValue(i)],\n        [\"revindex\", new IntegerValue(items.length - i)],\n        [\"revindex0\", new IntegerValue(items.length - i - 1)],\n        [\"first\", new BooleanValue(i === 0)],\n        [\"last\", new BooleanValue(i === items.length - 1)],\n        [\"length\", new IntegerValue(items.length)],\n        [\"previtem\", i > 0 ? items[i - 1] : new UndefinedValue()],\n        [\"nextitem\", i < items.length - 1 ? items[i + 1] : new UndefinedValue()]\n      ]);\n      scope.setVariable(\"loop\", new ObjectValue(loop));\n      scopeUpdateFunctions[i](scope);\n      try {\n        const evaluated = this.evaluateBlock(node.body, scope);\n        result += evaluated.value;\n      } catch (err) {\n        if (err instanceof ContinueControl) {\n          continue;\n        }\n        if (err instanceof BreakControl) {\n          break;\n        }\n        throw err;\n      }\n      noIteration = false;\n    }\n    if (noIteration) {\n      const defaultEvaluated = this.evaluateBlock(node.defaultBlock, scope);\n      result += defaultEvaluated.value;\n    }\n    return new StringValue(result);\n  }\n  /**\n   * See https://jinja.palletsprojects.com/en/3.1.x/templates/#macros for more information.\n   */\n  evaluateMacro(node, environment) {\n    environment.setVariable(\n      node.name.value,\n      new FunctionValue((args, scope) => {\n        const macroScope = new Environment(scope);\n        args = args.slice();\n        let kwargs;\n        if (args.at(-1)?.type === \"KeywordArgumentsValue\") {\n          kwargs = args.pop();\n        }\n        for (let i = 0; i < node.args.length; ++i) {\n          const nodeArg = node.args[i];\n          const passedArg = args[i];\n          if (nodeArg.type === \"Identifier\") {\n            const identifier = nodeArg;\n            if (!passedArg) {\n              throw new Error(`Missing positional argument: ${identifier.value}`);\n            }\n            macroScope.setVariable(identifier.value, passedArg);\n          } else if (nodeArg.type === \"KeywordArgumentExpression\") {\n            const kwarg = nodeArg;\n            const value = passedArg ?? // Try positional arguments first\n            kwargs?.value.get(kwarg.key.value) ?? // Look in user-passed kwargs\n            this.evaluate(kwarg.value, macroScope);\n            macroScope.setVariable(kwarg.key.value, value);\n          } else {\n            throw new Error(`Unknown argument type: ${nodeArg.type}`);\n          }\n        }\n        return this.evaluateBlock(node.body, macroScope);\n      })\n    );\n    return new NullValue();\n  }\n  evaluateCallStatement(node, environment) {\n    const callerFn = new FunctionValue((callerArgs, callerEnv) => {\n      const callBlockEnv = new Environment(callerEnv);\n      if (node.callerArgs) {\n        for (let i = 0; i < node.callerArgs.length; ++i) {\n          const param = node.callerArgs[i];\n          if (param.type !== \"Identifier\") {\n            throw new Error(`Caller parameter must be an identifier, got ${param.type}`);\n          }\n          callBlockEnv.setVariable(param.value, callerArgs[i] ?? new UndefinedValue());\n        }\n      }\n      return this.evaluateBlock(node.body, callBlockEnv);\n    });\n    const [macroArgs, macroKwargs] = this.evaluateArguments(node.call.args, environment);\n    macroArgs.push(new KeywordArgumentsValue(macroKwargs));\n    const fn = this.evaluate(node.call.callee, environment);\n    if (fn.type !== \"FunctionValue\") {\n      throw new Error(`Cannot call something that is not a function: got ${fn.type}`);\n    }\n    const newEnv = new Environment(environment);\n    newEnv.setVariable(\"caller\", callerFn);\n    return fn.value(macroArgs, newEnv);\n  }\n  evaluateFilterStatement(node, environment) {\n    const rendered = this.evaluateBlock(node.body, environment);\n    return this.applyFilter(rendered, node.filter, environment);\n  }\n  evaluate(statement, environment) {\n    if (!statement)\n      return new UndefinedValue();\n    switch (statement.type) {\n      case \"Program\":\n        return this.evalProgram(statement, environment);\n      case \"Set\":\n        return this.evaluateSet(statement, environment);\n      case \"If\":\n        return this.evaluateIf(statement, environment);\n      case \"For\":\n        return this.evaluateFor(statement, environment);\n      case \"Macro\":\n        return this.evaluateMacro(statement, environment);\n      case \"CallStatement\":\n        return this.evaluateCallStatement(statement, environment);\n      case \"Break\":\n        throw new BreakControl();\n      case \"Continue\":\n        throw new ContinueControl();\n      case \"IntegerLiteral\":\n        return new IntegerValue(statement.value);\n      case \"FloatLiteral\":\n        return new FloatValue(statement.value);\n      case \"StringLiteral\":\n        return new StringValue(statement.value);\n      case \"ArrayLiteral\":\n        return new ArrayValue(statement.value.map((x) => this.evaluate(x, environment)));\n      case \"TupleLiteral\":\n        return new TupleValue(statement.value.map((x) => this.evaluate(x, environment)));\n      case \"ObjectLiteral\": {\n        const mapping = /* @__PURE__ */ new Map();\n        for (const [key, value] of statement.value) {\n          const evaluatedKey = this.evaluate(key, environment);\n          if (!(evaluatedKey instanceof StringValue)) {\n            throw new Error(`Object keys must be strings: got ${evaluatedKey.type}`);\n          }\n          mapping.set(evaluatedKey.value, this.evaluate(value, environment));\n        }\n        return new ObjectValue(mapping);\n      }\n      case \"Identifier\":\n        return this.evaluateIdentifier(statement, environment);\n      case \"CallExpression\":\n        return this.evaluateCallExpression(statement, environment);\n      case \"MemberExpression\":\n        return this.evaluateMemberExpression(statement, environment);\n      case \"UnaryExpression\":\n        return this.evaluateUnaryExpression(statement, environment);\n      case \"BinaryExpression\":\n        return this.evaluateBinaryExpression(statement, environment);\n      case \"FilterExpression\":\n        return this.evaluateFilterExpression(statement, environment);\n      case \"FilterStatement\":\n        return this.evaluateFilterStatement(statement, environment);\n      case \"TestExpression\":\n        return this.evaluateTestExpression(statement, environment);\n      case \"SelectExpression\":\n        return this.evaluateSelectExpression(statement, environment);\n      case \"Ternary\":\n        return this.evaluateTernaryExpression(statement, environment);\n      case \"Comment\":\n        return new NullValue();\n      default:\n        throw new SyntaxError(`Unknown node type: ${statement.type}`);\n    }\n  }\n};\nfunction convertToRuntimeValues(input) {\n  switch (typeof input) {\n    case \"number\":\n      return Number.isInteger(input) ? new IntegerValue(input) : new FloatValue(input);\n    case \"string\":\n      return new StringValue(input);\n    case \"boolean\":\n      return new BooleanValue(input);\n    case \"undefined\":\n      return new UndefinedValue();\n    case \"object\":\n      if (input === null) {\n        return new NullValue();\n      } else if (Array.isArray(input)) {\n        return new ArrayValue(input.map(convertToRuntimeValues));\n      } else {\n        return new ObjectValue(\n          new Map(Object.entries(input).map(([key, value]) => [key, convertToRuntimeValues(value)]))\n        );\n      }\n    case \"function\":\n      return new FunctionValue((args, _scope) => {\n        const result = input(...args.map((x) => x.value)) ?? null;\n        return convertToRuntimeValues(result);\n      });\n    default:\n      throw new Error(`Cannot convert to runtime value: ${input}`);\n  }\n}\nfunction toJSON(input, indent, depth) {\n  const currentDepth = depth ?? 0;\n  switch (input.type) {\n    case \"NullValue\":\n    case \"UndefinedValue\":\n      return \"null\";\n    case \"IntegerValue\":\n    case \"FloatValue\":\n    case \"StringValue\":\n    case \"BooleanValue\":\n      return JSON.stringify(input.value);\n    case \"ArrayValue\":\n    case \"ObjectValue\": {\n      const indentValue = indent ? \" \".repeat(indent) : \"\";\n      const basePadding = \"\\n\" + indentValue.repeat(currentDepth);\n      const childrenPadding = basePadding + indentValue;\n      if (input.type === \"ArrayValue\") {\n        const core = input.value.map((x) => toJSON(x, indent, currentDepth + 1));\n        return indent ? `[${childrenPadding}${core.join(`,${childrenPadding}`)}${basePadding}]` : `[${core.join(\", \")}]`;\n      } else {\n        const core = Array.from(input.value.entries()).map(([key, value]) => {\n          const v = `\"${key}\": ${toJSON(value, indent, currentDepth + 1)}`;\n          return indent ? `${childrenPadding}${v}` : v;\n        });\n        return indent ? `{${core.join(\",\")}${basePadding}}` : `{${core.join(\", \")}}`;\n      }\n    }\n    default:\n      throw new Error(`Cannot convert to JSON: ${input.type}`);\n  }\n}\n\n// src/format.ts\nvar NEWLINE = \"\\n\";\nvar OPEN_STATEMENT = \"{%- \";\nvar CLOSE_STATEMENT = \" -%}\";\nfunction getBinaryOperatorPrecedence(expr) {\n  switch (expr.operator.type) {\n    case \"MultiplicativeBinaryOperator\":\n      return 4;\n    case \"AdditiveBinaryOperator\":\n      return 3;\n    case \"ComparisonBinaryOperator\":\n      return 2;\n    case \"Identifier\":\n      if (expr.operator.value === \"and\")\n        return 1;\n      if (expr.operator.value === \"in\" || expr.operator.value === \"not in\")\n        return 2;\n      return 0;\n  }\n  return 0;\n}\nfunction format(program, indent = \"\t\") {\n  const indentStr = typeof indent === \"number\" ? \" \".repeat(indent) : indent;\n  const body = formatStatements(program.body, 0, indentStr);\n  return body.replace(/\\n$/, \"\");\n}\nfunction createStatement(...text) {\n  return OPEN_STATEMENT + text.join(\" \") + CLOSE_STATEMENT;\n}\nfunction formatStatements(stmts, depth, indentStr) {\n  return stmts.map((stmt) => formatStatement(stmt, depth, indentStr)).join(NEWLINE);\n}\nfunction formatStatement(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  switch (node.type) {\n    case \"Program\":\n      return formatStatements(node.body, depth, indentStr);\n    case \"If\":\n      return formatIf(node, depth, indentStr);\n    case \"For\":\n      return formatFor(node, depth, indentStr);\n    case \"Set\":\n      return formatSet(node, depth, indentStr);\n    case \"Macro\":\n      return formatMacro(node, depth, indentStr);\n    case \"Break\":\n      return pad + createStatement(\"break\");\n    case \"Continue\":\n      return pad + createStatement(\"continue\");\n    case \"CallStatement\":\n      return formatCallStatement(node, depth, indentStr);\n    case \"FilterStatement\":\n      return formatFilterStatement(node, depth, indentStr);\n    case \"Comment\":\n      return pad + \"{# \" + node.value + \" #}\";\n    default:\n      return pad + \"{{- \" + formatExpression(node) + \" -}}\";\n  }\n}\nfunction formatIf(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  const clauses = [];\n  let current = node;\n  while (current) {\n    clauses.push({ test: current.test, body: current.body });\n    if (current.alternate.length === 1 && current.alternate[0].type === \"If\") {\n      current = current.alternate[0];\n    } else {\n      break;\n    }\n  }\n  let out = pad + createStatement(\"if\", formatExpression(clauses[0].test)) + NEWLINE + formatStatements(clauses[0].body, depth + 1, indentStr);\n  for (let i = 1; i < clauses.length; ++i) {\n    out += NEWLINE + pad + createStatement(\"elif\", formatExpression(clauses[i].test)) + NEWLINE + formatStatements(clauses[i].body, depth + 1, indentStr);\n  }\n  if (current && current.alternate.length > 0) {\n    out += NEWLINE + pad + createStatement(\"else\") + NEWLINE + formatStatements(current.alternate, depth + 1, indentStr);\n  }\n  out += NEWLINE + pad + createStatement(\"endif\");\n  return out;\n}\nfunction formatFor(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  let formattedIterable = \"\";\n  if (node.iterable.type === \"SelectExpression\") {\n    const n = node.iterable;\n    formattedIterable = `${formatExpression(n.lhs)} if ${formatExpression(n.test)}`;\n  } else {\n    formattedIterable = formatExpression(node.iterable);\n  }\n  let out = pad + createStatement(\"for\", formatExpression(node.loopvar), \"in\", formattedIterable) + NEWLINE + formatStatements(node.body, depth + 1, indentStr);\n  if (node.defaultBlock.length > 0) {\n    out += NEWLINE + pad + createStatement(\"else\") + NEWLINE + formatStatements(node.defaultBlock, depth + 1, indentStr);\n  }\n  out += NEWLINE + pad + createStatement(\"endfor\");\n  return out;\n}\nfunction formatSet(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  const left = formatExpression(node.assignee);\n  const right = node.value ? formatExpression(node.value) : \"\";\n  const value = pad + createStatement(\"set\", `${left}${node.value ? \" = \" + right : \"\"}`);\n  if (node.body.length === 0) {\n    return value;\n  }\n  return value + NEWLINE + formatStatements(node.body, depth + 1, indentStr) + NEWLINE + pad + createStatement(\"endset\");\n}\nfunction formatMacro(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  const args = node.args.map(formatExpression).join(\", \");\n  return pad + createStatement(\"macro\", `${node.name.value}(${args})`) + NEWLINE + formatStatements(node.body, depth + 1, indentStr) + NEWLINE + pad + createStatement(\"endmacro\");\n}\nfunction formatCallStatement(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  const params = node.callerArgs && node.callerArgs.length > 0 ? `(${node.callerArgs.map(formatExpression).join(\", \")})` : \"\";\n  const callExpr = formatExpression(node.call);\n  let out = pad + createStatement(`call${params}`, callExpr) + NEWLINE;\n  out += formatStatements(node.body, depth + 1, indentStr) + NEWLINE;\n  out += pad + createStatement(\"endcall\");\n  return out;\n}\nfunction formatFilterStatement(node, depth, indentStr) {\n  const pad = indentStr.repeat(depth);\n  const spec = node.filter.type === \"Identifier\" ? node.filter.value : formatExpression(node.filter);\n  let out = pad + createStatement(\"filter\", spec) + NEWLINE;\n  out += formatStatements(node.body, depth + 1, indentStr) + NEWLINE;\n  out += pad + createStatement(\"endfilter\");\n  return out;\n}\nfunction formatExpression(node, parentPrec = -1) {\n  switch (node.type) {\n    case \"SpreadExpression\": {\n      const n = node;\n      return `*${formatExpression(n.argument)}`;\n    }\n    case \"Identifier\":\n      return node.value;\n    case \"IntegerLiteral\":\n      return `${node.value}`;\n    case \"FloatLiteral\":\n      return `${node.value}`;\n    case \"StringLiteral\":\n      return JSON.stringify(node.value);\n    case \"BinaryExpression\": {\n      const n = node;\n      const thisPrecedence = getBinaryOperatorPrecedence(n);\n      const left = formatExpression(n.left, thisPrecedence);\n      const right = formatExpression(n.right, thisPrecedence + 1);\n      const expr = `${left} ${n.operator.value} ${right}`;\n      return thisPrecedence < parentPrec ? `(${expr})` : expr;\n    }\n    case \"UnaryExpression\": {\n      const n = node;\n      const val = n.operator.value + (n.operator.value === \"not\" ? \" \" : \"\") + formatExpression(n.argument, Infinity);\n      return val;\n    }\n    case \"CallExpression\": {\n      const n = node;\n      const args = n.args.map(formatExpression).join(\", \");\n      return `${formatExpression(n.callee)}(${args})`;\n    }\n    case \"MemberExpression\": {\n      const n = node;\n      let obj = formatExpression(n.object);\n      if (![\n        \"Identifier\",\n        \"MemberExpression\",\n        \"CallExpression\",\n        \"StringLiteral\",\n        \"IntegerLiteral\",\n        \"FloatLiteral\",\n        \"ArrayLiteral\",\n        \"TupleLiteral\",\n        \"ObjectLiteral\"\n      ].includes(n.object.type)) {\n        obj = `(${obj})`;\n      }\n      let prop = formatExpression(n.property);\n      if (!n.computed && n.property.type !== \"Identifier\") {\n        prop = `(${prop})`;\n      }\n      return n.computed ? `${obj}[${prop}]` : `${obj}.${prop}`;\n    }\n    case \"FilterExpression\": {\n      const n = node;\n      const operand = formatExpression(n.operand, Infinity);\n      if (n.filter.type === \"CallExpression\") {\n        return `${operand} | ${formatExpression(n.filter)}`;\n      }\n      return `${operand} | ${n.filter.value}`;\n    }\n    case \"SelectExpression\": {\n      const n = node;\n      return `${formatExpression(n.lhs)} if ${formatExpression(n.test)}`;\n    }\n    case \"TestExpression\": {\n      const n = node;\n      return `${formatExpression(n.operand)} is${n.negate ? \" not\" : \"\"} ${n.test.value}`;\n    }\n    case \"ArrayLiteral\":\n    case \"TupleLiteral\": {\n      const elems = node.value.map(formatExpression);\n      const brackets = node.type === \"ArrayLiteral\" ? \"[]\" : \"()\";\n      return `${brackets[0]}${elems.join(\", \")}${brackets[1]}`;\n    }\n    case \"ObjectLiteral\": {\n      const entries = Array.from(node.value.entries()).map(\n        ([k, v]) => `${formatExpression(k)}: ${formatExpression(v)}`\n      );\n      return `{${entries.join(\", \")}}`;\n    }\n    case \"SliceExpression\": {\n      const n = node;\n      const s = n.start ? formatExpression(n.start) : \"\";\n      const t = n.stop ? formatExpression(n.stop) : \"\";\n      const st = n.step ? `:${formatExpression(n.step)}` : \"\";\n      return `${s}:${t}${st}`;\n    }\n    case \"KeywordArgumentExpression\": {\n      const n = node;\n      return `${n.key.value}=${formatExpression(n.value)}`;\n    }\n    case \"Ternary\": {\n      const n = node;\n      const expr = `${formatExpression(n.trueExpr)} if ${formatExpression(n.condition, 0)} else ${formatExpression(\n        n.falseExpr\n      )}`;\n      return parentPrec > -1 ? `(${expr})` : expr;\n    }\n    default:\n      throw new Error(`Unknown expression type: ${node.type}`);\n  }\n}\n\n// src/index.ts\nvar Template = class {\n  parsed;\n  /**\n   * @param {string} template The template string\n   */\n  constructor(template) {\n    const tokens = tokenize(template, {\n      lstrip_blocks: true,\n      trim_blocks: true\n    });\n    this.parsed = parse(tokens);\n  }\n  render(items) {\n    const env = new Environment();\n    setupGlobals(env);\n    if (items) {\n      for (const [key, value] of Object.entries(items)) {\n        env.set(key, value);\n      }\n    }\n    const interpreter = new Interpreter(env);\n    const result = interpreter.run(this.parsed);\n    return result.value;\n  }\n  format(options) {\n    return format(this.parsed, options?.indent || \"\t\");\n  }\n};\nexport {\n  Environment,\n  Interpreter,\n  Template,\n  parse,\n  tokenize\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}