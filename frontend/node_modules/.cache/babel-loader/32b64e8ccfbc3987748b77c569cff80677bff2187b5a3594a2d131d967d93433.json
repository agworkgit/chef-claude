{"ast":null,"code":"/**\n * See the registered mapping of HF model ID => Fal model ID here:\n *\n * https://huggingface.co/api/partners/fal-ai/models\n *\n * This is a publicly available mapping.\n *\n * If you want to try to run inference for a new model locally before it's registered on huggingface.co,\n * you can add it to the dictionary \"HARDCODED_MODEL_ID_MAPPING\" in consts.ts, for dev purposes.\n *\n * - If you work at Fal and want to update this mapping, please use the model mapping API we provide on huggingface.co\n * - If you're a community member and want to add a new supported HF model to Fal, please open an issue on the present repo\n * and we will tag Fal team members.\n *\n * Thanks!\n */\nimport { base64FromBytes } from \"../utils/base64FromBytes.js\";\nimport { isUrl } from \"../lib/isUrl.js\";\nimport { delay } from \"../utils/delay.js\";\nimport { omit } from \"../utils/omit.js\";\nimport { TaskProviderHelper } from \"./providerHelper.js\";\nimport { HF_HUB_URL } from \"../config.js\";\nimport { InferenceClientInputError, InferenceClientProviderApiError, InferenceClientProviderOutputError } from \"../errors.js\";\nexport const FAL_AI_SUPPORTED_BLOB_TYPES = [\"audio/mpeg\", \"audio/mp4\", \"audio/wav\", \"audio/x-wav\"];\nclass FalAITask extends TaskProviderHelper {\n  constructor(url) {\n    super(\"fal-ai\", url || \"https://fal.run\");\n  }\n  preparePayload(params) {\n    return params.args;\n  }\n  makeRoute(params) {\n    return `/${params.model}`;\n  }\n  prepareHeaders(params, binary) {\n    const headers = {\n      Authorization: params.authMethod !== \"provider-key\" ? `Bearer ${params.accessToken}` : `Key ${params.accessToken}`\n    };\n    if (!binary) {\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n    return headers;\n  }\n}\nclass FalAiQueueTask extends FalAITask {\n  async getResponseFromQueueApi(response, url, headers) {\n    if (!url || !headers) {\n      throw new InferenceClientInputError(`URL and headers are required for ${this.task} task`);\n    }\n    const requestId = response.request_id;\n    if (!requestId) {\n      throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai ${this.task} API: no request ID found in the response`);\n    }\n    let status = response.status;\n    const parsedUrl = new URL(url);\n    const baseUrl = `${parsedUrl.protocol}//${parsedUrl.host}${parsedUrl.host === \"router.huggingface.co\" ? \"/fal-ai\" : \"\"}`;\n    // extracting the provider model id for status and result urls\n    // from the response as it might be different from the mapped model in `url`\n    const modelId = new URL(response.response_url).pathname;\n    const queryParams = parsedUrl.search;\n    const statusUrl = `${baseUrl}${modelId}/status${queryParams}`;\n    const resultUrl = `${baseUrl}${modelId}${queryParams}`;\n    while (status !== \"COMPLETED\") {\n      await delay(500);\n      const statusResponse = await fetch(statusUrl, {\n        headers\n      });\n      if (!statusResponse.ok) {\n        throw new InferenceClientProviderApiError(\"Failed to fetch response status from fal-ai API\", {\n          url: statusUrl,\n          method: \"GET\"\n        }, {\n          requestId: statusResponse.headers.get(\"x-request-id\") ?? \"\",\n          status: statusResponse.status,\n          body: await statusResponse.text()\n        });\n      }\n      try {\n        status = (await statusResponse.json()).status;\n      } catch (error) {\n        throw new InferenceClientProviderOutputError(\"Failed to parse status response from fal-ai API: received malformed response\");\n      }\n    }\n    const resultResponse = await fetch(resultUrl, {\n      headers\n    });\n    let result;\n    try {\n      result = await resultResponse.json();\n    } catch (error) {\n      throw new InferenceClientProviderOutputError(\"Failed to parse result response from fal-ai API: received malformed response\");\n    }\n    return result;\n  }\n}\nfunction buildLoraPath(modelId, adapterWeightsPath) {\n  return `${HF_HUB_URL}/${modelId}/resolve/main/${adapterWeightsPath}`;\n}\nexport class FalAITextToImageTask extends FalAITask {\n  preparePayload(params) {\n    const payload = {\n      ...omit(params.args, [\"inputs\", \"parameters\"]),\n      ...params.args.parameters,\n      sync_mode: true,\n      prompt: params.args.inputs\n    };\n    if (params.mapping?.adapter === \"lora\" && params.mapping.adapterWeightsPath) {\n      payload.loras = [{\n        path: buildLoraPath(params.mapping.hfModelId, params.mapping.adapterWeightsPath),\n        scale: 1\n      }];\n      if (params.mapping.providerId === \"fal-ai/lora\") {\n        payload.model_name = \"stabilityai/stable-diffusion-xl-base-1.0\";\n      }\n    }\n    return payload;\n  }\n  async getResponse(response, url, headers, outputType) {\n    if (typeof response === \"object\" && \"images\" in response && Array.isArray(response.images) && response.images.length > 0 && \"url\" in response.images[0] && typeof response.images[0].url === \"string\") {\n      if (outputType === \"json\") {\n        return {\n          ...response\n        };\n      }\n      if (outputType === \"url\") {\n        return response.images[0].url;\n      }\n      const urlResponse = await fetch(response.images[0].url);\n      return await urlResponse.blob();\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from Fal.ai text-to-image API\");\n  }\n}\nexport class FalAIImageToImageTask extends FalAiQueueTask {\n  task;\n  constructor() {\n    super(\"https://queue.fal.run\");\n    this.task = \"image-to-image\";\n  }\n  makeRoute(params) {\n    if (params.authMethod !== \"provider-key\") {\n      return `/${params.model}?_subdomain=queue`;\n    }\n    return `/${params.model}`;\n  }\n  preparePayload(params) {\n    const payload = params.args;\n    if (params.mapping?.adapter === \"lora\" && params.mapping.adapterWeightsPath) {\n      payload.loras = [{\n        path: buildLoraPath(params.mapping.hfModelId, params.mapping.adapterWeightsPath),\n        scale: 1\n      }];\n    }\n    return payload;\n  }\n  async preparePayloadAsync(args) {\n    const mimeType = args.inputs instanceof Blob ? args.inputs.type : \"image/png\";\n    return {\n      ...omit(args, [\"inputs\", \"parameters\"]),\n      image_url: `data:${mimeType};base64,${base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))}`,\n      ...args.parameters,\n      ...args\n    };\n  }\n  async getResponse(response, url, headers) {\n    const result = await this.getResponseFromQueueApi(response, url, headers);\n    if (typeof result === \"object\" && !!result && \"images\" in result && Array.isArray(result.images) && result.images.length > 0 && typeof result.images[0] === \"object\" && !!result.images[0] && \"url\" in result.images[0] && typeof result.images[0].url === \"string\" && isUrl(result.images[0].url)) {\n      const urlResponse = await fetch(result.images[0].url);\n      return await urlResponse.blob();\n    } else {\n      throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai image-to-image API: expected { images: Array<{ url: string }> } result format, got instead: ${JSON.stringify(result)}`);\n    }\n  }\n}\nexport class FalAITextToVideoTask extends FalAiQueueTask {\n  task;\n  constructor() {\n    super(\"https://queue.fal.run\");\n    this.task = \"text-to-video\";\n  }\n  makeRoute(params) {\n    if (params.authMethod !== \"provider-key\") {\n      return `/${params.model}?_subdomain=queue`;\n    }\n    return `/${params.model}`;\n  }\n  preparePayload(params) {\n    return {\n      ...omit(params.args, [\"inputs\", \"parameters\"]),\n      ...params.args.parameters,\n      prompt: params.args.inputs\n    };\n  }\n  async getResponse(response, url, headers) {\n    const result = await this.getResponseFromQueueApi(response, url, headers);\n    if (typeof result === \"object\" && !!result && \"video\" in result && typeof result.video === \"object\" && !!result.video && \"url\" in result.video && typeof result.video.url === \"string\" && isUrl(result.video.url)) {\n      const urlResponse = await fetch(result.video.url);\n      return await urlResponse.blob();\n    } else {\n      throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai text-to-video API: expected { video: { url: string } } result format, got instead: ${JSON.stringify(result)}`);\n    }\n  }\n}\nexport class FalAIImageToVideoTask extends FalAiQueueTask {\n  task;\n  constructor() {\n    super(\"https://queue.fal.run\");\n    this.task = \"image-to-video\";\n  }\n  /** Same queue routing rule as the other Fal queue tasks */\n  makeRoute(params) {\n    return params.authMethod !== \"provider-key\" ? `/${params.model}?_subdomain=queue` : `/${params.model}`;\n  }\n  /** Synchronous case – caller already gave us base64 or a URL */\n  preparePayload(params) {\n    return {\n      ...omit(params.args, [\"inputs\", \"parameters\"]),\n      ...params.args.parameters,\n      // args.inputs is expected to be a base64 data URI or an URL\n      image_url: params.args.image_url\n    };\n  }\n  /** Asynchronous helper – caller gave us a Blob */\n  async preparePayloadAsync(args) {\n    const mimeType = args.inputs instanceof Blob ? args.inputs.type : \"image/png\";\n    return {\n      ...omit(args, [\"inputs\", \"parameters\"]),\n      image_url: `data:${mimeType};base64,${base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))}`,\n      ...args.parameters,\n      ...args\n    };\n  }\n  /** Queue polling + final download – mirrors Text‑to‑Video */\n  async getResponse(response, url, headers) {\n    const result = await this.getResponseFromQueueApi(response, url, headers);\n    if (typeof result === \"object\" && result !== null && \"video\" in result && typeof result.video === \"object\" && result.video !== null && \"url\" in result.video && typeof result.video.url === \"string\" && \"url\" in result.video && isUrl(result.video.url)) {\n      const urlResponse = await fetch(result.video.url);\n      return await urlResponse.blob();\n    }\n    throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai image‑to‑video API: expected { video: { url: string } }, got: ${JSON.stringify(result)}`);\n  }\n}\nexport class FalAIAutomaticSpeechRecognitionTask extends FalAITask {\n  prepareHeaders(params, binary) {\n    const headers = super.prepareHeaders(params, binary);\n    headers[\"Content-Type\"] = \"application/json\";\n    return headers;\n  }\n  async getResponse(response) {\n    const res = response;\n    if (typeof res?.text !== \"string\") {\n      throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai Automatic Speech Recognition API: expected { text: string } format, got instead: ${JSON.stringify(response)}`);\n    }\n    return {\n      text: res.text\n    };\n  }\n  async preparePayloadAsync(args) {\n    const blob = \"data\" in args && args.data instanceof Blob ? args.data : \"inputs\" in args ? args.inputs : undefined;\n    const contentType = blob?.type;\n    if (!contentType) {\n      throw new InferenceClientInputError(`Unable to determine the input's content-type. Make sure your are passing a Blob when using provider fal-ai.`);\n    }\n    if (!FAL_AI_SUPPORTED_BLOB_TYPES.includes(contentType)) {\n      throw new InferenceClientInputError(`Provider fal-ai does not support blob type ${contentType} - supported content types are: ${FAL_AI_SUPPORTED_BLOB_TYPES.join(\", \")}`);\n    }\n    const base64audio = base64FromBytes(new Uint8Array(await blob.arrayBuffer()));\n    return {\n      ...(\"data\" in args ? omit(args, \"data\") : omit(args, \"inputs\")),\n      audio_url: `data:${contentType};base64,${base64audio}`\n    };\n  }\n}\nexport class FalAITextToSpeechTask extends FalAITask {\n  preparePayload(params) {\n    return {\n      ...omit(params.args, [\"inputs\", \"parameters\"]),\n      ...params.args.parameters,\n      text: params.args.inputs\n    };\n  }\n  async getResponse(response) {\n    const res = response;\n    if (typeof res?.audio?.url !== \"string\") {\n      throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai Text-to-Speech API: expected { audio: { url: string } } format, got instead: ${JSON.stringify(response)}`);\n    }\n    const urlResponse = await fetch(res.audio.url);\n    if (!urlResponse.ok) {\n      throw new InferenceClientProviderApiError(`Failed to fetch audio from ${res.audio.url}: ${urlResponse.statusText}`, {\n        url: res.audio.url,\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }, {\n        requestId: urlResponse.headers.get(\"x-request-id\") ?? \"\",\n        status: urlResponse.status,\n        body: await urlResponse.text()\n      });\n    }\n    try {\n      return await urlResponse.blob();\n    } catch (error) {\n      throw new InferenceClientProviderApiError(`Failed to fetch audio from ${res.audio.url}: ${error instanceof Error ? error.message : String(error)}`, {\n        url: res.audio.url,\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      }, {\n        requestId: urlResponse.headers.get(\"x-request-id\") ?? \"\",\n        status: urlResponse.status,\n        body: await urlResponse.text()\n      });\n    }\n  }\n}\nexport class FalAIImageSegmentationTask extends FalAiQueueTask {\n  task;\n  constructor() {\n    super(\"https://queue.fal.run\");\n    this.task = \"image-segmentation\";\n  }\n  makeRoute(params) {\n    if (params.authMethod !== \"provider-key\") {\n      return `/${params.model}?_subdomain=queue`;\n    }\n    return `/${params.model}`;\n  }\n  preparePayload(params) {\n    return {\n      ...omit(params.args, [\"inputs\", \"parameters\"]),\n      ...params.args.parameters,\n      sync_mode: true\n    };\n  }\n  async preparePayloadAsync(args) {\n    const blob = \"data\" in args && args.data instanceof Blob ? args.data : \"inputs\" in args ? args.inputs : undefined;\n    const mimeType = blob instanceof Blob ? blob.type : \"image/png\";\n    const base64Image = base64FromBytes(new Uint8Array(blob instanceof ArrayBuffer ? blob : await blob.arrayBuffer()));\n    return {\n      ...omit(args, [\"inputs\", \"parameters\", \"data\"]),\n      ...args.parameters,\n      ...args,\n      image_url: `data:${mimeType};base64,${base64Image}`,\n      sync_mode: true\n    };\n  }\n  async getResponse(response, url, headers) {\n    const result = await this.getResponseFromQueueApi(response, url, headers);\n    if (typeof result === \"object\" && result !== null && \"image\" in result && typeof result.image === \"object\" && result.image !== null && \"url\" in result.image && typeof result.image.url === \"string\") {\n      const maskResponse = await fetch(result.image.url);\n      if (!maskResponse.ok) {\n        throw new InferenceClientProviderApiError(`Failed to fetch segmentation mask from ${result.image.url}`, {\n          url: result.image.url,\n          method: \"GET\"\n        }, {\n          requestId: maskResponse.headers.get(\"x-request-id\") ?? \"\",\n          status: maskResponse.status,\n          body: await maskResponse.text()\n        });\n      }\n      const maskBlob = await maskResponse.blob();\n      const maskArrayBuffer = await maskBlob.arrayBuffer();\n      const maskBase64 = base64FromBytes(new Uint8Array(maskArrayBuffer));\n      return [{\n        label: \"mask\",\n        // placeholder label, as Fal does not provide labels in the response(?)\n        score: 1.0,\n        // placeholder score, as Fal does not provide scores in the response(?)\n        mask: maskBase64\n      }];\n    }\n    throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai image-segmentation API: expected { image: { url: string } } format, got instead: ${JSON.stringify(response)}`);\n  }\n}","map":{"version":3,"names":["base64FromBytes","isUrl","delay","omit","TaskProviderHelper","HF_HUB_URL","InferenceClientInputError","InferenceClientProviderApiError","InferenceClientProviderOutputError","FAL_AI_SUPPORTED_BLOB_TYPES","FalAITask","constructor","url","preparePayload","params","args","makeRoute","model","prepareHeaders","binary","headers","Authorization","authMethod","accessToken","FalAiQueueTask","getResponseFromQueueApi","response","task","requestId","request_id","status","parsedUrl","URL","baseUrl","protocol","host","modelId","response_url","pathname","queryParams","search","statusUrl","resultUrl","statusResponse","fetch","ok","method","get","body","text","json","error","resultResponse","result","buildLoraPath","adapterWeightsPath","FalAITextToImageTask","payload","parameters","sync_mode","prompt","inputs","mapping","adapter","loras","path","hfModelId","scale","providerId","model_name","getResponse","outputType","Array","isArray","images","length","urlResponse","blob","FalAIImageToImageTask","preparePayloadAsync","mimeType","Blob","type","image_url","Uint8Array","ArrayBuffer","arrayBuffer","JSON","stringify","FalAITextToVideoTask","video","FalAIImageToVideoTask","FalAIAutomaticSpeechRecognitionTask","res","data","undefined","contentType","includes","join","base64audio","audio_url","FalAITextToSpeechTask","audio","statusText","Error","message","String","FalAIImageSegmentationTask","base64Image","image","maskResponse","maskBlob","maskArrayBuffer","maskBase64","label","score","mask"],"sources":["/Users/agmacbook/Documents/Courses/Meta - Full Stack/Exercises/meta_fullstack_exercises/6_react_basics/12_review/13_chef_claude/node_modules/@huggingface/inference/dist/esm/providers/fal-ai.js"],"sourcesContent":["/**\n * See the registered mapping of HF model ID => Fal model ID here:\n *\n * https://huggingface.co/api/partners/fal-ai/models\n *\n * This is a publicly available mapping.\n *\n * If you want to try to run inference for a new model locally before it's registered on huggingface.co,\n * you can add it to the dictionary \"HARDCODED_MODEL_ID_MAPPING\" in consts.ts, for dev purposes.\n *\n * - If you work at Fal and want to update this mapping, please use the model mapping API we provide on huggingface.co\n * - If you're a community member and want to add a new supported HF model to Fal, please open an issue on the present repo\n * and we will tag Fal team members.\n *\n * Thanks!\n */\nimport { base64FromBytes } from \"../utils/base64FromBytes.js\";\nimport { isUrl } from \"../lib/isUrl.js\";\nimport { delay } from \"../utils/delay.js\";\nimport { omit } from \"../utils/omit.js\";\nimport { TaskProviderHelper, } from \"./providerHelper.js\";\nimport { HF_HUB_URL } from \"../config.js\";\nimport { InferenceClientInputError, InferenceClientProviderApiError, InferenceClientProviderOutputError, } from \"../errors.js\";\nexport const FAL_AI_SUPPORTED_BLOB_TYPES = [\"audio/mpeg\", \"audio/mp4\", \"audio/wav\", \"audio/x-wav\"];\nclass FalAITask extends TaskProviderHelper {\n    constructor(url) {\n        super(\"fal-ai\", url || \"https://fal.run\");\n    }\n    preparePayload(params) {\n        return params.args;\n    }\n    makeRoute(params) {\n        return `/${params.model}`;\n    }\n    prepareHeaders(params, binary) {\n        const headers = {\n            Authorization: params.authMethod !== \"provider-key\" ? `Bearer ${params.accessToken}` : `Key ${params.accessToken}`,\n        };\n        if (!binary) {\n            headers[\"Content-Type\"] = \"application/json\";\n        }\n        return headers;\n    }\n}\nclass FalAiQueueTask extends FalAITask {\n    async getResponseFromQueueApi(response, url, headers) {\n        if (!url || !headers) {\n            throw new InferenceClientInputError(`URL and headers are required for ${this.task} task`);\n        }\n        const requestId = response.request_id;\n        if (!requestId) {\n            throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai ${this.task} API: no request ID found in the response`);\n        }\n        let status = response.status;\n        const parsedUrl = new URL(url);\n        const baseUrl = `${parsedUrl.protocol}//${parsedUrl.host}${parsedUrl.host === \"router.huggingface.co\" ? \"/fal-ai\" : \"\"}`;\n        // extracting the provider model id for status and result urls\n        // from the response as it might be different from the mapped model in `url`\n        const modelId = new URL(response.response_url).pathname;\n        const queryParams = parsedUrl.search;\n        const statusUrl = `${baseUrl}${modelId}/status${queryParams}`;\n        const resultUrl = `${baseUrl}${modelId}${queryParams}`;\n        while (status !== \"COMPLETED\") {\n            await delay(500);\n            const statusResponse = await fetch(statusUrl, { headers });\n            if (!statusResponse.ok) {\n                throw new InferenceClientProviderApiError(\"Failed to fetch response status from fal-ai API\", { url: statusUrl, method: \"GET\" }, {\n                    requestId: statusResponse.headers.get(\"x-request-id\") ?? \"\",\n                    status: statusResponse.status,\n                    body: await statusResponse.text(),\n                });\n            }\n            try {\n                status = (await statusResponse.json()).status;\n            }\n            catch (error) {\n                throw new InferenceClientProviderOutputError(\"Failed to parse status response from fal-ai API: received malformed response\");\n            }\n        }\n        const resultResponse = await fetch(resultUrl, { headers });\n        let result;\n        try {\n            result = await resultResponse.json();\n        }\n        catch (error) {\n            throw new InferenceClientProviderOutputError(\"Failed to parse result response from fal-ai API: received malformed response\");\n        }\n        return result;\n    }\n}\nfunction buildLoraPath(modelId, adapterWeightsPath) {\n    return `${HF_HUB_URL}/${modelId}/resolve/main/${adapterWeightsPath}`;\n}\nexport class FalAITextToImageTask extends FalAITask {\n    preparePayload(params) {\n        const payload = {\n            ...omit(params.args, [\"inputs\", \"parameters\"]),\n            ...params.args.parameters,\n            sync_mode: true,\n            prompt: params.args.inputs,\n        };\n        if (params.mapping?.adapter === \"lora\" && params.mapping.adapterWeightsPath) {\n            payload.loras = [\n                {\n                    path: buildLoraPath(params.mapping.hfModelId, params.mapping.adapterWeightsPath),\n                    scale: 1,\n                },\n            ];\n            if (params.mapping.providerId === \"fal-ai/lora\") {\n                payload.model_name = \"stabilityai/stable-diffusion-xl-base-1.0\";\n            }\n        }\n        return payload;\n    }\n    async getResponse(response, url, headers, outputType) {\n        if (typeof response === \"object\" &&\n            \"images\" in response &&\n            Array.isArray(response.images) &&\n            response.images.length > 0 &&\n            \"url\" in response.images[0] &&\n            typeof response.images[0].url === \"string\") {\n            if (outputType === \"json\") {\n                return { ...response };\n            }\n            if (outputType === \"url\") {\n                return response.images[0].url;\n            }\n            const urlResponse = await fetch(response.images[0].url);\n            return await urlResponse.blob();\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from Fal.ai text-to-image API\");\n    }\n}\nexport class FalAIImageToImageTask extends FalAiQueueTask {\n    task;\n    constructor() {\n        super(\"https://queue.fal.run\");\n        this.task = \"image-to-image\";\n    }\n    makeRoute(params) {\n        if (params.authMethod !== \"provider-key\") {\n            return `/${params.model}?_subdomain=queue`;\n        }\n        return `/${params.model}`;\n    }\n    preparePayload(params) {\n        const payload = params.args;\n        if (params.mapping?.adapter === \"lora\" && params.mapping.adapterWeightsPath) {\n            payload.loras = [\n                {\n                    path: buildLoraPath(params.mapping.hfModelId, params.mapping.adapterWeightsPath),\n                    scale: 1,\n                },\n            ];\n        }\n        return payload;\n    }\n    async preparePayloadAsync(args) {\n        const mimeType = args.inputs instanceof Blob ? args.inputs.type : \"image/png\";\n        return {\n            ...omit(args, [\"inputs\", \"parameters\"]),\n            image_url: `data:${mimeType};base64,${base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))}`,\n            ...args.parameters,\n            ...args,\n        };\n    }\n    async getResponse(response, url, headers) {\n        const result = await this.getResponseFromQueueApi(response, url, headers);\n        if (typeof result === \"object\" &&\n            !!result &&\n            \"images\" in result &&\n            Array.isArray(result.images) &&\n            result.images.length > 0 &&\n            typeof result.images[0] === \"object\" &&\n            !!result.images[0] &&\n            \"url\" in result.images[0] &&\n            typeof result.images[0].url === \"string\" &&\n            isUrl(result.images[0].url)) {\n            const urlResponse = await fetch(result.images[0].url);\n            return await urlResponse.blob();\n        }\n        else {\n            throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai image-to-image API: expected { images: Array<{ url: string }> } result format, got instead: ${JSON.stringify(result)}`);\n        }\n    }\n}\nexport class FalAITextToVideoTask extends FalAiQueueTask {\n    task;\n    constructor() {\n        super(\"https://queue.fal.run\");\n        this.task = \"text-to-video\";\n    }\n    makeRoute(params) {\n        if (params.authMethod !== \"provider-key\") {\n            return `/${params.model}?_subdomain=queue`;\n        }\n        return `/${params.model}`;\n    }\n    preparePayload(params) {\n        return {\n            ...omit(params.args, [\"inputs\", \"parameters\"]),\n            ...params.args.parameters,\n            prompt: params.args.inputs,\n        };\n    }\n    async getResponse(response, url, headers) {\n        const result = await this.getResponseFromQueueApi(response, url, headers);\n        if (typeof result === \"object\" &&\n            !!result &&\n            \"video\" in result &&\n            typeof result.video === \"object\" &&\n            !!result.video &&\n            \"url\" in result.video &&\n            typeof result.video.url === \"string\" &&\n            isUrl(result.video.url)) {\n            const urlResponse = await fetch(result.video.url);\n            return await urlResponse.blob();\n        }\n        else {\n            throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai text-to-video API: expected { video: { url: string } } result format, got instead: ${JSON.stringify(result)}`);\n        }\n    }\n}\nexport class FalAIImageToVideoTask extends FalAiQueueTask {\n    task;\n    constructor() {\n        super(\"https://queue.fal.run\");\n        this.task = \"image-to-video\";\n    }\n    /** Same queue routing rule as the other Fal queue tasks */\n    makeRoute(params) {\n        return params.authMethod !== \"provider-key\" ? `/${params.model}?_subdomain=queue` : `/${params.model}`;\n    }\n    /** Synchronous case – caller already gave us base64 or a URL */\n    preparePayload(params) {\n        return {\n            ...omit(params.args, [\"inputs\", \"parameters\"]),\n            ...params.args.parameters,\n            // args.inputs is expected to be a base64 data URI or an URL\n            image_url: params.args.image_url,\n        };\n    }\n    /** Asynchronous helper – caller gave us a Blob */\n    async preparePayloadAsync(args) {\n        const mimeType = args.inputs instanceof Blob ? args.inputs.type : \"image/png\";\n        return {\n            ...omit(args, [\"inputs\", \"parameters\"]),\n            image_url: `data:${mimeType};base64,${base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))}`,\n            ...args.parameters,\n            ...args,\n        };\n    }\n    /** Queue polling + final download – mirrors Text‑to‑Video */\n    async getResponse(response, url, headers) {\n        const result = await this.getResponseFromQueueApi(response, url, headers);\n        if (typeof result === \"object\" &&\n            result !== null &&\n            \"video\" in result &&\n            typeof result.video === \"object\" &&\n            result.video !== null &&\n            \"url\" in result.video &&\n            typeof result.video.url === \"string\" &&\n            \"url\" in result.video &&\n            isUrl(result.video.url)) {\n            const urlResponse = await fetch(result.video.url);\n            return await urlResponse.blob();\n        }\n        throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai image‑to‑video API: expected { video: { url: string } }, got: ${JSON.stringify(result)}`);\n    }\n}\nexport class FalAIAutomaticSpeechRecognitionTask extends FalAITask {\n    prepareHeaders(params, binary) {\n        const headers = super.prepareHeaders(params, binary);\n        headers[\"Content-Type\"] = \"application/json\";\n        return headers;\n    }\n    async getResponse(response) {\n        const res = response;\n        if (typeof res?.text !== \"string\") {\n            throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai Automatic Speech Recognition API: expected { text: string } format, got instead: ${JSON.stringify(response)}`);\n        }\n        return { text: res.text };\n    }\n    async preparePayloadAsync(args) {\n        const blob = \"data\" in args && args.data instanceof Blob ? args.data : \"inputs\" in args ? args.inputs : undefined;\n        const contentType = blob?.type;\n        if (!contentType) {\n            throw new InferenceClientInputError(`Unable to determine the input's content-type. Make sure your are passing a Blob when using provider fal-ai.`);\n        }\n        if (!FAL_AI_SUPPORTED_BLOB_TYPES.includes(contentType)) {\n            throw new InferenceClientInputError(`Provider fal-ai does not support blob type ${contentType} - supported content types are: ${FAL_AI_SUPPORTED_BLOB_TYPES.join(\", \")}`);\n        }\n        const base64audio = base64FromBytes(new Uint8Array(await blob.arrayBuffer()));\n        return {\n            ...(\"data\" in args ? omit(args, \"data\") : omit(args, \"inputs\")),\n            audio_url: `data:${contentType};base64,${base64audio}`,\n        };\n    }\n}\nexport class FalAITextToSpeechTask extends FalAITask {\n    preparePayload(params) {\n        return {\n            ...omit(params.args, [\"inputs\", \"parameters\"]),\n            ...params.args.parameters,\n            text: params.args.inputs,\n        };\n    }\n    async getResponse(response) {\n        const res = response;\n        if (typeof res?.audio?.url !== \"string\") {\n            throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai Text-to-Speech API: expected { audio: { url: string } } format, got instead: ${JSON.stringify(response)}`);\n        }\n        const urlResponse = await fetch(res.audio.url);\n        if (!urlResponse.ok) {\n            throw new InferenceClientProviderApiError(`Failed to fetch audio from ${res.audio.url}: ${urlResponse.statusText}`, { url: res.audio.url, method: \"GET\", headers: { \"Content-Type\": \"application/json\" } }, {\n                requestId: urlResponse.headers.get(\"x-request-id\") ?? \"\",\n                status: urlResponse.status,\n                body: await urlResponse.text(),\n            });\n        }\n        try {\n            return await urlResponse.blob();\n        }\n        catch (error) {\n            throw new InferenceClientProviderApiError(`Failed to fetch audio from ${res.audio.url}: ${error instanceof Error ? error.message : String(error)}`, { url: res.audio.url, method: \"GET\", headers: { \"Content-Type\": \"application/json\" } }, {\n                requestId: urlResponse.headers.get(\"x-request-id\") ?? \"\",\n                status: urlResponse.status,\n                body: await urlResponse.text(),\n            });\n        }\n    }\n}\nexport class FalAIImageSegmentationTask extends FalAiQueueTask {\n    task;\n    constructor() {\n        super(\"https://queue.fal.run\");\n        this.task = \"image-segmentation\";\n    }\n    makeRoute(params) {\n        if (params.authMethod !== \"provider-key\") {\n            return `/${params.model}?_subdomain=queue`;\n        }\n        return `/${params.model}`;\n    }\n    preparePayload(params) {\n        return {\n            ...omit(params.args, [\"inputs\", \"parameters\"]),\n            ...params.args.parameters,\n            sync_mode: true,\n        };\n    }\n    async preparePayloadAsync(args) {\n        const blob = \"data\" in args && args.data instanceof Blob ? args.data : \"inputs\" in args ? args.inputs : undefined;\n        const mimeType = blob instanceof Blob ? blob.type : \"image/png\";\n        const base64Image = base64FromBytes(new Uint8Array(blob instanceof ArrayBuffer ? blob : await blob.arrayBuffer()));\n        return {\n            ...omit(args, [\"inputs\", \"parameters\", \"data\"]),\n            ...args.parameters,\n            ...args,\n            image_url: `data:${mimeType};base64,${base64Image}`,\n            sync_mode: true,\n        };\n    }\n    async getResponse(response, url, headers) {\n        const result = await this.getResponseFromQueueApi(response, url, headers);\n        if (typeof result === \"object\" &&\n            result !== null &&\n            \"image\" in result &&\n            typeof result.image === \"object\" &&\n            result.image !== null &&\n            \"url\" in result.image &&\n            typeof result.image.url === \"string\") {\n            const maskResponse = await fetch(result.image.url);\n            if (!maskResponse.ok) {\n                throw new InferenceClientProviderApiError(`Failed to fetch segmentation mask from ${result.image.url}`, { url: result.image.url, method: \"GET\" }, {\n                    requestId: maskResponse.headers.get(\"x-request-id\") ?? \"\",\n                    status: maskResponse.status,\n                    body: await maskResponse.text(),\n                });\n            }\n            const maskBlob = await maskResponse.blob();\n            const maskArrayBuffer = await maskBlob.arrayBuffer();\n            const maskBase64 = base64FromBytes(new Uint8Array(maskArrayBuffer));\n            return [\n                {\n                    label: \"mask\", // placeholder label, as Fal does not provide labels in the response(?)\n                    score: 1.0, // placeholder score, as Fal does not provide scores in the response(?)\n                    mask: maskBase64,\n                },\n            ];\n        }\n        throw new InferenceClientProviderOutputError(`Received malformed response from Fal.ai image-segmentation API: expected { image: { url: string } } format, got instead: ${JSON.stringify(response)}`);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}