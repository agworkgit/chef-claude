{"ast":null,"code":"/**\n * See the registered mapping of HF model ID => Replicate model ID here:\n *\n * https://huggingface.co/api/partners/replicate/models\n *\n * This is a publicly available mapping.\n *\n * If you want to try to run inference for a new model locally before it's registered on huggingface.co,\n * you can add it to the dictionary \"HARDCODED_MODEL_ID_MAPPING\" in consts.ts, for dev purposes.\n *\n * - If you work at Replicate and want to update this mapping, please use the model mapping API we provide on huggingface.co\n * - If you're a community member and want to add a new supported HF model to Replicate, please open an issue on the present repo\n * and we will tag Replicate team members.\n *\n * Thanks!\n */\nimport { InferenceClientProviderOutputError } from \"../errors.js\";\nimport { isUrl } from \"../lib/isUrl.js\";\nimport { omit } from \"../utils/omit.js\";\nimport { TaskProviderHelper } from \"./providerHelper.js\";\nimport { base64FromBytes } from \"../utils/base64FromBytes.js\";\nclass ReplicateTask extends TaskProviderHelper {\n  constructor(url) {\n    super(\"replicate\", url || \"https://api.replicate.com\");\n  }\n  makeRoute(params) {\n    if (params.model.includes(\":\")) {\n      return \"v1/predictions\";\n    }\n    return `v1/models/${params.model}/predictions`;\n  }\n  preparePayload(params) {\n    return {\n      input: {\n        ...omit(params.args, [\"inputs\", \"parameters\"]),\n        ...params.args.parameters,\n        prompt: params.args.inputs\n      },\n      version: params.model.includes(\":\") ? params.model.split(\":\")[1] : undefined\n    };\n  }\n  prepareHeaders(params, binary) {\n    const headers = {\n      Authorization: `Bearer ${params.accessToken}`,\n      Prefer: \"wait\"\n    };\n    if (!binary) {\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n    return headers;\n  }\n  makeUrl(params) {\n    const baseUrl = this.makeBaseUrl(params);\n    if (params.model.includes(\":\")) {\n      return `${baseUrl}/v1/predictions`;\n    }\n    return `${baseUrl}/v1/models/${params.model}/predictions`;\n  }\n}\nexport class ReplicateTextToImageTask extends ReplicateTask {\n  preparePayload(params) {\n    return {\n      input: {\n        ...omit(params.args, [\"inputs\", \"parameters\"]),\n        ...params.args.parameters,\n        prompt: params.args.inputs,\n        lora_weights: params.mapping?.adapter === \"lora\" && params.mapping.adapterWeightsPath ? `https://huggingface.co/${params.mapping.hfModelId}` : undefined\n      },\n      version: params.model.includes(\":\") ? params.model.split(\":\")[1] : undefined\n    };\n  }\n  async getResponse(res, url, headers, outputType) {\n    void url;\n    void headers;\n    if (typeof res === \"object\" && \"output\" in res && Array.isArray(res.output) && res.output.length > 0 && typeof res.output[0] === \"string\") {\n      if (outputType === \"json\") {\n        return {\n          ...res\n        };\n      }\n      if (outputType === \"url\") {\n        return res.output[0];\n      }\n      const urlResponse = await fetch(res.output[0]);\n      return await urlResponse.blob();\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from Replicate text-to-image API\");\n  }\n}\nexport class ReplicateTextToSpeechTask extends ReplicateTask {\n  preparePayload(params) {\n    const payload = super.preparePayload(params);\n    const input = payload[\"input\"];\n    if (typeof input === \"object\" && input !== null && \"prompt\" in input) {\n      const inputObj = input;\n      inputObj[\"text\"] = inputObj[\"prompt\"];\n      delete inputObj[\"prompt\"];\n    }\n    return payload;\n  }\n  async getResponse(response) {\n    if (response instanceof Blob) {\n      return response;\n    }\n    if (response && typeof response === \"object\") {\n      if (\"output\" in response) {\n        if (typeof response.output === \"string\") {\n          const urlResponse = await fetch(response.output);\n          return await urlResponse.blob();\n        } else if (Array.isArray(response.output)) {\n          const urlResponse = await fetch(response.output[0]);\n          return await urlResponse.blob();\n        }\n      }\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from Replicate text-to-speech API\");\n  }\n}\nexport class ReplicateTextToVideoTask extends ReplicateTask {\n  async getResponse(response) {\n    if (typeof response === \"object\" && !!response && \"output\" in response && typeof response.output === \"string\" && isUrl(response.output)) {\n      const urlResponse = await fetch(response.output);\n      return await urlResponse.blob();\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from Replicate text-to-video API\");\n  }\n}\nexport class ReplicateAutomaticSpeechRecognitionTask extends ReplicateTask {\n  preparePayload(params) {\n    return {\n      input: {\n        ...omit(params.args, [\"inputs\", \"parameters\"]),\n        ...params.args.parameters,\n        audio: params.args.inputs // This will be processed in preparePayloadAsync\n      },\n      version: params.model.includes(\":\") ? params.model.split(\":\")[1] : undefined\n    };\n  }\n  async preparePayloadAsync(args) {\n    const blob = \"data\" in args && args.data instanceof Blob ? args.data : \"inputs\" in args ? args.inputs : undefined;\n    if (!blob || !(blob instanceof Blob)) {\n      throw new Error(\"Audio input must be a Blob\");\n    }\n    // Convert Blob to base64 data URL\n    const bytes = new Uint8Array(await blob.arrayBuffer());\n    const base64 = base64FromBytes(bytes);\n    const audioInput = `data:${blob.type || \"audio/wav\"};base64,${base64}`;\n    return {\n      ...(\"data\" in args ? omit(args, \"data\") : omit(args, \"inputs\")),\n      inputs: audioInput\n    };\n  }\n  async getResponse(response) {\n    if (typeof response?.output === \"string\") return {\n      text: response.output\n    };\n    if (Array.isArray(response?.output) && typeof response.output[0] === \"string\") return {\n      text: response.output[0]\n    };\n    const out = response?.output;\n    if (out && typeof out === \"object\") {\n      if (typeof out.transcription === \"string\") return {\n        text: out.transcription\n      };\n      if (typeof out.translation === \"string\") return {\n        text: out.translation\n      };\n      if (typeof out.txt_file === \"string\") {\n        const r = await fetch(out.txt_file);\n        return {\n          text: await r.text()\n        };\n      }\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from Replicate automatic-speech-recognition API\");\n  }\n}\nexport class ReplicateImageToImageTask extends ReplicateTask {\n  preparePayload(params) {\n    return {\n      input: {\n        ...omit(params.args, [\"inputs\", \"parameters\"]),\n        ...params.args.parameters,\n        input_image: params.args.inputs,\n        // This will be processed in preparePayloadAsync\n        lora_weights: params.mapping?.adapter === \"lora\" && params.mapping.adapterWeightsPath ? `https://huggingface.co/${params.mapping.hfModelId}` : undefined\n      },\n      version: params.model.includes(\":\") ? params.model.split(\":\")[1] : undefined\n    };\n  }\n  async preparePayloadAsync(args) {\n    const {\n      inputs,\n      ...restArgs\n    } = args;\n    // Convert Blob to base64 data URL\n    const bytes = new Uint8Array(await inputs.arrayBuffer());\n    const base64 = base64FromBytes(bytes);\n    const imageInput = `data:${inputs.type || \"image/jpeg\"};base64,${base64}`;\n    return {\n      ...restArgs,\n      inputs: imageInput\n    };\n  }\n  async getResponse(response) {\n    if (typeof response === \"object\" && !!response && \"output\" in response && Array.isArray(response.output) && response.output.length > 0 && typeof response.output[0] === \"string\") {\n      const urlResponse = await fetch(response.output[0]);\n      return await urlResponse.blob();\n    }\n    if (typeof response === \"object\" && !!response && \"output\" in response && typeof response.output === \"string\" && isUrl(response.output)) {\n      const urlResponse = await fetch(response.output);\n      return await urlResponse.blob();\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from Replicate image-to-image API\");\n  }\n}","map":{"version":3,"names":["InferenceClientProviderOutputError","isUrl","omit","TaskProviderHelper","base64FromBytes","ReplicateTask","constructor","url","makeRoute","params","model","includes","preparePayload","input","args","parameters","prompt","inputs","version","split","undefined","prepareHeaders","binary","headers","Authorization","accessToken","Prefer","makeUrl","baseUrl","makeBaseUrl","ReplicateTextToImageTask","lora_weights","mapping","adapter","adapterWeightsPath","hfModelId","getResponse","res","outputType","Array","isArray","output","length","urlResponse","fetch","blob","ReplicateTextToSpeechTask","payload","inputObj","response","Blob","ReplicateTextToVideoTask","ReplicateAutomaticSpeechRecognitionTask","audio","preparePayloadAsync","data","Error","bytes","Uint8Array","arrayBuffer","base64","audioInput","type","text","out","transcription","translation","txt_file","r","ReplicateImageToImageTask","input_image","restArgs","imageInput"],"sources":["/Users/agmacbook/Documents/Courses/Meta - Full Stack/Exercises/meta_fullstack_exercises/6_react_basics/12_review/13_chef_claude/node_modules/@huggingface/inference/dist/esm/providers/replicate.js"],"sourcesContent":["/**\n * See the registered mapping of HF model ID => Replicate model ID here:\n *\n * https://huggingface.co/api/partners/replicate/models\n *\n * This is a publicly available mapping.\n *\n * If you want to try to run inference for a new model locally before it's registered on huggingface.co,\n * you can add it to the dictionary \"HARDCODED_MODEL_ID_MAPPING\" in consts.ts, for dev purposes.\n *\n * - If you work at Replicate and want to update this mapping, please use the model mapping API we provide on huggingface.co\n * - If you're a community member and want to add a new supported HF model to Replicate, please open an issue on the present repo\n * and we will tag Replicate team members.\n *\n * Thanks!\n */\nimport { InferenceClientProviderOutputError } from \"../errors.js\";\nimport { isUrl } from \"../lib/isUrl.js\";\nimport { omit } from \"../utils/omit.js\";\nimport { TaskProviderHelper, } from \"./providerHelper.js\";\nimport { base64FromBytes } from \"../utils/base64FromBytes.js\";\nclass ReplicateTask extends TaskProviderHelper {\n    constructor(url) {\n        super(\"replicate\", url || \"https://api.replicate.com\");\n    }\n    makeRoute(params) {\n        if (params.model.includes(\":\")) {\n            return \"v1/predictions\";\n        }\n        return `v1/models/${params.model}/predictions`;\n    }\n    preparePayload(params) {\n        return {\n            input: {\n                ...omit(params.args, [\"inputs\", \"parameters\"]),\n                ...params.args.parameters,\n                prompt: params.args.inputs,\n            },\n            version: params.model.includes(\":\") ? params.model.split(\":\")[1] : undefined,\n        };\n    }\n    prepareHeaders(params, binary) {\n        const headers = { Authorization: `Bearer ${params.accessToken}`, Prefer: \"wait\" };\n        if (!binary) {\n            headers[\"Content-Type\"] = \"application/json\";\n        }\n        return headers;\n    }\n    makeUrl(params) {\n        const baseUrl = this.makeBaseUrl(params);\n        if (params.model.includes(\":\")) {\n            return `${baseUrl}/v1/predictions`;\n        }\n        return `${baseUrl}/v1/models/${params.model}/predictions`;\n    }\n}\nexport class ReplicateTextToImageTask extends ReplicateTask {\n    preparePayload(params) {\n        return {\n            input: {\n                ...omit(params.args, [\"inputs\", \"parameters\"]),\n                ...params.args.parameters,\n                prompt: params.args.inputs,\n                lora_weights: params.mapping?.adapter === \"lora\" && params.mapping.adapterWeightsPath\n                    ? `https://huggingface.co/${params.mapping.hfModelId}`\n                    : undefined,\n            },\n            version: params.model.includes(\":\") ? params.model.split(\":\")[1] : undefined,\n        };\n    }\n    async getResponse(res, url, headers, outputType) {\n        void url;\n        void headers;\n        if (typeof res === \"object\" &&\n            \"output\" in res &&\n            Array.isArray(res.output) &&\n            res.output.length > 0 &&\n            typeof res.output[0] === \"string\") {\n            if (outputType === \"json\") {\n                return { ...res };\n            }\n            if (outputType === \"url\") {\n                return res.output[0];\n            }\n            const urlResponse = await fetch(res.output[0]);\n            return await urlResponse.blob();\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from Replicate text-to-image API\");\n    }\n}\nexport class ReplicateTextToSpeechTask extends ReplicateTask {\n    preparePayload(params) {\n        const payload = super.preparePayload(params);\n        const input = payload[\"input\"];\n        if (typeof input === \"object\" && input !== null && \"prompt\" in input) {\n            const inputObj = input;\n            inputObj[\"text\"] = inputObj[\"prompt\"];\n            delete inputObj[\"prompt\"];\n        }\n        return payload;\n    }\n    async getResponse(response) {\n        if (response instanceof Blob) {\n            return response;\n        }\n        if (response && typeof response === \"object\") {\n            if (\"output\" in response) {\n                if (typeof response.output === \"string\") {\n                    const urlResponse = await fetch(response.output);\n                    return await urlResponse.blob();\n                }\n                else if (Array.isArray(response.output)) {\n                    const urlResponse = await fetch(response.output[0]);\n                    return await urlResponse.blob();\n                }\n            }\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from Replicate text-to-speech API\");\n    }\n}\nexport class ReplicateTextToVideoTask extends ReplicateTask {\n    async getResponse(response) {\n        if (typeof response === \"object\" &&\n            !!response &&\n            \"output\" in response &&\n            typeof response.output === \"string\" &&\n            isUrl(response.output)) {\n            const urlResponse = await fetch(response.output);\n            return await urlResponse.blob();\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from Replicate text-to-video API\");\n    }\n}\nexport class ReplicateAutomaticSpeechRecognitionTask extends ReplicateTask {\n    preparePayload(params) {\n        return {\n            input: {\n                ...omit(params.args, [\"inputs\", \"parameters\"]),\n                ...params.args.parameters,\n                audio: params.args.inputs, // This will be processed in preparePayloadAsync\n            },\n            version: params.model.includes(\":\") ? params.model.split(\":\")[1] : undefined,\n        };\n    }\n    async preparePayloadAsync(args) {\n        const blob = \"data\" in args && args.data instanceof Blob ? args.data : \"inputs\" in args ? args.inputs : undefined;\n        if (!blob || !(blob instanceof Blob)) {\n            throw new Error(\"Audio input must be a Blob\");\n        }\n        // Convert Blob to base64 data URL\n        const bytes = new Uint8Array(await blob.arrayBuffer());\n        const base64 = base64FromBytes(bytes);\n        const audioInput = `data:${blob.type || \"audio/wav\"};base64,${base64}`;\n        return {\n            ...(\"data\" in args ? omit(args, \"data\") : omit(args, \"inputs\")),\n            inputs: audioInput,\n        };\n    }\n    async getResponse(response) {\n        if (typeof response?.output === \"string\")\n            return { text: response.output };\n        if (Array.isArray(response?.output) && typeof response.output[0] === \"string\")\n            return { text: response.output[0] };\n        const out = response?.output;\n        if (out && typeof out === \"object\") {\n            if (typeof out.transcription === \"string\")\n                return { text: out.transcription };\n            if (typeof out.translation === \"string\")\n                return { text: out.translation };\n            if (typeof out.txt_file === \"string\") {\n                const r = await fetch(out.txt_file);\n                return { text: await r.text() };\n            }\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from Replicate automatic-speech-recognition API\");\n    }\n}\nexport class ReplicateImageToImageTask extends ReplicateTask {\n    preparePayload(params) {\n        return {\n            input: {\n                ...omit(params.args, [\"inputs\", \"parameters\"]),\n                ...params.args.parameters,\n                input_image: params.args.inputs, // This will be processed in preparePayloadAsync\n                lora_weights: params.mapping?.adapter === \"lora\" && params.mapping.adapterWeightsPath\n                    ? `https://huggingface.co/${params.mapping.hfModelId}`\n                    : undefined,\n            },\n            version: params.model.includes(\":\") ? params.model.split(\":\")[1] : undefined,\n        };\n    }\n    async preparePayloadAsync(args) {\n        const { inputs, ...restArgs } = args;\n        // Convert Blob to base64 data URL\n        const bytes = new Uint8Array(await inputs.arrayBuffer());\n        const base64 = base64FromBytes(bytes);\n        const imageInput = `data:${inputs.type || \"image/jpeg\"};base64,${base64}`;\n        return {\n            ...restArgs,\n            inputs: imageInput,\n        };\n    }\n    async getResponse(response) {\n        if (typeof response === \"object\" &&\n            !!response &&\n            \"output\" in response &&\n            Array.isArray(response.output) &&\n            response.output.length > 0 &&\n            typeof response.output[0] === \"string\") {\n            const urlResponse = await fetch(response.output[0]);\n            return await urlResponse.blob();\n        }\n        if (typeof response === \"object\" &&\n            !!response &&\n            \"output\" in response &&\n            typeof response.output === \"string\" &&\n            isUrl(response.output)) {\n            const urlResponse = await fetch(response.output);\n            return await urlResponse.blob();\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from Replicate image-to-image API\");\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}