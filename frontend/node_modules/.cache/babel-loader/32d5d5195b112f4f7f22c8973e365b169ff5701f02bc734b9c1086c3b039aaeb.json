{"ast":null,"code":"import { Template } from \"@huggingface/jinja\";\nimport { getModelInputSnippet, inferenceSnippetLanguages } from \"@huggingface/tasks\";\nimport { getProviderHelper } from \"../lib/getProviderHelper.js\";\nimport { makeRequestOptionsFromResolvedModel } from \"../lib/makeRequestOptions.js\";\nimport { templates } from \"./templates.exported.js\";\nimport { getLogger } from \"../lib/logger.js\";\nimport { HF_ROUTER_AUTO_ENDPOINT } from \"../config.js\";\nconst PYTHON_CLIENTS = [\"openai\", \"huggingface_hub\", \"fal_client\", \"requests\"];\nconst JS_CLIENTS = [\"openai\", \"huggingface.js\", \"fetch\"];\nconst SH_CLIENTS = [\"curl\"];\nconst CLIENTS = {\n  js: [...JS_CLIENTS],\n  python: [...PYTHON_CLIENTS],\n  sh: [...SH_CLIENTS]\n};\n// The \"auto\"-provider policy is only available through the HF SDKs (huggingface.js / huggingface_hub)\n// except for conversational tasks for which we have https://router.huggingface.co/v1/chat/completions\nconst CLIENTS_NON_CONVERSATIONAL_AUTO_POLICY = {\n  js: [\"huggingface.js\"],\n  python: [\"huggingface_hub\"]\n};\n// Helpers to find + load templates\nconst hasTemplate = (language, client, templateName) => templates[language]?.[client]?.[templateName] !== undefined;\nconst loadTemplate = (language, client, templateName) => {\n  const template = templates[language]?.[client]?.[templateName];\n  if (!template) {\n    throw new Error(`Template not found: ${language}/${client}/${templateName}`);\n  }\n  return data => new Template(template).render({\n    ...data\n  });\n};\nconst snippetImportPythonInferenceClient = loadTemplate(\"python\", \"huggingface_hub\", \"importInferenceClient\");\nconst snippetImportRequests = loadTemplate(\"python\", \"requests\", \"importRequests\");\n// Needed for huggingface_hub basic snippets\nconst HF_PYTHON_METHODS = {\n  \"audio-classification\": \"audio_classification\",\n  \"audio-to-audio\": \"audio_to_audio\",\n  \"automatic-speech-recognition\": \"automatic_speech_recognition\",\n  \"document-question-answering\": \"document_question_answering\",\n  \"feature-extraction\": \"feature_extraction\",\n  \"fill-mask\": \"fill_mask\",\n  \"image-classification\": \"image_classification\",\n  \"image-segmentation\": \"image_segmentation\",\n  \"image-to-image\": \"image_to_image\",\n  \"image-to-text\": \"image_to_text\",\n  \"object-detection\": \"object_detection\",\n  \"question-answering\": \"question_answering\",\n  \"sentence-similarity\": \"sentence_similarity\",\n  summarization: \"summarization\",\n  \"table-question-answering\": \"table_question_answering\",\n  \"tabular-classification\": \"tabular_classification\",\n  \"tabular-regression\": \"tabular_regression\",\n  \"text-classification\": \"text_classification\",\n  \"text-generation\": \"text_generation\",\n  \"text-to-image\": \"text_to_image\",\n  \"text-to-speech\": \"text_to_speech\",\n  \"text-to-video\": \"text_to_video\",\n  \"token-classification\": \"token_classification\",\n  translation: \"translation\",\n  \"visual-question-answering\": \"visual_question_answering\",\n  \"zero-shot-classification\": \"zero_shot_classification\",\n  \"zero-shot-image-classification\": \"zero_shot_image_classification\"\n};\n// Needed for huggingface.js basic snippets\nconst HF_JS_METHODS = {\n  \"automatic-speech-recognition\": \"automaticSpeechRecognition\",\n  \"feature-extraction\": \"featureExtraction\",\n  \"fill-mask\": \"fillMask\",\n  \"image-classification\": \"imageClassification\",\n  \"question-answering\": \"questionAnswering\",\n  \"sentence-similarity\": \"sentenceSimilarity\",\n  summarization: \"summarization\",\n  \"table-question-answering\": \"tableQuestionAnswering\",\n  \"text-classification\": \"textClassification\",\n  \"text-generation\": \"textGeneration\",\n  \"token-classification\": \"tokenClassification\",\n  \"text-to-speech\": \"textToSpeech\",\n  translation: \"translation\"\n};\n// Placeholders to replace with env variable in snippets\n// little hack to support both direct requests and routing => routed requests should start with \"hf_\"\nconst ACCESS_TOKEN_ROUTING_PLACEHOLDER = \"hf_token_placeholder\";\nconst ACCESS_TOKEN_DIRECT_REQUEST_PLACEHOLDER = \"not_hf_token_placeholder\";\n// Snippet generators\nconst snippetGenerator = (templateName, inputPreparationFn) => {\n  return (model, provider, inferenceProviderMapping, opts) => {\n    const logger = getLogger();\n    const providerModelId = inferenceProviderMapping?.providerId ?? model.id;\n    /// Hacky: hard-code conversational templates here\n    let task = model.pipeline_tag;\n    if (model.pipeline_tag && [\"text-generation\", \"image-text-to-text\"].includes(model.pipeline_tag) && model.tags.includes(\"conversational\")) {\n      templateName = opts?.streaming ? \"conversationalStream\" : \"conversational\";\n      inputPreparationFn = prepareConversationalInput;\n      task = \"conversational\";\n    }\n    let providerHelper;\n    try {\n      providerHelper = getProviderHelper(provider, task);\n    } catch (e) {\n      logger.error(`Failed to get provider helper for ${provider} (${task})`, e);\n      return [];\n    }\n    const placeholder = opts?.directRequest ? ACCESS_TOKEN_DIRECT_REQUEST_PLACEHOLDER : ACCESS_TOKEN_ROUTING_PLACEHOLDER;\n    const accessTokenOrPlaceholder = opts?.accessToken ?? placeholder;\n    /// Prepare inputs + make request\n    const inputs = opts?.inputs ? {\n      inputs: opts.inputs\n    } : inputPreparationFn ? inputPreparationFn(model, opts) : {\n      inputs: getModelInputSnippet(model)\n    };\n    const request = makeRequestOptionsFromResolvedModel(providerModelId, providerHelper, {\n      accessToken: accessTokenOrPlaceholder,\n      provider,\n      endpointUrl: opts?.endpointUrl ?? (provider === \"auto\" ? HF_ROUTER_AUTO_ENDPOINT : undefined),\n      ...inputs\n    }, inferenceProviderMapping, {\n      task,\n      billTo: opts?.billTo\n    });\n    /// Parse request.info.body if not a binary.\n    /// This is the body sent to the provider. Important for snippets with raw payload (e.g curl, requests, etc.)\n    let providerInputs = inputs;\n    const bodyAsObj = request.info.body;\n    if (typeof bodyAsObj === \"string\") {\n      try {\n        providerInputs = JSON.parse(bodyAsObj);\n      } catch (e) {\n        logger.error(\"Failed to parse body as JSON\", e);\n      }\n    }\n    // Inputs for the \"auto\" route is strictly the same as \"inputs\", except the model includes the provider\n    // If not \"auto\" route, use the providerInputs\n    const autoInputs = !opts?.endpointUrl && !opts?.directRequest ? provider !== \"auto\" ? {\n      ...inputs,\n      model: `${model.id}:${provider}`\n    } : {\n      ...inputs,\n      model: `${model.id}` // if no :provider => auto\n    } : providerInputs;\n    /// Prepare template injection data\n    const params = {\n      accessToken: accessTokenOrPlaceholder,\n      authorizationHeader: request.info.headers?.Authorization,\n      baseUrl: task === \"conversational\" && !opts?.endpointUrl && !opts?.directRequest ? HF_ROUTER_AUTO_ENDPOINT : removeSuffix(request.url, \"/chat/completions\"),\n      fullUrl: task === \"conversational\" && !opts?.endpointUrl && !opts?.directRequest ? HF_ROUTER_AUTO_ENDPOINT + \"/chat/completions\" : request.url,\n      inputs: {\n        asObj: inputs,\n        asCurlString: formatBody(inputs, \"curl\"),\n        asJsonString: formatBody(inputs, \"json\"),\n        asPythonString: formatBody(inputs, \"python\"),\n        asTsString: formatBody(inputs, \"ts\")\n      },\n      providerInputs: {\n        asObj: providerInputs,\n        asCurlString: formatBody(providerInputs, \"curl\"),\n        asJsonString: formatBody(providerInputs, \"json\"),\n        asPythonString: formatBody(providerInputs, \"python\"),\n        asTsString: formatBody(providerInputs, \"ts\")\n      },\n      autoInputs: {\n        asObj: autoInputs,\n        asCurlString: formatBody(autoInputs, \"curl\"),\n        asJsonString: formatBody(autoInputs, \"json\"),\n        asPythonString: formatBody(autoInputs, \"python\"),\n        asTsString: formatBody(autoInputs, \"ts\")\n      },\n      model,\n      provider,\n      providerModelId: task === \"conversational\" && !opts?.endpointUrl && !opts?.directRequest ? provider !== \"auto\" ? `${model.id}:${provider}` // e.g. \"moonshotai/Kimi-K2-Instruct:groq\"\n      : model.id : providerModelId ?? model.id,\n      billTo: opts?.billTo,\n      endpointUrl: opts?.endpointUrl\n    };\n    /// Iterate over clients => check if a snippet exists => generate\n    const clients = provider === \"auto\" && task !== \"conversational\" ? CLIENTS_NON_CONVERSATIONAL_AUTO_POLICY : CLIENTS;\n    return inferenceSnippetLanguages.map(language => {\n      const langClients = clients[language] ?? [];\n      return langClients.map(client => {\n        if (!hasTemplate(language, client, templateName)) {\n          return;\n        }\n        const template = loadTemplate(language, client, templateName);\n        if (client === \"huggingface_hub\" && templateName.includes(\"basic\")) {\n          if (!(model.pipeline_tag && model.pipeline_tag in HF_PYTHON_METHODS)) {\n            return;\n          }\n          params[\"methodName\"] = HF_PYTHON_METHODS[model.pipeline_tag];\n        }\n        if (client === \"huggingface.js\" && templateName.includes(\"basic\")) {\n          if (!(model.pipeline_tag && model.pipeline_tag in HF_JS_METHODS)) {\n            return;\n          }\n          params[\"methodName\"] = HF_JS_METHODS[model.pipeline_tag];\n        }\n        /// Generate snippet\n        let snippet = template(params).trim();\n        if (!snippet) {\n          return;\n        }\n        /// Add import section separately\n        if (client === \"huggingface_hub\") {\n          const importSection = snippetImportPythonInferenceClient({\n            ...params\n          });\n          snippet = `${importSection}\\n\\n${snippet}`;\n        } else if (client === \"requests\") {\n          const importSection = snippetImportRequests({\n            ...params,\n            importBase64: snippet.includes(\"base64\"),\n            importJson: snippet.includes(\"json.\")\n          });\n          snippet = `${importSection}\\n\\n${snippet}`;\n        }\n        /// Replace access token placeholder\n        if (snippet.includes(placeholder)) {\n          snippet = replaceAccessTokenPlaceholder(opts?.directRequest, placeholder, snippet, language, provider, opts?.endpointUrl);\n        }\n        /// Snippet is ready!\n        return {\n          language,\n          client: client,\n          content: snippet\n        };\n      }).filter(snippet => snippet !== undefined);\n    }).flat();\n  };\n};\nconst prepareDocumentQuestionAnsweringInput = model => {\n  return JSON.parse(getModelInputSnippet(model));\n};\nconst prepareImageToImageInput = model => {\n  const data = JSON.parse(getModelInputSnippet(model));\n  return {\n    inputs: data.image,\n    parameters: {\n      prompt: data.prompt\n    }\n  };\n};\nconst prepareConversationalInput = (model, opts) => {\n  return {\n    messages: opts?.messages ?? getModelInputSnippet(model),\n    ...(opts?.temperature ? {\n      temperature: opts?.temperature\n    } : undefined),\n    ...(opts?.max_tokens ? {\n      max_tokens: opts?.max_tokens\n    } : undefined),\n    ...(opts?.top_p ? {\n      top_p: opts?.top_p\n    } : undefined)\n  };\n};\nconst prepareQuestionAnsweringInput = model => {\n  const data = JSON.parse(getModelInputSnippet(model));\n  return {\n    question: data.question,\n    context: data.context\n  };\n};\nconst prepareTableQuestionAnsweringInput = model => {\n  const data = JSON.parse(getModelInputSnippet(model));\n  return {\n    query: data.query,\n    table: JSON.stringify(data.table)\n  };\n};\nconst snippets = {\n  \"audio-classification\": snippetGenerator(\"basicAudio\"),\n  \"audio-to-audio\": snippetGenerator(\"basicAudio\"),\n  \"automatic-speech-recognition\": snippetGenerator(\"basicAudio\"),\n  \"document-question-answering\": snippetGenerator(\"documentQuestionAnswering\", prepareDocumentQuestionAnsweringInput),\n  \"feature-extraction\": snippetGenerator(\"basic\"),\n  \"fill-mask\": snippetGenerator(\"basic\"),\n  \"image-classification\": snippetGenerator(\"basicImage\"),\n  \"image-segmentation\": snippetGenerator(\"basicImage\"),\n  \"image-text-to-text\": snippetGenerator(\"conversational\"),\n  \"image-to-image\": snippetGenerator(\"imageToImage\", prepareImageToImageInput),\n  \"image-to-text\": snippetGenerator(\"basicImage\"),\n  \"image-to-video\": snippetGenerator(\"imageToVideo\", prepareImageToImageInput),\n  \"object-detection\": snippetGenerator(\"basicImage\"),\n  \"question-answering\": snippetGenerator(\"questionAnswering\", prepareQuestionAnsweringInput),\n  \"sentence-similarity\": snippetGenerator(\"basic\"),\n  summarization: snippetGenerator(\"basic\"),\n  \"tabular-classification\": snippetGenerator(\"tabular\"),\n  \"tabular-regression\": snippetGenerator(\"tabular\"),\n  \"table-question-answering\": snippetGenerator(\"tableQuestionAnswering\", prepareTableQuestionAnsweringInput),\n  \"text-classification\": snippetGenerator(\"basic\"),\n  \"text-generation\": snippetGenerator(\"basic\"),\n  \"text-to-audio\": snippetGenerator(\"textToAudio\"),\n  \"text-to-image\": snippetGenerator(\"textToImage\"),\n  \"text-to-speech\": snippetGenerator(\"textToSpeech\"),\n  \"text-to-video\": snippetGenerator(\"textToVideo\"),\n  \"token-classification\": snippetGenerator(\"basic\"),\n  translation: snippetGenerator(\"basic\"),\n  \"zero-shot-classification\": snippetGenerator(\"zeroShotClassification\"),\n  \"zero-shot-image-classification\": snippetGenerator(\"zeroShotImageClassification\")\n};\nexport function getInferenceSnippets(model, provider, inferenceProviderMapping, opts) {\n  return model.pipeline_tag && model.pipeline_tag in snippets ? snippets[model.pipeline_tag]?.(model, provider, inferenceProviderMapping, opts) ?? [] : [];\n}\n// String manipulation helpers\nfunction formatBody(obj, format) {\n  switch (format) {\n    case \"curl\":\n      return indentString(formatBody(obj, \"json\"));\n    case \"json\":\n      /// Hacky: remove outer brackets to make is extendable in templates\n      return JSON.stringify(obj, null, 4).split(\"\\n\").slice(1, -1).join(\"\\n\");\n    case \"python\":\n      return indentString(Object.entries(obj).map(([key, value]) => {\n        const formattedValue = JSON.stringify(value, null, 4).replace(/\"/g, '\"');\n        return `${key}=${formattedValue},`;\n      }).join(\"\\n\"));\n    case \"ts\":\n      /// Hacky: remove outer brackets to make is extendable in templates\n      return formatTsObject(obj).split(\"\\n\").slice(1, -1).join(\"\\n\");\n    default:\n      throw new Error(`Unsupported format: ${format}`);\n  }\n}\nfunction formatTsObject(obj, depth) {\n  depth = depth ?? 0;\n  /// Case int, boolean, string, etc.\n  if (typeof obj !== \"object\" || obj === null) {\n    return JSON.stringify(obj);\n  }\n  /// Case array\n  if (Array.isArray(obj)) {\n    const items = obj.map(item => {\n      const formatted = formatTsObject(item, depth + 1);\n      return `${\" \".repeat(4 * (depth + 1))}${formatted},`;\n    }).join(\"\\n\");\n    return `[\\n${items}\\n${\" \".repeat(4 * depth)}]`;\n  }\n  /// Case mapping\n  const entries = Object.entries(obj);\n  const lines = entries.map(([key, value]) => {\n    const formattedValue = formatTsObject(value, depth + 1);\n    const keyStr = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `\"${key}\"`;\n    return `${\" \".repeat(4 * (depth + 1))}${keyStr}: ${formattedValue},`;\n  }).join(\"\\n\");\n  return `{\\n${lines}\\n${\" \".repeat(4 * depth)}}`;\n}\nfunction indentString(str) {\n  return str.split(\"\\n\").map(line => \" \".repeat(4) + line).join(\"\\n\");\n}\nfunction removeSuffix(str, suffix) {\n  return str.endsWith(suffix) ? str.slice(0, -suffix.length) : str;\n}\nfunction replaceAccessTokenPlaceholder(directRequest, placeholder, snippet, language, provider, endpointUrl) {\n  // If \"opts.accessToken\" is not set, the snippets are generated with a placeholder.\n  // Once snippets are rendered, we replace the placeholder with code to fetch the access token from an environment variable.\n  // Determine if HF_TOKEN or specific provider token should be used\n  const useHfToken = !endpointUrl && (\n  // custom endpointUrl => use a generic API_TOKEN\n  provider == \"hf-inference\" ||\n  // hf-inference provider => use $HF_TOKEN\n  !directRequest && (\n  // if explicit directRequest => use provider-specific token\n  snippet.includes(\"InferenceClient\") ||\n  // using a client => use $HF_TOKEN\n  snippet.includes(\"https://router.huggingface.co\"))); // explicit routed request => use $HF_TOKEN\n  const accessTokenEnvVar = useHfToken ? \"HF_TOKEN\" // e.g. routed request or hf-inference\n  : endpointUrl ? \"API_TOKEN\" : provider.toUpperCase().replace(\"-\", \"_\") + \"_API_KEY\"; // e.g. \"REPLICATE_API_KEY\"\n  // Replace the placeholder with the env variable\n  if (language === \"sh\") {\n    snippet = snippet.replace(`'Authorization: Bearer ${placeholder}'`, `\"Authorization: Bearer $${accessTokenEnvVar}\"` // e.g. \"Authorization: Bearer $HF_TOKEN\"\n    );\n  } else if (language === \"python\") {\n    snippet = \"import os\\n\" + snippet;\n    snippet = snippet.replace(`\"${placeholder}\"`, `os.environ[\"${accessTokenEnvVar}\"]` // e.g. os.environ[\"HF_TOKEN\")\n    );\n    snippet = snippet.replace(`\"Bearer ${placeholder}\"`, `f\"Bearer {os.environ['${accessTokenEnvVar}']}\"` // e.g. f\"Bearer {os.environ['HF_TOKEN']}\"\n    );\n    snippet = snippet.replace(`\"Key ${placeholder}\"`, `f\"Key {os.environ['${accessTokenEnvVar}']}\"` // e.g. f\"Key {os.environ['FAL_AI_API_KEY']}\"\n    );\n    snippet = snippet.replace(`\"X-Key ${placeholder}\"`, `f\"X-Key {os.environ['${accessTokenEnvVar}']}\"` // e.g. f\"X-Key {os.environ['BLACK_FOREST_LABS_API_KEY']}\"\n    );\n  } else if (language === \"js\") {\n    snippet = snippet.replace(`\"${placeholder}\"`, `process.env.${accessTokenEnvVar}` // e.g. process.env.HF_TOKEN\n    );\n    snippet = snippet.replace(`Authorization: \"Bearer ${placeholder}\",`, `Authorization: \\`Bearer $\\{process.env.${accessTokenEnvVar}}\\`,` // e.g. Authorization: `Bearer ${process.env.HF_TOKEN}`,\n    );\n    snippet = snippet.replace(`Authorization: \"Key ${placeholder}\",`, `Authorization: \\`Key $\\{process.env.${accessTokenEnvVar}}\\`,` // e.g. Authorization: `Key ${process.env.FAL_AI_API_KEY}`,\n    );\n    snippet = snippet.replace(`Authorization: \"X-Key ${placeholder}\",`, `Authorization: \\`X-Key $\\{process.env.${accessTokenEnvVar}}\\`,` // e.g. Authorization: `X-Key ${process.env.BLACK_FOREST_LABS_AI_API_KEY}`,\n    );\n  }\n  return snippet;\n}","map":{"version":3,"names":["Template","getModelInputSnippet","inferenceSnippetLanguages","getProviderHelper","makeRequestOptionsFromResolvedModel","templates","getLogger","HF_ROUTER_AUTO_ENDPOINT","PYTHON_CLIENTS","JS_CLIENTS","SH_CLIENTS","CLIENTS","js","python","sh","CLIENTS_NON_CONVERSATIONAL_AUTO_POLICY","hasTemplate","language","client","templateName","undefined","loadTemplate","template","Error","data","render","snippetImportPythonInferenceClient","snippetImportRequests","HF_PYTHON_METHODS","summarization","translation","HF_JS_METHODS","ACCESS_TOKEN_ROUTING_PLACEHOLDER","ACCESS_TOKEN_DIRECT_REQUEST_PLACEHOLDER","snippetGenerator","inputPreparationFn","model","provider","inferenceProviderMapping","opts","logger","providerModelId","providerId","id","task","pipeline_tag","includes","tags","streaming","prepareConversationalInput","providerHelper","e","error","placeholder","directRequest","accessTokenOrPlaceholder","accessToken","inputs","request","endpointUrl","billTo","providerInputs","bodyAsObj","info","body","JSON","parse","autoInputs","params","authorizationHeader","headers","Authorization","baseUrl","removeSuffix","url","fullUrl","asObj","asCurlString","formatBody","asJsonString","asPythonString","asTsString","clients","map","langClients","snippet","trim","importSection","importBase64","importJson","replaceAccessTokenPlaceholder","content","filter","flat","prepareDocumentQuestionAnsweringInput","prepareImageToImageInput","image","parameters","prompt","messages","temperature","max_tokens","top_p","prepareQuestionAnsweringInput","question","context","prepareTableQuestionAnsweringInput","query","table","stringify","snippets","getInferenceSnippets","obj","format","indentString","split","slice","join","Object","entries","key","value","formattedValue","replace","formatTsObject","depth","Array","isArray","items","item","formatted","repeat","lines","keyStr","test","str","line","suffix","endsWith","length","useHfToken","accessTokenEnvVar","toUpperCase"],"sources":["/Users/agmacbook/Documents/Courses/Meta - Full Stack/Exercises/meta_fullstack_exercises/6_react_basics/12_review/13_chef_claude/node_modules/@huggingface/inference/dist/esm/snippets/getInferenceSnippets.js"],"sourcesContent":["import { Template } from \"@huggingface/jinja\";\nimport { getModelInputSnippet, inferenceSnippetLanguages, } from \"@huggingface/tasks\";\nimport { getProviderHelper } from \"../lib/getProviderHelper.js\";\nimport { makeRequestOptionsFromResolvedModel } from \"../lib/makeRequestOptions.js\";\nimport { templates } from \"./templates.exported.js\";\nimport { getLogger } from \"../lib/logger.js\";\nimport { HF_ROUTER_AUTO_ENDPOINT } from \"../config.js\";\nconst PYTHON_CLIENTS = [\"openai\", \"huggingface_hub\", \"fal_client\", \"requests\"];\nconst JS_CLIENTS = [\"openai\", \"huggingface.js\", \"fetch\"];\nconst SH_CLIENTS = [\"curl\"];\nconst CLIENTS = {\n    js: [...JS_CLIENTS],\n    python: [...PYTHON_CLIENTS],\n    sh: [...SH_CLIENTS],\n};\n// The \"auto\"-provider policy is only available through the HF SDKs (huggingface.js / huggingface_hub)\n// except for conversational tasks for which we have https://router.huggingface.co/v1/chat/completions\nconst CLIENTS_NON_CONVERSATIONAL_AUTO_POLICY = {\n    js: [\"huggingface.js\"],\n    python: [\"huggingface_hub\"],\n};\n// Helpers to find + load templates\nconst hasTemplate = (language, client, templateName) => templates[language]?.[client]?.[templateName] !== undefined;\nconst loadTemplate = (language, client, templateName) => {\n    const template = templates[language]?.[client]?.[templateName];\n    if (!template) {\n        throw new Error(`Template not found: ${language}/${client}/${templateName}`);\n    }\n    return (data) => new Template(template).render({ ...data });\n};\nconst snippetImportPythonInferenceClient = loadTemplate(\"python\", \"huggingface_hub\", \"importInferenceClient\");\nconst snippetImportRequests = loadTemplate(\"python\", \"requests\", \"importRequests\");\n// Needed for huggingface_hub basic snippets\nconst HF_PYTHON_METHODS = {\n    \"audio-classification\": \"audio_classification\",\n    \"audio-to-audio\": \"audio_to_audio\",\n    \"automatic-speech-recognition\": \"automatic_speech_recognition\",\n    \"document-question-answering\": \"document_question_answering\",\n    \"feature-extraction\": \"feature_extraction\",\n    \"fill-mask\": \"fill_mask\",\n    \"image-classification\": \"image_classification\",\n    \"image-segmentation\": \"image_segmentation\",\n    \"image-to-image\": \"image_to_image\",\n    \"image-to-text\": \"image_to_text\",\n    \"object-detection\": \"object_detection\",\n    \"question-answering\": \"question_answering\",\n    \"sentence-similarity\": \"sentence_similarity\",\n    summarization: \"summarization\",\n    \"table-question-answering\": \"table_question_answering\",\n    \"tabular-classification\": \"tabular_classification\",\n    \"tabular-regression\": \"tabular_regression\",\n    \"text-classification\": \"text_classification\",\n    \"text-generation\": \"text_generation\",\n    \"text-to-image\": \"text_to_image\",\n    \"text-to-speech\": \"text_to_speech\",\n    \"text-to-video\": \"text_to_video\",\n    \"token-classification\": \"token_classification\",\n    translation: \"translation\",\n    \"visual-question-answering\": \"visual_question_answering\",\n    \"zero-shot-classification\": \"zero_shot_classification\",\n    \"zero-shot-image-classification\": \"zero_shot_image_classification\",\n};\n// Needed for huggingface.js basic snippets\nconst HF_JS_METHODS = {\n    \"automatic-speech-recognition\": \"automaticSpeechRecognition\",\n    \"feature-extraction\": \"featureExtraction\",\n    \"fill-mask\": \"fillMask\",\n    \"image-classification\": \"imageClassification\",\n    \"question-answering\": \"questionAnswering\",\n    \"sentence-similarity\": \"sentenceSimilarity\",\n    summarization: \"summarization\",\n    \"table-question-answering\": \"tableQuestionAnswering\",\n    \"text-classification\": \"textClassification\",\n    \"text-generation\": \"textGeneration\",\n    \"token-classification\": \"tokenClassification\",\n    \"text-to-speech\": \"textToSpeech\",\n    translation: \"translation\",\n};\n// Placeholders to replace with env variable in snippets\n// little hack to support both direct requests and routing => routed requests should start with \"hf_\"\nconst ACCESS_TOKEN_ROUTING_PLACEHOLDER = \"hf_token_placeholder\";\nconst ACCESS_TOKEN_DIRECT_REQUEST_PLACEHOLDER = \"not_hf_token_placeholder\";\n// Snippet generators\nconst snippetGenerator = (templateName, inputPreparationFn) => {\n    return (model, provider, inferenceProviderMapping, opts) => {\n        const logger = getLogger();\n        const providerModelId = inferenceProviderMapping?.providerId ?? model.id;\n        /// Hacky: hard-code conversational templates here\n        let task = model.pipeline_tag;\n        if (model.pipeline_tag &&\n            [\"text-generation\", \"image-text-to-text\"].includes(model.pipeline_tag) &&\n            model.tags.includes(\"conversational\")) {\n            templateName = opts?.streaming ? \"conversationalStream\" : \"conversational\";\n            inputPreparationFn = prepareConversationalInput;\n            task = \"conversational\";\n        }\n        let providerHelper;\n        try {\n            providerHelper = getProviderHelper(provider, task);\n        }\n        catch (e) {\n            logger.error(`Failed to get provider helper for ${provider} (${task})`, e);\n            return [];\n        }\n        const placeholder = opts?.directRequest\n            ? ACCESS_TOKEN_DIRECT_REQUEST_PLACEHOLDER\n            : ACCESS_TOKEN_ROUTING_PLACEHOLDER;\n        const accessTokenOrPlaceholder = opts?.accessToken ?? placeholder;\n        /// Prepare inputs + make request\n        const inputs = opts?.inputs\n            ? { inputs: opts.inputs }\n            : inputPreparationFn\n                ? inputPreparationFn(model, opts)\n                : { inputs: getModelInputSnippet(model) };\n        const request = makeRequestOptionsFromResolvedModel(providerModelId, providerHelper, {\n            accessToken: accessTokenOrPlaceholder,\n            provider,\n            endpointUrl: opts?.endpointUrl ?? (provider === \"auto\" ? HF_ROUTER_AUTO_ENDPOINT : undefined),\n            ...inputs,\n        }, inferenceProviderMapping, {\n            task,\n            billTo: opts?.billTo,\n        });\n        /// Parse request.info.body if not a binary.\n        /// This is the body sent to the provider. Important for snippets with raw payload (e.g curl, requests, etc.)\n        let providerInputs = inputs;\n        const bodyAsObj = request.info.body;\n        if (typeof bodyAsObj === \"string\") {\n            try {\n                providerInputs = JSON.parse(bodyAsObj);\n            }\n            catch (e) {\n                logger.error(\"Failed to parse body as JSON\", e);\n            }\n        }\n        // Inputs for the \"auto\" route is strictly the same as \"inputs\", except the model includes the provider\n        // If not \"auto\" route, use the providerInputs\n        const autoInputs = !opts?.endpointUrl && !opts?.directRequest\n            ? provider !== \"auto\"\n                ? {\n                    ...inputs,\n                    model: `${model.id}:${provider}`,\n                }\n                : {\n                    ...inputs,\n                    model: `${model.id}`, // if no :provider => auto\n                }\n            : providerInputs;\n        /// Prepare template injection data\n        const params = {\n            accessToken: accessTokenOrPlaceholder,\n            authorizationHeader: request.info.headers?.Authorization,\n            baseUrl: task === \"conversational\" && !opts?.endpointUrl && !opts?.directRequest\n                ? HF_ROUTER_AUTO_ENDPOINT\n                : removeSuffix(request.url, \"/chat/completions\"),\n            fullUrl: task === \"conversational\" && !opts?.endpointUrl && !opts?.directRequest\n                ? HF_ROUTER_AUTO_ENDPOINT + \"/chat/completions\"\n                : request.url,\n            inputs: {\n                asObj: inputs,\n                asCurlString: formatBody(inputs, \"curl\"),\n                asJsonString: formatBody(inputs, \"json\"),\n                asPythonString: formatBody(inputs, \"python\"),\n                asTsString: formatBody(inputs, \"ts\"),\n            },\n            providerInputs: {\n                asObj: providerInputs,\n                asCurlString: formatBody(providerInputs, \"curl\"),\n                asJsonString: formatBody(providerInputs, \"json\"),\n                asPythonString: formatBody(providerInputs, \"python\"),\n                asTsString: formatBody(providerInputs, \"ts\"),\n            },\n            autoInputs: {\n                asObj: autoInputs,\n                asCurlString: formatBody(autoInputs, \"curl\"),\n                asJsonString: formatBody(autoInputs, \"json\"),\n                asPythonString: formatBody(autoInputs, \"python\"),\n                asTsString: formatBody(autoInputs, \"ts\"),\n            },\n            model,\n            provider,\n            providerModelId: task === \"conversational\" && !opts?.endpointUrl && !opts?.directRequest\n                ? provider !== \"auto\"\n                    ? `${model.id}:${provider}` // e.g. \"moonshotai/Kimi-K2-Instruct:groq\"\n                    : model.id\n                : providerModelId ?? model.id,\n            billTo: opts?.billTo,\n            endpointUrl: opts?.endpointUrl,\n        };\n        /// Iterate over clients => check if a snippet exists => generate\n        const clients = provider === \"auto\" && task !== \"conversational\" ? CLIENTS_NON_CONVERSATIONAL_AUTO_POLICY : CLIENTS;\n        return inferenceSnippetLanguages\n            .map((language) => {\n            const langClients = clients[language] ?? [];\n            return langClients\n                .map((client) => {\n                if (!hasTemplate(language, client, templateName)) {\n                    return;\n                }\n                const template = loadTemplate(language, client, templateName);\n                if (client === \"huggingface_hub\" && templateName.includes(\"basic\")) {\n                    if (!(model.pipeline_tag && model.pipeline_tag in HF_PYTHON_METHODS)) {\n                        return;\n                    }\n                    params[\"methodName\"] = HF_PYTHON_METHODS[model.pipeline_tag];\n                }\n                if (client === \"huggingface.js\" && templateName.includes(\"basic\")) {\n                    if (!(model.pipeline_tag && model.pipeline_tag in HF_JS_METHODS)) {\n                        return;\n                    }\n                    params[\"methodName\"] = HF_JS_METHODS[model.pipeline_tag];\n                }\n                /// Generate snippet\n                let snippet = template(params).trim();\n                if (!snippet) {\n                    return;\n                }\n                /// Add import section separately\n                if (client === \"huggingface_hub\") {\n                    const importSection = snippetImportPythonInferenceClient({ ...params });\n                    snippet = `${importSection}\\n\\n${snippet}`;\n                }\n                else if (client === \"requests\") {\n                    const importSection = snippetImportRequests({\n                        ...params,\n                        importBase64: snippet.includes(\"base64\"),\n                        importJson: snippet.includes(\"json.\"),\n                    });\n                    snippet = `${importSection}\\n\\n${snippet}`;\n                }\n                /// Replace access token placeholder\n                if (snippet.includes(placeholder)) {\n                    snippet = replaceAccessTokenPlaceholder(opts?.directRequest, placeholder, snippet, language, provider, opts?.endpointUrl);\n                }\n                /// Snippet is ready!\n                return { language, client: client, content: snippet };\n            })\n                .filter((snippet) => snippet !== undefined);\n        })\n            .flat();\n    };\n};\nconst prepareDocumentQuestionAnsweringInput = (model) => {\n    return JSON.parse(getModelInputSnippet(model));\n};\nconst prepareImageToImageInput = (model) => {\n    const data = JSON.parse(getModelInputSnippet(model));\n    return { inputs: data.image, parameters: { prompt: data.prompt } };\n};\nconst prepareConversationalInput = (model, opts) => {\n    return {\n        messages: opts?.messages ?? getModelInputSnippet(model),\n        ...(opts?.temperature ? { temperature: opts?.temperature } : undefined),\n        ...(opts?.max_tokens ? { max_tokens: opts?.max_tokens } : undefined),\n        ...(opts?.top_p ? { top_p: opts?.top_p } : undefined),\n    };\n};\nconst prepareQuestionAnsweringInput = (model) => {\n    const data = JSON.parse(getModelInputSnippet(model));\n    return { question: data.question, context: data.context };\n};\nconst prepareTableQuestionAnsweringInput = (model) => {\n    const data = JSON.parse(getModelInputSnippet(model));\n    return { query: data.query, table: JSON.stringify(data.table) };\n};\nconst snippets = {\n    \"audio-classification\": snippetGenerator(\"basicAudio\"),\n    \"audio-to-audio\": snippetGenerator(\"basicAudio\"),\n    \"automatic-speech-recognition\": snippetGenerator(\"basicAudio\"),\n    \"document-question-answering\": snippetGenerator(\"documentQuestionAnswering\", prepareDocumentQuestionAnsweringInput),\n    \"feature-extraction\": snippetGenerator(\"basic\"),\n    \"fill-mask\": snippetGenerator(\"basic\"),\n    \"image-classification\": snippetGenerator(\"basicImage\"),\n    \"image-segmentation\": snippetGenerator(\"basicImage\"),\n    \"image-text-to-text\": snippetGenerator(\"conversational\"),\n    \"image-to-image\": snippetGenerator(\"imageToImage\", prepareImageToImageInput),\n    \"image-to-text\": snippetGenerator(\"basicImage\"),\n    \"image-to-video\": snippetGenerator(\"imageToVideo\", prepareImageToImageInput),\n    \"object-detection\": snippetGenerator(\"basicImage\"),\n    \"question-answering\": snippetGenerator(\"questionAnswering\", prepareQuestionAnsweringInput),\n    \"sentence-similarity\": snippetGenerator(\"basic\"),\n    summarization: snippetGenerator(\"basic\"),\n    \"tabular-classification\": snippetGenerator(\"tabular\"),\n    \"tabular-regression\": snippetGenerator(\"tabular\"),\n    \"table-question-answering\": snippetGenerator(\"tableQuestionAnswering\", prepareTableQuestionAnsweringInput),\n    \"text-classification\": snippetGenerator(\"basic\"),\n    \"text-generation\": snippetGenerator(\"basic\"),\n    \"text-to-audio\": snippetGenerator(\"textToAudio\"),\n    \"text-to-image\": snippetGenerator(\"textToImage\"),\n    \"text-to-speech\": snippetGenerator(\"textToSpeech\"),\n    \"text-to-video\": snippetGenerator(\"textToVideo\"),\n    \"token-classification\": snippetGenerator(\"basic\"),\n    translation: snippetGenerator(\"basic\"),\n    \"zero-shot-classification\": snippetGenerator(\"zeroShotClassification\"),\n    \"zero-shot-image-classification\": snippetGenerator(\"zeroShotImageClassification\"),\n};\nexport function getInferenceSnippets(model, provider, inferenceProviderMapping, opts) {\n    return model.pipeline_tag && model.pipeline_tag in snippets\n        ? snippets[model.pipeline_tag]?.(model, provider, inferenceProviderMapping, opts) ?? []\n        : [];\n}\n// String manipulation helpers\nfunction formatBody(obj, format) {\n    switch (format) {\n        case \"curl\":\n            return indentString(formatBody(obj, \"json\"));\n        case \"json\":\n            /// Hacky: remove outer brackets to make is extendable in templates\n            return JSON.stringify(obj, null, 4).split(\"\\n\").slice(1, -1).join(\"\\n\");\n        case \"python\":\n            return indentString(Object.entries(obj)\n                .map(([key, value]) => {\n                const formattedValue = JSON.stringify(value, null, 4).replace(/\"/g, '\"');\n                return `${key}=${formattedValue},`;\n            })\n                .join(\"\\n\"));\n        case \"ts\":\n            /// Hacky: remove outer brackets to make is extendable in templates\n            return formatTsObject(obj).split(\"\\n\").slice(1, -1).join(\"\\n\");\n        default:\n            throw new Error(`Unsupported format: ${format}`);\n    }\n}\nfunction formatTsObject(obj, depth) {\n    depth = depth ?? 0;\n    /// Case int, boolean, string, etc.\n    if (typeof obj !== \"object\" || obj === null) {\n        return JSON.stringify(obj);\n    }\n    /// Case array\n    if (Array.isArray(obj)) {\n        const items = obj\n            .map((item) => {\n            const formatted = formatTsObject(item, depth + 1);\n            return `${\" \".repeat(4 * (depth + 1))}${formatted},`;\n        })\n            .join(\"\\n\");\n        return `[\\n${items}\\n${\" \".repeat(4 * depth)}]`;\n    }\n    /// Case mapping\n    const entries = Object.entries(obj);\n    const lines = entries\n        .map(([key, value]) => {\n        const formattedValue = formatTsObject(value, depth + 1);\n        const keyStr = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `\"${key}\"`;\n        return `${\" \".repeat(4 * (depth + 1))}${keyStr}: ${formattedValue},`;\n    })\n        .join(\"\\n\");\n    return `{\\n${lines}\\n${\" \".repeat(4 * depth)}}`;\n}\nfunction indentString(str) {\n    return str\n        .split(\"\\n\")\n        .map((line) => \" \".repeat(4) + line)\n        .join(\"\\n\");\n}\nfunction removeSuffix(str, suffix) {\n    return str.endsWith(suffix) ? str.slice(0, -suffix.length) : str;\n}\nfunction replaceAccessTokenPlaceholder(directRequest, placeholder, snippet, language, provider, endpointUrl) {\n    // If \"opts.accessToken\" is not set, the snippets are generated with a placeholder.\n    // Once snippets are rendered, we replace the placeholder with code to fetch the access token from an environment variable.\n    // Determine if HF_TOKEN or specific provider token should be used\n    const useHfToken = !endpointUrl && // custom endpointUrl => use a generic API_TOKEN\n        (provider == \"hf-inference\" || // hf-inference provider => use $HF_TOKEN\n            (!directRequest && // if explicit directRequest => use provider-specific token\n                (snippet.includes(\"InferenceClient\") || // using a client => use $HF_TOKEN\n                    snippet.includes(\"https://router.huggingface.co\")))); // explicit routed request => use $HF_TOKEN\n    const accessTokenEnvVar = useHfToken\n        ? \"HF_TOKEN\" // e.g. routed request or hf-inference\n        : endpointUrl\n            ? \"API_TOKEN\"\n            : provider.toUpperCase().replace(\"-\", \"_\") + \"_API_KEY\"; // e.g. \"REPLICATE_API_KEY\"\n    // Replace the placeholder with the env variable\n    if (language === \"sh\") {\n        snippet = snippet.replace(`'Authorization: Bearer ${placeholder}'`, `\"Authorization: Bearer $${accessTokenEnvVar}\"` // e.g. \"Authorization: Bearer $HF_TOKEN\"\n        );\n    }\n    else if (language === \"python\") {\n        snippet = \"import os\\n\" + snippet;\n        snippet = snippet.replace(`\"${placeholder}\"`, `os.environ[\"${accessTokenEnvVar}\"]` // e.g. os.environ[\"HF_TOKEN\")\n        );\n        snippet = snippet.replace(`\"Bearer ${placeholder}\"`, `f\"Bearer {os.environ['${accessTokenEnvVar}']}\"` // e.g. f\"Bearer {os.environ['HF_TOKEN']}\"\n        );\n        snippet = snippet.replace(`\"Key ${placeholder}\"`, `f\"Key {os.environ['${accessTokenEnvVar}']}\"` // e.g. f\"Key {os.environ['FAL_AI_API_KEY']}\"\n        );\n        snippet = snippet.replace(`\"X-Key ${placeholder}\"`, `f\"X-Key {os.environ['${accessTokenEnvVar}']}\"` // e.g. f\"X-Key {os.environ['BLACK_FOREST_LABS_API_KEY']}\"\n        );\n    }\n    else if (language === \"js\") {\n        snippet = snippet.replace(`\"${placeholder}\"`, `process.env.${accessTokenEnvVar}` // e.g. process.env.HF_TOKEN\n        );\n        snippet = snippet.replace(`Authorization: \"Bearer ${placeholder}\",`, `Authorization: \\`Bearer $\\{process.env.${accessTokenEnvVar}}\\`,` // e.g. Authorization: `Bearer ${process.env.HF_TOKEN}`,\n        );\n        snippet = snippet.replace(`Authorization: \"Key ${placeholder}\",`, `Authorization: \\`Key $\\{process.env.${accessTokenEnvVar}}\\`,` // e.g. Authorization: `Key ${process.env.FAL_AI_API_KEY}`,\n        );\n        snippet = snippet.replace(`Authorization: \"X-Key ${placeholder}\",`, `Authorization: \\`X-Key $\\{process.env.${accessTokenEnvVar}}\\`,` // e.g. Authorization: `X-Key ${process.env.BLACK_FOREST_LABS_AI_API_KEY}`,\n        );\n    }\n    return snippet;\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,oBAAoB;AAC7C,SAASC,oBAAoB,EAAEC,yBAAyB,QAAS,oBAAoB;AACrF,SAASC,iBAAiB,QAAQ,6BAA6B;AAC/D,SAASC,mCAAmC,QAAQ,8BAA8B;AAClF,SAASC,SAAS,QAAQ,yBAAyB;AACnD,SAASC,SAAS,QAAQ,kBAAkB;AAC5C,SAASC,uBAAuB,QAAQ,cAAc;AACtD,MAAMC,cAAc,GAAG,CAAC,QAAQ,EAAE,iBAAiB,EAAE,YAAY,EAAE,UAAU,CAAC;AAC9E,MAAMC,UAAU,GAAG,CAAC,QAAQ,EAAE,gBAAgB,EAAE,OAAO,CAAC;AACxD,MAAMC,UAAU,GAAG,CAAC,MAAM,CAAC;AAC3B,MAAMC,OAAO,GAAG;EACZC,EAAE,EAAE,CAAC,GAAGH,UAAU,CAAC;EACnBI,MAAM,EAAE,CAAC,GAAGL,cAAc,CAAC;EAC3BM,EAAE,EAAE,CAAC,GAAGJ,UAAU;AACtB,CAAC;AACD;AACA;AACA,MAAMK,sCAAsC,GAAG;EAC3CH,EAAE,EAAE,CAAC,gBAAgB,CAAC;EACtBC,MAAM,EAAE,CAAC,iBAAiB;AAC9B,CAAC;AACD;AACA,MAAMG,WAAW,GAAGA,CAACC,QAAQ,EAAEC,MAAM,EAAEC,YAAY,KAAKd,SAAS,CAACY,QAAQ,CAAC,GAAGC,MAAM,CAAC,GAAGC,YAAY,CAAC,KAAKC,SAAS;AACnH,MAAMC,YAAY,GAAGA,CAACJ,QAAQ,EAAEC,MAAM,EAAEC,YAAY,KAAK;EACrD,MAAMG,QAAQ,GAAGjB,SAAS,CAACY,QAAQ,CAAC,GAAGC,MAAM,CAAC,GAAGC,YAAY,CAAC;EAC9D,IAAI,CAACG,QAAQ,EAAE;IACX,MAAM,IAAIC,KAAK,CAAC,uBAAuBN,QAAQ,IAAIC,MAAM,IAAIC,YAAY,EAAE,CAAC;EAChF;EACA,OAAQK,IAAI,IAAK,IAAIxB,QAAQ,CAACsB,QAAQ,CAAC,CAACG,MAAM,CAAC;IAAE,GAAGD;EAAK,CAAC,CAAC;AAC/D,CAAC;AACD,MAAME,kCAAkC,GAAGL,YAAY,CAAC,QAAQ,EAAE,iBAAiB,EAAE,uBAAuB,CAAC;AAC7G,MAAMM,qBAAqB,GAAGN,YAAY,CAAC,QAAQ,EAAE,UAAU,EAAE,gBAAgB,CAAC;AAClF;AACA,MAAMO,iBAAiB,GAAG;EACtB,sBAAsB,EAAE,sBAAsB;EAC9C,gBAAgB,EAAE,gBAAgB;EAClC,8BAA8B,EAAE,8BAA8B;EAC9D,6BAA6B,EAAE,6BAA6B;EAC5D,oBAAoB,EAAE,oBAAoB;EAC1C,WAAW,EAAE,WAAW;EACxB,sBAAsB,EAAE,sBAAsB;EAC9C,oBAAoB,EAAE,oBAAoB;EAC1C,gBAAgB,EAAE,gBAAgB;EAClC,eAAe,EAAE,eAAe;EAChC,kBAAkB,EAAE,kBAAkB;EACtC,oBAAoB,EAAE,oBAAoB;EAC1C,qBAAqB,EAAE,qBAAqB;EAC5CC,aAAa,EAAE,eAAe;EAC9B,0BAA0B,EAAE,0BAA0B;EACtD,wBAAwB,EAAE,wBAAwB;EAClD,oBAAoB,EAAE,oBAAoB;EAC1C,qBAAqB,EAAE,qBAAqB;EAC5C,iBAAiB,EAAE,iBAAiB;EACpC,eAAe,EAAE,eAAe;EAChC,gBAAgB,EAAE,gBAAgB;EAClC,eAAe,EAAE,eAAe;EAChC,sBAAsB,EAAE,sBAAsB;EAC9CC,WAAW,EAAE,aAAa;EAC1B,2BAA2B,EAAE,2BAA2B;EACxD,0BAA0B,EAAE,0BAA0B;EACtD,gCAAgC,EAAE;AACtC,CAAC;AACD;AACA,MAAMC,aAAa,GAAG;EAClB,8BAA8B,EAAE,4BAA4B;EAC5D,oBAAoB,EAAE,mBAAmB;EACzC,WAAW,EAAE,UAAU;EACvB,sBAAsB,EAAE,qBAAqB;EAC7C,oBAAoB,EAAE,mBAAmB;EACzC,qBAAqB,EAAE,oBAAoB;EAC3CF,aAAa,EAAE,eAAe;EAC9B,0BAA0B,EAAE,wBAAwB;EACpD,qBAAqB,EAAE,oBAAoB;EAC3C,iBAAiB,EAAE,gBAAgB;EACnC,sBAAsB,EAAE,qBAAqB;EAC7C,gBAAgB,EAAE,cAAc;EAChCC,WAAW,EAAE;AACjB,CAAC;AACD;AACA;AACA,MAAME,gCAAgC,GAAG,sBAAsB;AAC/D,MAAMC,uCAAuC,GAAG,0BAA0B;AAC1E;AACA,MAAMC,gBAAgB,GAAGA,CAACf,YAAY,EAAEgB,kBAAkB,KAAK;EAC3D,OAAO,CAACC,KAAK,EAAEC,QAAQ,EAAEC,wBAAwB,EAAEC,IAAI,KAAK;IACxD,MAAMC,MAAM,GAAGlC,SAAS,CAAC,CAAC;IAC1B,MAAMmC,eAAe,GAAGH,wBAAwB,EAAEI,UAAU,IAAIN,KAAK,CAACO,EAAE;IACxE;IACA,IAAIC,IAAI,GAAGR,KAAK,CAACS,YAAY;IAC7B,IAAIT,KAAK,CAACS,YAAY,IAClB,CAAC,iBAAiB,EAAE,oBAAoB,CAAC,CAACC,QAAQ,CAACV,KAAK,CAACS,YAAY,CAAC,IACtET,KAAK,CAACW,IAAI,CAACD,QAAQ,CAAC,gBAAgB,CAAC,EAAE;MACvC3B,YAAY,GAAGoB,IAAI,EAAES,SAAS,GAAG,sBAAsB,GAAG,gBAAgB;MAC1Eb,kBAAkB,GAAGc,0BAA0B;MAC/CL,IAAI,GAAG,gBAAgB;IAC3B;IACA,IAAIM,cAAc;IAClB,IAAI;MACAA,cAAc,GAAG/C,iBAAiB,CAACkC,QAAQ,EAAEO,IAAI,CAAC;IACtD,CAAC,CACD,OAAOO,CAAC,EAAE;MACNX,MAAM,CAACY,KAAK,CAAC,qCAAqCf,QAAQ,KAAKO,IAAI,GAAG,EAAEO,CAAC,CAAC;MAC1E,OAAO,EAAE;IACb;IACA,MAAME,WAAW,GAAGd,IAAI,EAAEe,aAAa,GACjCrB,uCAAuC,GACvCD,gCAAgC;IACtC,MAAMuB,wBAAwB,GAAGhB,IAAI,EAAEiB,WAAW,IAAIH,WAAW;IACjE;IACA,MAAMI,MAAM,GAAGlB,IAAI,EAAEkB,MAAM,GACrB;MAAEA,MAAM,EAAElB,IAAI,CAACkB;IAAO,CAAC,GACvBtB,kBAAkB,GACdA,kBAAkB,CAACC,KAAK,EAAEG,IAAI,CAAC,GAC/B;MAAEkB,MAAM,EAAExD,oBAAoB,CAACmC,KAAK;IAAE,CAAC;IACjD,MAAMsB,OAAO,GAAGtD,mCAAmC,CAACqC,eAAe,EAAES,cAAc,EAAE;MACjFM,WAAW,EAAED,wBAAwB;MACrClB,QAAQ;MACRsB,WAAW,EAAEpB,IAAI,EAAEoB,WAAW,KAAKtB,QAAQ,KAAK,MAAM,GAAG9B,uBAAuB,GAAGa,SAAS,CAAC;MAC7F,GAAGqC;IACP,CAAC,EAAEnB,wBAAwB,EAAE;MACzBM,IAAI;MACJgB,MAAM,EAAErB,IAAI,EAAEqB;IAClB,CAAC,CAAC;IACF;IACA;IACA,IAAIC,cAAc,GAAGJ,MAAM;IAC3B,MAAMK,SAAS,GAAGJ,OAAO,CAACK,IAAI,CAACC,IAAI;IACnC,IAAI,OAAOF,SAAS,KAAK,QAAQ,EAAE;MAC/B,IAAI;QACAD,cAAc,GAAGI,IAAI,CAACC,KAAK,CAACJ,SAAS,CAAC;MAC1C,CAAC,CACD,OAAOX,CAAC,EAAE;QACNX,MAAM,CAACY,KAAK,CAAC,8BAA8B,EAAED,CAAC,CAAC;MACnD;IACJ;IACA;IACA;IACA,MAAMgB,UAAU,GAAG,CAAC5B,IAAI,EAAEoB,WAAW,IAAI,CAACpB,IAAI,EAAEe,aAAa,GACvDjB,QAAQ,KAAK,MAAM,GACf;MACE,GAAGoB,MAAM;MACTrB,KAAK,EAAE,GAAGA,KAAK,CAACO,EAAE,IAAIN,QAAQ;IAClC,CAAC,GACC;MACE,GAAGoB,MAAM;MACTrB,KAAK,EAAE,GAAGA,KAAK,CAACO,EAAE,EAAE,CAAE;IAC1B,CAAC,GACHkB,cAAc;IACpB;IACA,MAAMO,MAAM,GAAG;MACXZ,WAAW,EAAED,wBAAwB;MACrCc,mBAAmB,EAAEX,OAAO,CAACK,IAAI,CAACO,OAAO,EAAEC,aAAa;MACxDC,OAAO,EAAE5B,IAAI,KAAK,gBAAgB,IAAI,CAACL,IAAI,EAAEoB,WAAW,IAAI,CAACpB,IAAI,EAAEe,aAAa,GAC1E/C,uBAAuB,GACvBkE,YAAY,CAACf,OAAO,CAACgB,GAAG,EAAE,mBAAmB,CAAC;MACpDC,OAAO,EAAE/B,IAAI,KAAK,gBAAgB,IAAI,CAACL,IAAI,EAAEoB,WAAW,IAAI,CAACpB,IAAI,EAAEe,aAAa,GAC1E/C,uBAAuB,GAAG,mBAAmB,GAC7CmD,OAAO,CAACgB,GAAG;MACjBjB,MAAM,EAAE;QACJmB,KAAK,EAAEnB,MAAM;QACboB,YAAY,EAAEC,UAAU,CAACrB,MAAM,EAAE,MAAM,CAAC;QACxCsB,YAAY,EAAED,UAAU,CAACrB,MAAM,EAAE,MAAM,CAAC;QACxCuB,cAAc,EAAEF,UAAU,CAACrB,MAAM,EAAE,QAAQ,CAAC;QAC5CwB,UAAU,EAAEH,UAAU,CAACrB,MAAM,EAAE,IAAI;MACvC,CAAC;MACDI,cAAc,EAAE;QACZe,KAAK,EAAEf,cAAc;QACrBgB,YAAY,EAAEC,UAAU,CAACjB,cAAc,EAAE,MAAM,CAAC;QAChDkB,YAAY,EAAED,UAAU,CAACjB,cAAc,EAAE,MAAM,CAAC;QAChDmB,cAAc,EAAEF,UAAU,CAACjB,cAAc,EAAE,QAAQ,CAAC;QACpDoB,UAAU,EAAEH,UAAU,CAACjB,cAAc,EAAE,IAAI;MAC/C,CAAC;MACDM,UAAU,EAAE;QACRS,KAAK,EAAET,UAAU;QACjBU,YAAY,EAAEC,UAAU,CAACX,UAAU,EAAE,MAAM,CAAC;QAC5CY,YAAY,EAAED,UAAU,CAACX,UAAU,EAAE,MAAM,CAAC;QAC5Ca,cAAc,EAAEF,UAAU,CAACX,UAAU,EAAE,QAAQ,CAAC;QAChDc,UAAU,EAAEH,UAAU,CAACX,UAAU,EAAE,IAAI;MAC3C,CAAC;MACD/B,KAAK;MACLC,QAAQ;MACRI,eAAe,EAAEG,IAAI,KAAK,gBAAgB,IAAI,CAACL,IAAI,EAAEoB,WAAW,IAAI,CAACpB,IAAI,EAAEe,aAAa,GAClFjB,QAAQ,KAAK,MAAM,GACf,GAAGD,KAAK,CAACO,EAAE,IAAIN,QAAQ,EAAE,CAAC;MAAA,EAC1BD,KAAK,CAACO,EAAE,GACZF,eAAe,IAAIL,KAAK,CAACO,EAAE;MACjCiB,MAAM,EAAErB,IAAI,EAAEqB,MAAM;MACpBD,WAAW,EAAEpB,IAAI,EAAEoB;IACvB,CAAC;IACD;IACA,MAAMuB,OAAO,GAAG7C,QAAQ,KAAK,MAAM,IAAIO,IAAI,KAAK,gBAAgB,GAAG7B,sCAAsC,GAAGJ,OAAO;IACnH,OAAOT,yBAAyB,CAC3BiF,GAAG,CAAElE,QAAQ,IAAK;MACnB,MAAMmE,WAAW,GAAGF,OAAO,CAACjE,QAAQ,CAAC,IAAI,EAAE;MAC3C,OAAOmE,WAAW,CACbD,GAAG,CAAEjE,MAAM,IAAK;QACjB,IAAI,CAACF,WAAW,CAACC,QAAQ,EAAEC,MAAM,EAAEC,YAAY,CAAC,EAAE;UAC9C;QACJ;QACA,MAAMG,QAAQ,GAAGD,YAAY,CAACJ,QAAQ,EAAEC,MAAM,EAAEC,YAAY,CAAC;QAC7D,IAAID,MAAM,KAAK,iBAAiB,IAAIC,YAAY,CAAC2B,QAAQ,CAAC,OAAO,CAAC,EAAE;UAChE,IAAI,EAAEV,KAAK,CAACS,YAAY,IAAIT,KAAK,CAACS,YAAY,IAAIjB,iBAAiB,CAAC,EAAE;YAClE;UACJ;UACAwC,MAAM,CAAC,YAAY,CAAC,GAAGxC,iBAAiB,CAACQ,KAAK,CAACS,YAAY,CAAC;QAChE;QACA,IAAI3B,MAAM,KAAK,gBAAgB,IAAIC,YAAY,CAAC2B,QAAQ,CAAC,OAAO,CAAC,EAAE;UAC/D,IAAI,EAAEV,KAAK,CAACS,YAAY,IAAIT,KAAK,CAACS,YAAY,IAAId,aAAa,CAAC,EAAE;YAC9D;UACJ;UACAqC,MAAM,CAAC,YAAY,CAAC,GAAGrC,aAAa,CAACK,KAAK,CAACS,YAAY,CAAC;QAC5D;QACA;QACA,IAAIwC,OAAO,GAAG/D,QAAQ,CAAC8C,MAAM,CAAC,CAACkB,IAAI,CAAC,CAAC;QACrC,IAAI,CAACD,OAAO,EAAE;UACV;QACJ;QACA;QACA,IAAInE,MAAM,KAAK,iBAAiB,EAAE;UAC9B,MAAMqE,aAAa,GAAG7D,kCAAkC,CAAC;YAAE,GAAG0C;UAAO,CAAC,CAAC;UACvEiB,OAAO,GAAG,GAAGE,aAAa,OAAOF,OAAO,EAAE;QAC9C,CAAC,MACI,IAAInE,MAAM,KAAK,UAAU,EAAE;UAC5B,MAAMqE,aAAa,GAAG5D,qBAAqB,CAAC;YACxC,GAAGyC,MAAM;YACToB,YAAY,EAAEH,OAAO,CAACvC,QAAQ,CAAC,QAAQ,CAAC;YACxC2C,UAAU,EAAEJ,OAAO,CAACvC,QAAQ,CAAC,OAAO;UACxC,CAAC,CAAC;UACFuC,OAAO,GAAG,GAAGE,aAAa,OAAOF,OAAO,EAAE;QAC9C;QACA;QACA,IAAIA,OAAO,CAACvC,QAAQ,CAACO,WAAW,CAAC,EAAE;UAC/BgC,OAAO,GAAGK,6BAA6B,CAACnD,IAAI,EAAEe,aAAa,EAAED,WAAW,EAAEgC,OAAO,EAAEpE,QAAQ,EAAEoB,QAAQ,EAAEE,IAAI,EAAEoB,WAAW,CAAC;QAC7H;QACA;QACA,OAAO;UAAE1C,QAAQ;UAAEC,MAAM,EAAEA,MAAM;UAAEyE,OAAO,EAAEN;QAAQ,CAAC;MACzD,CAAC,CAAC,CACGO,MAAM,CAAEP,OAAO,IAAKA,OAAO,KAAKjE,SAAS,CAAC;IACnD,CAAC,CAAC,CACGyE,IAAI,CAAC,CAAC;EACf,CAAC;AACL,CAAC;AACD,MAAMC,qCAAqC,GAAI1D,KAAK,IAAK;EACrD,OAAO6B,IAAI,CAACC,KAAK,CAACjE,oBAAoB,CAACmC,KAAK,CAAC,CAAC;AAClD,CAAC;AACD,MAAM2D,wBAAwB,GAAI3D,KAAK,IAAK;EACxC,MAAMZ,IAAI,GAAGyC,IAAI,CAACC,KAAK,CAACjE,oBAAoB,CAACmC,KAAK,CAAC,CAAC;EACpD,OAAO;IAAEqB,MAAM,EAAEjC,IAAI,CAACwE,KAAK;IAAEC,UAAU,EAAE;MAAEC,MAAM,EAAE1E,IAAI,CAAC0E;IAAO;EAAE,CAAC;AACtE,CAAC;AACD,MAAMjD,0BAA0B,GAAGA,CAACb,KAAK,EAAEG,IAAI,KAAK;EAChD,OAAO;IACH4D,QAAQ,EAAE5D,IAAI,EAAE4D,QAAQ,IAAIlG,oBAAoB,CAACmC,KAAK,CAAC;IACvD,IAAIG,IAAI,EAAE6D,WAAW,GAAG;MAAEA,WAAW,EAAE7D,IAAI,EAAE6D;IAAY,CAAC,GAAGhF,SAAS,CAAC;IACvE,IAAImB,IAAI,EAAE8D,UAAU,GAAG;MAAEA,UAAU,EAAE9D,IAAI,EAAE8D;IAAW,CAAC,GAAGjF,SAAS,CAAC;IACpE,IAAImB,IAAI,EAAE+D,KAAK,GAAG;MAAEA,KAAK,EAAE/D,IAAI,EAAE+D;IAAM,CAAC,GAAGlF,SAAS;EACxD,CAAC;AACL,CAAC;AACD,MAAMmF,6BAA6B,GAAInE,KAAK,IAAK;EAC7C,MAAMZ,IAAI,GAAGyC,IAAI,CAACC,KAAK,CAACjE,oBAAoB,CAACmC,KAAK,CAAC,CAAC;EACpD,OAAO;IAAEoE,QAAQ,EAAEhF,IAAI,CAACgF,QAAQ;IAAEC,OAAO,EAAEjF,IAAI,CAACiF;EAAQ,CAAC;AAC7D,CAAC;AACD,MAAMC,kCAAkC,GAAItE,KAAK,IAAK;EAClD,MAAMZ,IAAI,GAAGyC,IAAI,CAACC,KAAK,CAACjE,oBAAoB,CAACmC,KAAK,CAAC,CAAC;EACpD,OAAO;IAAEuE,KAAK,EAAEnF,IAAI,CAACmF,KAAK;IAAEC,KAAK,EAAE3C,IAAI,CAAC4C,SAAS,CAACrF,IAAI,CAACoF,KAAK;EAAE,CAAC;AACnE,CAAC;AACD,MAAME,QAAQ,GAAG;EACb,sBAAsB,EAAE5E,gBAAgB,CAAC,YAAY,CAAC;EACtD,gBAAgB,EAAEA,gBAAgB,CAAC,YAAY,CAAC;EAChD,8BAA8B,EAAEA,gBAAgB,CAAC,YAAY,CAAC;EAC9D,6BAA6B,EAAEA,gBAAgB,CAAC,2BAA2B,EAAE4D,qCAAqC,CAAC;EACnH,oBAAoB,EAAE5D,gBAAgB,CAAC,OAAO,CAAC;EAC/C,WAAW,EAAEA,gBAAgB,CAAC,OAAO,CAAC;EACtC,sBAAsB,EAAEA,gBAAgB,CAAC,YAAY,CAAC;EACtD,oBAAoB,EAAEA,gBAAgB,CAAC,YAAY,CAAC;EACpD,oBAAoB,EAAEA,gBAAgB,CAAC,gBAAgB,CAAC;EACxD,gBAAgB,EAAEA,gBAAgB,CAAC,cAAc,EAAE6D,wBAAwB,CAAC;EAC5E,eAAe,EAAE7D,gBAAgB,CAAC,YAAY,CAAC;EAC/C,gBAAgB,EAAEA,gBAAgB,CAAC,cAAc,EAAE6D,wBAAwB,CAAC;EAC5E,kBAAkB,EAAE7D,gBAAgB,CAAC,YAAY,CAAC;EAClD,oBAAoB,EAAEA,gBAAgB,CAAC,mBAAmB,EAAEqE,6BAA6B,CAAC;EAC1F,qBAAqB,EAAErE,gBAAgB,CAAC,OAAO,CAAC;EAChDL,aAAa,EAAEK,gBAAgB,CAAC,OAAO,CAAC;EACxC,wBAAwB,EAAEA,gBAAgB,CAAC,SAAS,CAAC;EACrD,oBAAoB,EAAEA,gBAAgB,CAAC,SAAS,CAAC;EACjD,0BAA0B,EAAEA,gBAAgB,CAAC,wBAAwB,EAAEwE,kCAAkC,CAAC;EAC1G,qBAAqB,EAAExE,gBAAgB,CAAC,OAAO,CAAC;EAChD,iBAAiB,EAAEA,gBAAgB,CAAC,OAAO,CAAC;EAC5C,eAAe,EAAEA,gBAAgB,CAAC,aAAa,CAAC;EAChD,eAAe,EAAEA,gBAAgB,CAAC,aAAa,CAAC;EAChD,gBAAgB,EAAEA,gBAAgB,CAAC,cAAc,CAAC;EAClD,eAAe,EAAEA,gBAAgB,CAAC,aAAa,CAAC;EAChD,sBAAsB,EAAEA,gBAAgB,CAAC,OAAO,CAAC;EACjDJ,WAAW,EAAEI,gBAAgB,CAAC,OAAO,CAAC;EACtC,0BAA0B,EAAEA,gBAAgB,CAAC,wBAAwB,CAAC;EACtE,gCAAgC,EAAEA,gBAAgB,CAAC,6BAA6B;AACpF,CAAC;AACD,OAAO,SAAS6E,oBAAoBA,CAAC3E,KAAK,EAAEC,QAAQ,EAAEC,wBAAwB,EAAEC,IAAI,EAAE;EAClF,OAAOH,KAAK,CAACS,YAAY,IAAIT,KAAK,CAACS,YAAY,IAAIiE,QAAQ,GACrDA,QAAQ,CAAC1E,KAAK,CAACS,YAAY,CAAC,GAAGT,KAAK,EAAEC,QAAQ,EAAEC,wBAAwB,EAAEC,IAAI,CAAC,IAAI,EAAE,GACrF,EAAE;AACZ;AACA;AACA,SAASuC,UAAUA,CAACkC,GAAG,EAAEC,MAAM,EAAE;EAC7B,QAAQA,MAAM;IACV,KAAK,MAAM;MACP,OAAOC,YAAY,CAACpC,UAAU,CAACkC,GAAG,EAAE,MAAM,CAAC,CAAC;IAChD,KAAK,MAAM;MACP;MACA,OAAO/C,IAAI,CAAC4C,SAAS,CAACG,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC,CAACG,KAAK,CAAC,IAAI,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;IAC3E,KAAK,QAAQ;MACT,OAAOH,YAAY,CAACI,MAAM,CAACC,OAAO,CAACP,GAAG,CAAC,CAClC7B,GAAG,CAAC,CAAC,CAACqC,GAAG,EAAEC,KAAK,CAAC,KAAK;QACvB,MAAMC,cAAc,GAAGzD,IAAI,CAAC4C,SAAS,CAACY,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAACE,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;QACxE,OAAO,GAAGH,GAAG,IAAIE,cAAc,GAAG;MACtC,CAAC,CAAC,CACGL,IAAI,CAAC,IAAI,CAAC,CAAC;IACpB,KAAK,IAAI;MACL;MACA,OAAOO,cAAc,CAACZ,GAAG,CAAC,CAACG,KAAK,CAAC,IAAI,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;IAClE;MACI,MAAM,IAAI9F,KAAK,CAAC,uBAAuB0F,MAAM,EAAE,CAAC;EACxD;AACJ;AACA,SAASW,cAAcA,CAACZ,GAAG,EAAEa,KAAK,EAAE;EAChCA,KAAK,GAAGA,KAAK,IAAI,CAAC;EAClB;EACA,IAAI,OAAOb,GAAG,KAAK,QAAQ,IAAIA,GAAG,KAAK,IAAI,EAAE;IACzC,OAAO/C,IAAI,CAAC4C,SAAS,CAACG,GAAG,CAAC;EAC9B;EACA;EACA,IAAIc,KAAK,CAACC,OAAO,CAACf,GAAG,CAAC,EAAE;IACpB,MAAMgB,KAAK,GAAGhB,GAAG,CACZ7B,GAAG,CAAE8C,IAAI,IAAK;MACf,MAAMC,SAAS,GAAGN,cAAc,CAACK,IAAI,EAAEJ,KAAK,GAAG,CAAC,CAAC;MACjD,OAAO,GAAG,GAAG,CAACM,MAAM,CAAC,CAAC,IAAIN,KAAK,GAAG,CAAC,CAAC,CAAC,GAAGK,SAAS,GAAG;IACxD,CAAC,CAAC,CACGb,IAAI,CAAC,IAAI,CAAC;IACf,OAAO,MAAMW,KAAK,KAAK,GAAG,CAACG,MAAM,CAAC,CAAC,GAAGN,KAAK,CAAC,GAAG;EACnD;EACA;EACA,MAAMN,OAAO,GAAGD,MAAM,CAACC,OAAO,CAACP,GAAG,CAAC;EACnC,MAAMoB,KAAK,GAAGb,OAAO,CAChBpC,GAAG,CAAC,CAAC,CAACqC,GAAG,EAAEC,KAAK,CAAC,KAAK;IACvB,MAAMC,cAAc,GAAGE,cAAc,CAACH,KAAK,EAAEI,KAAK,GAAG,CAAC,CAAC;IACvD,MAAMQ,MAAM,GAAG,4BAA4B,CAACC,IAAI,CAACd,GAAG,CAAC,GAAGA,GAAG,GAAG,IAAIA,GAAG,GAAG;IACxE,OAAO,GAAG,GAAG,CAACW,MAAM,CAAC,CAAC,IAAIN,KAAK,GAAG,CAAC,CAAC,CAAC,GAAGQ,MAAM,KAAKX,cAAc,GAAG;EACxE,CAAC,CAAC,CACGL,IAAI,CAAC,IAAI,CAAC;EACf,OAAO,MAAMe,KAAK,KAAK,GAAG,CAACD,MAAM,CAAC,CAAC,GAAGN,KAAK,CAAC,GAAG;AACnD;AACA,SAASX,YAAYA,CAACqB,GAAG,EAAE;EACvB,OAAOA,GAAG,CACLpB,KAAK,CAAC,IAAI,CAAC,CACXhC,GAAG,CAAEqD,IAAI,IAAK,GAAG,CAACL,MAAM,CAAC,CAAC,CAAC,GAAGK,IAAI,CAAC,CACnCnB,IAAI,CAAC,IAAI,CAAC;AACnB;AACA,SAAS5C,YAAYA,CAAC8D,GAAG,EAAEE,MAAM,EAAE;EAC/B,OAAOF,GAAG,CAACG,QAAQ,CAACD,MAAM,CAAC,GAAGF,GAAG,CAACnB,KAAK,CAAC,CAAC,EAAE,CAACqB,MAAM,CAACE,MAAM,CAAC,GAAGJ,GAAG;AACpE;AACA,SAAS7C,6BAA6BA,CAACpC,aAAa,EAAED,WAAW,EAAEgC,OAAO,EAAEpE,QAAQ,EAAEoB,QAAQ,EAAEsB,WAAW,EAAE;EACzG;EACA;EACA;EACA,MAAMiF,UAAU,GAAG,CAACjF,WAAW;EAAI;EAC9BtB,QAAQ,IAAI,cAAc;EAAI;EAC1B,CAACiB,aAAa;EAAI;EACd+B,OAAO,CAACvC,QAAQ,CAAC,iBAAiB,CAAC;EAAI;EACpCuC,OAAO,CAACvC,QAAQ,CAAC,+BAA+B,CAAC,CAAE,CAAC,CAAC,CAAC;EACtE,MAAM+F,iBAAiB,GAAGD,UAAU,GAC9B,UAAU,CAAC;EAAA,EACXjF,WAAW,GACP,WAAW,GACXtB,QAAQ,CAACyG,WAAW,CAAC,CAAC,CAACnB,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,UAAU,CAAC,CAAC;EACjE;EACA,IAAI1G,QAAQ,KAAK,IAAI,EAAE;IACnBoE,OAAO,GAAGA,OAAO,CAACsC,OAAO,CAAC,0BAA0BtE,WAAW,GAAG,EAAE,2BAA2BwF,iBAAiB,GAAG,CAAC;IACpH,CAAC;EACL,CAAC,MACI,IAAI5H,QAAQ,KAAK,QAAQ,EAAE;IAC5BoE,OAAO,GAAG,aAAa,GAAGA,OAAO;IACjCA,OAAO,GAAGA,OAAO,CAACsC,OAAO,CAAC,IAAItE,WAAW,GAAG,EAAE,eAAewF,iBAAiB,IAAI,CAAC;IACnF,CAAC;IACDxD,OAAO,GAAGA,OAAO,CAACsC,OAAO,CAAC,WAAWtE,WAAW,GAAG,EAAE,yBAAyBwF,iBAAiB,MAAM,CAAC;IACtG,CAAC;IACDxD,OAAO,GAAGA,OAAO,CAACsC,OAAO,CAAC,QAAQtE,WAAW,GAAG,EAAE,sBAAsBwF,iBAAiB,MAAM,CAAC;IAChG,CAAC;IACDxD,OAAO,GAAGA,OAAO,CAACsC,OAAO,CAAC,UAAUtE,WAAW,GAAG,EAAE,wBAAwBwF,iBAAiB,MAAM,CAAC;IACpG,CAAC;EACL,CAAC,MACI,IAAI5H,QAAQ,KAAK,IAAI,EAAE;IACxBoE,OAAO,GAAGA,OAAO,CAACsC,OAAO,CAAC,IAAItE,WAAW,GAAG,EAAE,eAAewF,iBAAiB,EAAE,CAAC;IACjF,CAAC;IACDxD,OAAO,GAAGA,OAAO,CAACsC,OAAO,CAAC,0BAA0BtE,WAAW,IAAI,EAAE,0CAA0CwF,iBAAiB,MAAM,CAAC;IACvI,CAAC;IACDxD,OAAO,GAAGA,OAAO,CAACsC,OAAO,CAAC,uBAAuBtE,WAAW,IAAI,EAAE,uCAAuCwF,iBAAiB,MAAM,CAAC;IACjI,CAAC;IACDxD,OAAO,GAAGA,OAAO,CAACsC,OAAO,CAAC,yBAAyBtE,WAAW,IAAI,EAAE,yCAAyCwF,iBAAiB,MAAM,CAAC;IACrI,CAAC;EACL;EACA,OAAOxD,OAAO;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}