{"ast":null,"code":"import { HF_ROUTER_URL } from \"../config.js\";\nimport { InferenceClientProviderOutputError } from \"../errors.js\";\nimport { toArray } from \"../utils/toArray.js\";\nimport { TaskProviderHelper } from \"./providerHelper.js\";\nimport { base64FromBytes } from \"../utils/base64FromBytes.js\";\nimport { omit } from \"../utils/omit.js\";\nexport const EQUIVALENT_SENTENCE_TRANSFORMERS_TASKS = [\"feature-extraction\", \"sentence-similarity\"];\nexport class HFInferenceTask extends TaskProviderHelper {\n  constructor() {\n    super(\"hf-inference\", `${HF_ROUTER_URL}/hf-inference`);\n  }\n  preparePayload(params) {\n    return params.args;\n  }\n  makeUrl(params) {\n    if (params.model.startsWith(\"http://\") || params.model.startsWith(\"https://\")) {\n      return params.model;\n    }\n    return super.makeUrl(params);\n  }\n  makeRoute(params) {\n    if (params.task && [\"feature-extraction\", \"sentence-similarity\"].includes(params.task)) {\n      // when deployed on hf-inference, those two tasks are automatically compatible with one another.\n      return `models/${params.model}/pipeline/${params.task}`;\n    }\n    return `models/${params.model}`;\n  }\n  async getResponse(response) {\n    return response;\n  }\n}\nexport class HFInferenceTextToImageTask extends HFInferenceTask {\n  async getResponse(response, url, headers, outputType) {\n    if (!response) {\n      throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference text-to-image API: response is undefined\");\n    }\n    if (typeof response == \"object\") {\n      if (outputType === \"json\") {\n        return {\n          ...response\n        };\n      }\n      if (\"data\" in response && Array.isArray(response.data) && response.data[0].b64_json) {\n        const base64Data = response.data[0].b64_json;\n        if (outputType === \"url\") {\n          return `data:image/jpeg;base64,${base64Data}`;\n        }\n        const base64Response = await fetch(`data:image/jpeg;base64,${base64Data}`);\n        return await base64Response.blob();\n      }\n      if (\"output\" in response && Array.isArray(response.output)) {\n        if (outputType === \"url\") {\n          return response.output[0];\n        }\n        const urlResponse = await fetch(response.output[0]);\n        const blob = await urlResponse.blob();\n        return blob;\n      }\n    }\n    if (response instanceof Blob) {\n      if (outputType === \"url\" || outputType === \"json\") {\n        const b64 = await response.arrayBuffer().then(buf => Buffer.from(buf).toString(\"base64\"));\n        return outputType === \"url\" ? `data:image/jpeg;base64,${b64}` : {\n          output: `data:image/jpeg;base64,${b64}`\n        };\n      }\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference text-to-image API: expected a Blob\");\n  }\n}\nexport class HFInferenceConversationalTask extends HFInferenceTask {\n  makeUrl(params) {\n    let url;\n    if (params.model.startsWith(\"http://\") || params.model.startsWith(\"https://\")) {\n      url = params.model.trim();\n    } else {\n      url = `${this.makeBaseUrl(params)}/models/${params.model}`;\n    }\n    url = url.replace(/\\/+$/, \"\");\n    if (url.endsWith(\"/v1\")) {\n      url += \"/chat/completions\";\n    } else if (!url.endsWith(\"/chat/completions\")) {\n      url += \"/v1/chat/completions\";\n    }\n    return url;\n  }\n  preparePayload(params) {\n    return {\n      ...params.args,\n      model: params.model\n    };\n  }\n  async getResponse(response) {\n    return response;\n  }\n}\nexport class HFInferenceTextGenerationTask extends HFInferenceTask {\n  async getResponse(response) {\n    const res = toArray(response);\n    if (Array.isArray(res) && res.every(x => \"generated_text\" in x && typeof x?.generated_text === \"string\")) {\n      return res?.[0];\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference text generation API: expected Array<{generated_text: string}>\");\n  }\n}\nexport class HFInferenceAudioClassificationTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(x => typeof x === \"object\" && x !== null && typeof x.label === \"string\" && typeof x.score === \"number\")) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference audio-classification API: expected Array<{label: string, score: number}> but received different format\");\n  }\n}\nexport class HFInferenceAutomaticSpeechRecognitionTask extends HFInferenceTask {\n  async getResponse(response) {\n    return response;\n  }\n  async preparePayloadAsync(args) {\n    return \"data\" in args ? args : {\n      ...omit(args, \"inputs\"),\n      data: args.inputs\n    };\n  }\n}\nexport class HFInferenceAudioToAudioTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (!Array.isArray(response)) {\n      throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference audio-to-audio API: expected Array\");\n    }\n    if (!response.every(elem => {\n      return typeof elem === \"object\" && elem && \"label\" in elem && typeof elem.label === \"string\" && \"content-type\" in elem && typeof elem[\"content-type\"] === \"string\" && \"blob\" in elem && typeof elem.blob === \"string\";\n    })) {\n      throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference audio-to-audio API: expected Array<{label: string, audio: Blob}>\");\n    }\n    return response;\n  }\n}\nexport class HFInferenceDocumentQuestionAnsweringTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(elem => typeof elem === \"object\" && !!elem && typeof elem?.answer === \"string\" && (typeof elem.end === \"number\" || typeof elem.end === \"undefined\") && (typeof elem.score === \"number\" || typeof elem.score === \"undefined\") && (typeof elem.start === \"number\" || typeof elem.start === \"undefined\"))) {\n      return response[0];\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference document-question-answering API: expected Array<{answer: string, end: number, score: number, start: number}>\");\n  }\n}\nexport class HFInferenceFeatureExtractionTask extends HFInferenceTask {\n  async getResponse(response) {\n    const isNumArrayRec = (arr, maxDepth, curDepth = 0) => {\n      if (curDepth > maxDepth) return false;\n      if (arr.every(x => Array.isArray(x))) {\n        return arr.every(x => isNumArrayRec(x, maxDepth, curDepth + 1));\n      } else {\n        return arr.every(x => typeof x === \"number\");\n      }\n    };\n    if (Array.isArray(response) && isNumArrayRec(response, 3, 0)) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference feature-extraction API: expected Array<number[][][] | number[][] | number[] | number>\");\n  }\n}\nexport class HFInferenceImageClassificationTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(x => typeof x.label === \"string\" && typeof x.score === \"number\")) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference image-classification API: expected Array<{label: string, score: number}>\");\n  }\n}\nexport class HFInferenceImageSegmentationTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(x => typeof x.label === \"string\" && typeof x.mask === \"string\" && (x.score === undefined || typeof x.score === \"number\"))) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference image-segmentation API: expected Array<{label: string, mask: string, score: number}>\");\n  }\n  async preparePayloadAsync(args) {\n    return {\n      ...args,\n      inputs: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))\n    };\n  }\n}\nexport class HFInferenceImageToTextTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (typeof response?.generated_text !== \"string\") {\n      throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference image-to-text API: expected {generated_text: string}\");\n    }\n    return response;\n  }\n}\nexport class HFInferenceImageToImageTask extends HFInferenceTask {\n  async preparePayloadAsync(args) {\n    if (!args.parameters) {\n      return {\n        ...args,\n        model: args.model,\n        data: args.inputs\n      };\n    } else {\n      return {\n        ...args,\n        inputs: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))\n      };\n    }\n  }\n  async getResponse(response) {\n    if (response instanceof Blob) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference image-to-image API: expected Blob\");\n  }\n}\nexport class HFInferenceObjectDetectionTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(x => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\")) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference object-detection API: expected Array<{label: string, score: number, box: {xmin: number, ymin: number, xmax: number, ymax: number}}>\");\n  }\n}\nexport class HFInferenceZeroShotImageClassificationTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(x => typeof x.label === \"string\" && typeof x.score === \"number\")) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference zero-shot-image-classification API: expected Array<{label: string, score: number}>\");\n  }\n}\nexport class HFInferenceTextClassificationTask extends HFInferenceTask {\n  async getResponse(response) {\n    const output = response?.[0];\n    if (Array.isArray(output) && output.every(x => typeof x?.label === \"string\" && typeof x.score === \"number\")) {\n      return output;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference text-classification API: expected Array<{label: string, score: number}>\");\n  }\n}\nexport class HFInferenceQuestionAnsweringTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) ? response.every(elem => typeof elem === \"object\" && !!elem && typeof elem.answer === \"string\" && typeof elem.end === \"number\" && typeof elem.score === \"number\" && typeof elem.start === \"number\") : typeof response === \"object\" && !!response && typeof response.answer === \"string\" && typeof response.end === \"number\" && typeof response.score === \"number\" && typeof response.start === \"number\") {\n      return Array.isArray(response) ? response[0] : response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference question-answering API: expected Array<{answer: string, end: number, score: number, start: number}>\");\n  }\n}\nexport class HFInferenceFillMaskTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(x => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\")) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference fill-mask API: expected Array<{score: number, sequence: string, token: number, token_str: string}>\");\n  }\n}\nexport class HFInferenceZeroShotClassificationTask extends HFInferenceTask {\n  async getResponse(response) {\n    /// Handle Legacy response format from Inference API\n    if (typeof response === \"object\" && response !== null && \"labels\" in response && \"scores\" in response && Array.isArray(response.labels) && Array.isArray(response.scores) && response.labels.length === response.scores.length && response.labels.every(label => typeof label === \"string\") && response.scores.every(score => typeof score === \"number\")) {\n      const scores = response.scores;\n      return response.labels.map((label, index) => ({\n        label,\n        score: scores[index]\n      }));\n    }\n    if (Array.isArray(response) && response.every(HFInferenceZeroShotClassificationTask.validateOutputElement)) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference zero-shot-classification API: expected Array<{label: string, score: number}>\");\n  }\n  static validateOutputElement(elem) {\n    return typeof elem === \"object\" && !!elem && \"label\" in elem && \"score\" in elem && typeof elem.label === \"string\" && typeof elem.score === \"number\";\n  }\n}\nexport class HFInferenceSentenceSimilarityTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(x => typeof x === \"number\")) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference sentence-similarity API: expected Array<number>\");\n  }\n}\nexport class HFInferenceTableQuestionAnsweringTask extends HFInferenceTask {\n  static validate(elem) {\n    return typeof elem === \"object\" && !!elem && \"aggregator\" in elem && typeof elem.aggregator === \"string\" && \"answer\" in elem && typeof elem.answer === \"string\" && \"cells\" in elem && Array.isArray(elem.cells) && elem.cells.every(x => typeof x === \"string\") && \"coordinates\" in elem && Array.isArray(elem.coordinates) && elem.coordinates.every(coord => Array.isArray(coord) && coord.every(x => typeof x === \"number\"));\n  }\n  async getResponse(response) {\n    if (Array.isArray(response) && Array.isArray(response) ? response.every(elem => HFInferenceTableQuestionAnsweringTask.validate(elem)) : HFInferenceTableQuestionAnsweringTask.validate(response)) {\n      return Array.isArray(response) ? response[0] : response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference table-question-answering API: expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\");\n  }\n}\nexport class HFInferenceTokenClassificationTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(x => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\")) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference token-classification API: expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\");\n  }\n}\nexport class HFInferenceTranslationTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(x => typeof x?.translation_text === \"string\")) {\n      return response?.length === 1 ? response?.[0] : response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference translation API: expected Array<{translation_text: string}>\");\n  }\n}\nexport class HFInferenceSummarizationTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(x => typeof x?.summary_text === \"string\")) {\n      return response?.[0];\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference summarization API: expected Array<{summary_text: string}>\");\n  }\n}\nexport class HFInferenceTextToSpeechTask extends HFInferenceTask {\n  async getResponse(response) {\n    return response;\n  }\n}\nexport class HFInferenceTabularClassificationTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(x => typeof x === \"number\")) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference tabular-classification API: expected Array<number>\");\n  }\n}\nexport class HFInferenceVisualQuestionAnsweringTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(elem => typeof elem === \"object\" && !!elem && typeof elem?.answer === \"string\" && typeof elem.score === \"number\")) {\n      return response[0];\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference visual-question-answering API: expected Array<{answer: string, score: number}>\");\n  }\n}\nexport class HFInferenceTabularRegressionTask extends HFInferenceTask {\n  async getResponse(response) {\n    if (Array.isArray(response) && response.every(x => typeof x === \"number\")) {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference tabular-regression API: expected Array<number>\");\n  }\n}\nexport class HFInferenceTextToAudioTask extends HFInferenceTask {\n  async getResponse(response) {\n    return response;\n  }\n}","map":{"version":3,"names":["HF_ROUTER_URL","InferenceClientProviderOutputError","toArray","TaskProviderHelper","base64FromBytes","omit","EQUIVALENT_SENTENCE_TRANSFORMERS_TASKS","HFInferenceTask","constructor","preparePayload","params","args","makeUrl","model","startsWith","makeRoute","task","includes","getResponse","response","HFInferenceTextToImageTask","url","headers","outputType","Array","isArray","data","b64_json","base64Data","base64Response","fetch","blob","output","urlResponse","Blob","b64","arrayBuffer","then","buf","Buffer","from","toString","HFInferenceConversationalTask","trim","makeBaseUrl","replace","endsWith","HFInferenceTextGenerationTask","res","every","x","generated_text","HFInferenceAudioClassificationTask","label","score","HFInferenceAutomaticSpeechRecognitionTask","preparePayloadAsync","inputs","HFInferenceAudioToAudioTask","elem","HFInferenceDocumentQuestionAnsweringTask","answer","end","start","HFInferenceFeatureExtractionTask","isNumArrayRec","arr","maxDepth","curDepth","HFInferenceImageClassificationTask","HFInferenceImageSegmentationTask","mask","undefined","Uint8Array","ArrayBuffer","HFInferenceImageToTextTask","HFInferenceImageToImageTask","parameters","HFInferenceObjectDetectionTask","box","xmin","ymin","xmax","ymax","HFInferenceZeroShotImageClassificationTask","HFInferenceTextClassificationTask","HFInferenceQuestionAnsweringTask","HFInferenceFillMaskTask","sequence","token","token_str","HFInferenceZeroShotClassificationTask","labels","scores","length","map","index","validateOutputElement","HFInferenceSentenceSimilarityTask","HFInferenceTableQuestionAnsweringTask","validate","aggregator","cells","coordinates","coord","HFInferenceTokenClassificationTask","entity_group","word","HFInferenceTranslationTask","translation_text","HFInferenceSummarizationTask","summary_text","HFInferenceTextToSpeechTask","HFInferenceTabularClassificationTask","HFInferenceVisualQuestionAnsweringTask","HFInferenceTabularRegressionTask","HFInferenceTextToAudioTask"],"sources":["/Users/agmacbook/Documents/Courses/Meta - Full Stack/Exercises/meta_fullstack_exercises/6_react_basics/12_review/13_chef_claude/node_modules/@huggingface/inference/dist/esm/providers/hf-inference.js"],"sourcesContent":["import { HF_ROUTER_URL } from \"../config.js\";\nimport { InferenceClientProviderOutputError } from \"../errors.js\";\nimport { toArray } from \"../utils/toArray.js\";\nimport { TaskProviderHelper } from \"./providerHelper.js\";\nimport { base64FromBytes } from \"../utils/base64FromBytes.js\";\nimport { omit } from \"../utils/omit.js\";\nexport const EQUIVALENT_SENTENCE_TRANSFORMERS_TASKS = [\"feature-extraction\", \"sentence-similarity\"];\nexport class HFInferenceTask extends TaskProviderHelper {\n    constructor() {\n        super(\"hf-inference\", `${HF_ROUTER_URL}/hf-inference`);\n    }\n    preparePayload(params) {\n        return params.args;\n    }\n    makeUrl(params) {\n        if (params.model.startsWith(\"http://\") || params.model.startsWith(\"https://\")) {\n            return params.model;\n        }\n        return super.makeUrl(params);\n    }\n    makeRoute(params) {\n        if (params.task && [\"feature-extraction\", \"sentence-similarity\"].includes(params.task)) {\n            // when deployed on hf-inference, those two tasks are automatically compatible with one another.\n            return `models/${params.model}/pipeline/${params.task}`;\n        }\n        return `models/${params.model}`;\n    }\n    async getResponse(response) {\n        return response;\n    }\n}\nexport class HFInferenceTextToImageTask extends HFInferenceTask {\n    async getResponse(response, url, headers, outputType) {\n        if (!response) {\n            throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference text-to-image API: response is undefined\");\n        }\n        if (typeof response == \"object\") {\n            if (outputType === \"json\") {\n                return { ...response };\n            }\n            if (\"data\" in response && Array.isArray(response.data) && response.data[0].b64_json) {\n                const base64Data = response.data[0].b64_json;\n                if (outputType === \"url\") {\n                    return `data:image/jpeg;base64,${base64Data}`;\n                }\n                const base64Response = await fetch(`data:image/jpeg;base64,${base64Data}`);\n                return await base64Response.blob();\n            }\n            if (\"output\" in response && Array.isArray(response.output)) {\n                if (outputType === \"url\") {\n                    return response.output[0];\n                }\n                const urlResponse = await fetch(response.output[0]);\n                const blob = await urlResponse.blob();\n                return blob;\n            }\n        }\n        if (response instanceof Blob) {\n            if (outputType === \"url\" || outputType === \"json\") {\n                const b64 = await response.arrayBuffer().then((buf) => Buffer.from(buf).toString(\"base64\"));\n                return outputType === \"url\" ? `data:image/jpeg;base64,${b64}` : { output: `data:image/jpeg;base64,${b64}` };\n            }\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference text-to-image API: expected a Blob\");\n    }\n}\nexport class HFInferenceConversationalTask extends HFInferenceTask {\n    makeUrl(params) {\n        let url;\n        if (params.model.startsWith(\"http://\") || params.model.startsWith(\"https://\")) {\n            url = params.model.trim();\n        }\n        else {\n            url = `${this.makeBaseUrl(params)}/models/${params.model}`;\n        }\n        url = url.replace(/\\/+$/, \"\");\n        if (url.endsWith(\"/v1\")) {\n            url += \"/chat/completions\";\n        }\n        else if (!url.endsWith(\"/chat/completions\")) {\n            url += \"/v1/chat/completions\";\n        }\n        return url;\n    }\n    preparePayload(params) {\n        return {\n            ...params.args,\n            model: params.model,\n        };\n    }\n    async getResponse(response) {\n        return response;\n    }\n}\nexport class HFInferenceTextGenerationTask extends HFInferenceTask {\n    async getResponse(response) {\n        const res = toArray(response);\n        if (Array.isArray(res) && res.every((x) => \"generated_text\" in x && typeof x?.generated_text === \"string\")) {\n            return res?.[0];\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference text generation API: expected Array<{generated_text: string}>\");\n    }\n}\nexport class HFInferenceAudioClassificationTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) &&\n            response.every((x) => typeof x === \"object\" && x !== null && typeof x.label === \"string\" && typeof x.score === \"number\")) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference audio-classification API: expected Array<{label: string, score: number}> but received different format\");\n    }\n}\nexport class HFInferenceAutomaticSpeechRecognitionTask extends HFInferenceTask {\n    async getResponse(response) {\n        return response;\n    }\n    async preparePayloadAsync(args) {\n        return \"data\" in args\n            ? args\n            : {\n                ...omit(args, \"inputs\"),\n                data: args.inputs,\n            };\n    }\n}\nexport class HFInferenceAudioToAudioTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (!Array.isArray(response)) {\n            throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference audio-to-audio API: expected Array\");\n        }\n        if (!response.every((elem) => {\n            return (typeof elem === \"object\" &&\n                elem &&\n                \"label\" in elem &&\n                typeof elem.label === \"string\" &&\n                \"content-type\" in elem &&\n                typeof elem[\"content-type\"] === \"string\" &&\n                \"blob\" in elem &&\n                typeof elem.blob === \"string\");\n        })) {\n            throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference audio-to-audio API: expected Array<{label: string, audio: Blob}>\");\n        }\n        return response;\n    }\n}\nexport class HFInferenceDocumentQuestionAnsweringTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) &&\n            response.every((elem) => typeof elem === \"object\" &&\n                !!elem &&\n                typeof elem?.answer === \"string\" &&\n                (typeof elem.end === \"number\" || typeof elem.end === \"undefined\") &&\n                (typeof elem.score === \"number\" || typeof elem.score === \"undefined\") &&\n                (typeof elem.start === \"number\" || typeof elem.start === \"undefined\"))) {\n            return response[0];\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference document-question-answering API: expected Array<{answer: string, end: number, score: number, start: number}>\");\n    }\n}\nexport class HFInferenceFeatureExtractionTask extends HFInferenceTask {\n    async getResponse(response) {\n        const isNumArrayRec = (arr, maxDepth, curDepth = 0) => {\n            if (curDepth > maxDepth)\n                return false;\n            if (arr.every((x) => Array.isArray(x))) {\n                return arr.every((x) => isNumArrayRec(x, maxDepth, curDepth + 1));\n            }\n            else {\n                return arr.every((x) => typeof x === \"number\");\n            }\n        };\n        if (Array.isArray(response) && isNumArrayRec(response, 3, 0)) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference feature-extraction API: expected Array<number[][][] | number[][] | number[] | number>\");\n    }\n}\nexport class HFInferenceImageClassificationTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) && response.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\")) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference image-classification API: expected Array<{label: string, score: number}>\");\n    }\n}\nexport class HFInferenceImageSegmentationTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) &&\n            response.every((x) => typeof x.label === \"string\" &&\n                typeof x.mask === \"string\" &&\n                (x.score === undefined || typeof x.score === \"number\"))) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference image-segmentation API: expected Array<{label: string, mask: string, score: number}>\");\n    }\n    async preparePayloadAsync(args) {\n        return {\n            ...args,\n            inputs: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer())),\n        };\n    }\n}\nexport class HFInferenceImageToTextTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (typeof response?.generated_text !== \"string\") {\n            throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference image-to-text API: expected {generated_text: string}\");\n        }\n        return response;\n    }\n}\nexport class HFInferenceImageToImageTask extends HFInferenceTask {\n    async preparePayloadAsync(args) {\n        if (!args.parameters) {\n            return {\n                ...args,\n                model: args.model,\n                data: args.inputs,\n            };\n        }\n        else {\n            return {\n                ...args,\n                inputs: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer())),\n            };\n        }\n    }\n    async getResponse(response) {\n        if (response instanceof Blob) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference image-to-image API: expected Blob\");\n    }\n}\nexport class HFInferenceObjectDetectionTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) &&\n            response.every((x) => typeof x.label === \"string\" &&\n                typeof x.score === \"number\" &&\n                typeof x.box.xmin === \"number\" &&\n                typeof x.box.ymin === \"number\" &&\n                typeof x.box.xmax === \"number\" &&\n                typeof x.box.ymax === \"number\")) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference object-detection API: expected Array<{label: string, score: number, box: {xmin: number, ymin: number, xmax: number, ymax: number}}>\");\n    }\n}\nexport class HFInferenceZeroShotImageClassificationTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) && response.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\")) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference zero-shot-image-classification API: expected Array<{label: string, score: number}>\");\n    }\n}\nexport class HFInferenceTextClassificationTask extends HFInferenceTask {\n    async getResponse(response) {\n        const output = response?.[0];\n        if (Array.isArray(output) && output.every((x) => typeof x?.label === \"string\" && typeof x.score === \"number\")) {\n            return output;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference text-classification API: expected Array<{label: string, score: number}>\");\n    }\n}\nexport class HFInferenceQuestionAnsweringTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response)\n            ? response.every((elem) => typeof elem === \"object\" &&\n                !!elem &&\n                typeof elem.answer === \"string\" &&\n                typeof elem.end === \"number\" &&\n                typeof elem.score === \"number\" &&\n                typeof elem.start === \"number\")\n            : typeof response === \"object\" &&\n                !!response &&\n                typeof response.answer === \"string\" &&\n                typeof response.end === \"number\" &&\n                typeof response.score === \"number\" &&\n                typeof response.start === \"number\") {\n            return Array.isArray(response) ? response[0] : response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference question-answering API: expected Array<{answer: string, end: number, score: number, start: number}>\");\n    }\n}\nexport class HFInferenceFillMaskTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) &&\n            response.every((x) => typeof x.score === \"number\" &&\n                typeof x.sequence === \"string\" &&\n                typeof x.token === \"number\" &&\n                typeof x.token_str === \"string\")) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference fill-mask API: expected Array<{score: number, sequence: string, token: number, token_str: string}>\");\n    }\n}\nexport class HFInferenceZeroShotClassificationTask extends HFInferenceTask {\n    async getResponse(response) {\n        /// Handle Legacy response format from Inference API\n        if (typeof response === \"object\" &&\n            response !== null &&\n            \"labels\" in response &&\n            \"scores\" in response &&\n            Array.isArray(response.labels) &&\n            Array.isArray(response.scores) &&\n            response.labels.length === response.scores.length &&\n            response.labels.every((label) => typeof label === \"string\") &&\n            response.scores.every((score) => typeof score === \"number\")) {\n            const scores = response.scores;\n            return response.labels.map((label, index) => ({\n                label,\n                score: scores[index],\n            }));\n        }\n        if (Array.isArray(response) && response.every(HFInferenceZeroShotClassificationTask.validateOutputElement)) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference zero-shot-classification API: expected Array<{label: string, score: number}>\");\n    }\n    static validateOutputElement(elem) {\n        return (typeof elem === \"object\" &&\n            !!elem &&\n            \"label\" in elem &&\n            \"score\" in elem &&\n            typeof elem.label === \"string\" &&\n            typeof elem.score === \"number\");\n    }\n}\nexport class HFInferenceSentenceSimilarityTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) && response.every((x) => typeof x === \"number\")) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference sentence-similarity API: expected Array<number>\");\n    }\n}\nexport class HFInferenceTableQuestionAnsweringTask extends HFInferenceTask {\n    static validate(elem) {\n        return (typeof elem === \"object\" &&\n            !!elem &&\n            \"aggregator\" in elem &&\n            typeof elem.aggregator === \"string\" &&\n            \"answer\" in elem &&\n            typeof elem.answer === \"string\" &&\n            \"cells\" in elem &&\n            Array.isArray(elem.cells) &&\n            elem.cells.every((x) => typeof x === \"string\") &&\n            \"coordinates\" in elem &&\n            Array.isArray(elem.coordinates) &&\n            elem.coordinates.every((coord) => Array.isArray(coord) && coord.every((x) => typeof x === \"number\")));\n    }\n    async getResponse(response) {\n        if (Array.isArray(response) && Array.isArray(response)\n            ? response.every((elem) => HFInferenceTableQuestionAnsweringTask.validate(elem))\n            : HFInferenceTableQuestionAnsweringTask.validate(response)) {\n            return Array.isArray(response) ? response[0] : response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference table-question-answering API: expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\");\n    }\n}\nexport class HFInferenceTokenClassificationTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) &&\n            response.every((x) => typeof x.end === \"number\" &&\n                typeof x.entity_group === \"string\" &&\n                typeof x.score === \"number\" &&\n                typeof x.start === \"number\" &&\n                typeof x.word === \"string\")) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference token-classification API: expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\");\n    }\n}\nexport class HFInferenceTranslationTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) && response.every((x) => typeof x?.translation_text === \"string\")) {\n            return response?.length === 1 ? response?.[0] : response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference translation API: expected Array<{translation_text: string}>\");\n    }\n}\nexport class HFInferenceSummarizationTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) && response.every((x) => typeof x?.summary_text === \"string\")) {\n            return response?.[0];\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference summarization API: expected Array<{summary_text: string}>\");\n    }\n}\nexport class HFInferenceTextToSpeechTask extends HFInferenceTask {\n    async getResponse(response) {\n        return response;\n    }\n}\nexport class HFInferenceTabularClassificationTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) && response.every((x) => typeof x === \"number\")) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference tabular-classification API: expected Array<number>\");\n    }\n}\nexport class HFInferenceVisualQuestionAnsweringTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) &&\n            response.every((elem) => typeof elem === \"object\" && !!elem && typeof elem?.answer === \"string\" && typeof elem.score === \"number\")) {\n            return response[0];\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference visual-question-answering API: expected Array<{answer: string, score: number}>\");\n    }\n}\nexport class HFInferenceTabularRegressionTask extends HFInferenceTask {\n    async getResponse(response) {\n        if (Array.isArray(response) && response.every((x) => typeof x === \"number\")) {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Received malformed response from HF-Inference tabular-regression API: expected Array<number>\");\n    }\n}\nexport class HFInferenceTextToAudioTask extends HFInferenceTask {\n    async getResponse(response) {\n        return response;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}