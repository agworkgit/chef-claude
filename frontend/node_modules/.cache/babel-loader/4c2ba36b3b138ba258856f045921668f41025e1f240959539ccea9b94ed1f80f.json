{"ast":null,"code":"import { HF_ROUTER_URL } from \"../config.js\";\nimport { InferenceClientProviderOutputError, InferenceClientRoutingError } from \"../errors.js\";\nimport { toArray } from \"../utils/toArray.js\";\n/**\n * Base class for task-specific provider helpers\n */\nexport class TaskProviderHelper {\n  provider;\n  baseUrl;\n  clientSideRoutingOnly;\n  constructor(provider, baseUrl, clientSideRoutingOnly = false) {\n    this.provider = provider;\n    this.baseUrl = baseUrl;\n    this.clientSideRoutingOnly = clientSideRoutingOnly;\n  }\n  /**\n   * Prepare the base URL for the request\n   */\n  makeBaseUrl(params) {\n    return params.authMethod !== \"provider-key\" ? `${HF_ROUTER_URL}/${this.provider}` : this.baseUrl;\n  }\n  /**\n   * Prepare the body for the request\n   */\n  makeBody(params) {\n    if (\"data\" in params.args && !!params.args.data) {\n      return params.args.data;\n    }\n    return JSON.stringify(this.preparePayload(params));\n  }\n  /**\n   * Prepare the URL for the request\n   */\n  makeUrl(params) {\n    const baseUrl = this.makeBaseUrl(params);\n    const route = this.makeRoute(params).replace(/^\\/+/, \"\");\n    return `${baseUrl}/${route}`;\n  }\n  /**\n   * Prepare the headers for the request\n   */\n  prepareHeaders(params, isBinary) {\n    const headers = {};\n    if (params.authMethod !== \"none\") {\n      headers[\"Authorization\"] = `Bearer ${params.accessToken}`;\n    }\n    if (!isBinary) {\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n    return headers;\n  }\n}\n// BASE IMPLEMENTATIONS FOR COMMON PATTERNS\nexport class BaseConversationalTask extends TaskProviderHelper {\n  constructor(provider, baseUrl, clientSideRoutingOnly = false) {\n    super(provider, baseUrl, clientSideRoutingOnly);\n  }\n  makeRoute() {\n    return \"v1/chat/completions\";\n  }\n  preparePayload(params) {\n    return {\n      ...params.args,\n      model: params.model\n    };\n  }\n  async getResponse(response) {\n    if (typeof response === \"object\" && Array.isArray(response?.choices) && typeof response?.created === \"number\" && typeof response?.id === \"string\" && typeof response?.model === \"string\" && (\n    /// Together.ai and Nebius do not output a system_fingerprint\n    response.system_fingerprint === undefined || response.system_fingerprint === null || typeof response.system_fingerprint === \"string\") && typeof response?.usage === \"object\") {\n      return response;\n    }\n    throw new InferenceClientProviderOutputError(\"Expected ChatCompletionOutput\");\n  }\n}\nexport class BaseTextGenerationTask extends TaskProviderHelper {\n  constructor(provider, baseUrl, clientSideRoutingOnly = false) {\n    super(provider, baseUrl, clientSideRoutingOnly);\n  }\n  preparePayload(params) {\n    return {\n      ...params.args,\n      model: params.model\n    };\n  }\n  makeRoute() {\n    return \"v1/completions\";\n  }\n  async getResponse(response) {\n    const res = toArray(response);\n    if (Array.isArray(res) && res.length > 0 && res.every(x => typeof x === \"object\" && !!x && \"generated_text\" in x && typeof x.generated_text === \"string\")) {\n      return res[0];\n    }\n    throw new InferenceClientProviderOutputError(\"Expected Array<{generated_text: string}>\");\n  }\n}\nexport class AutoRouterConversationalTask extends BaseConversationalTask {\n  constructor() {\n    super(\"auto\", \"https://router.huggingface.co\");\n  }\n  makeBaseUrl(params) {\n    if (params.authMethod !== \"hf-token\") {\n      throw new InferenceClientRoutingError(\"Cannot select auto-router when using non-Hugging Face API key.\");\n    }\n    return this.baseUrl;\n  }\n}","map":{"version":3,"names":["HF_ROUTER_URL","InferenceClientProviderOutputError","InferenceClientRoutingError","toArray","TaskProviderHelper","provider","baseUrl","clientSideRoutingOnly","constructor","makeBaseUrl","params","authMethod","makeBody","args","data","JSON","stringify","preparePayload","makeUrl","route","makeRoute","replace","prepareHeaders","isBinary","headers","accessToken","BaseConversationalTask","model","getResponse","response","Array","isArray","choices","created","id","system_fingerprint","undefined","usage","BaseTextGenerationTask","res","length","every","x","generated_text","AutoRouterConversationalTask"],"sources":["/Users/agmacbook/Documents/Courses/Meta - Full Stack/Exercises/meta_fullstack_exercises/6_react_basics/12_review/13_chef_claude/node_modules/@huggingface/inference/dist/esm/providers/providerHelper.js"],"sourcesContent":["import { HF_ROUTER_URL } from \"../config.js\";\nimport { InferenceClientProviderOutputError, InferenceClientRoutingError } from \"../errors.js\";\nimport { toArray } from \"../utils/toArray.js\";\n/**\n * Base class for task-specific provider helpers\n */\nexport class TaskProviderHelper {\n    provider;\n    baseUrl;\n    clientSideRoutingOnly;\n    constructor(provider, baseUrl, clientSideRoutingOnly = false) {\n        this.provider = provider;\n        this.baseUrl = baseUrl;\n        this.clientSideRoutingOnly = clientSideRoutingOnly;\n    }\n    /**\n     * Prepare the base URL for the request\n     */\n    makeBaseUrl(params) {\n        return params.authMethod !== \"provider-key\" ? `${HF_ROUTER_URL}/${this.provider}` : this.baseUrl;\n    }\n    /**\n     * Prepare the body for the request\n     */\n    makeBody(params) {\n        if (\"data\" in params.args && !!params.args.data) {\n            return params.args.data;\n        }\n        return JSON.stringify(this.preparePayload(params));\n    }\n    /**\n     * Prepare the URL for the request\n     */\n    makeUrl(params) {\n        const baseUrl = this.makeBaseUrl(params);\n        const route = this.makeRoute(params).replace(/^\\/+/, \"\");\n        return `${baseUrl}/${route}`;\n    }\n    /**\n     * Prepare the headers for the request\n     */\n    prepareHeaders(params, isBinary) {\n        const headers = {};\n        if (params.authMethod !== \"none\") {\n            headers[\"Authorization\"] = `Bearer ${params.accessToken}`;\n        }\n        if (!isBinary) {\n            headers[\"Content-Type\"] = \"application/json\";\n        }\n        return headers;\n    }\n}\n// BASE IMPLEMENTATIONS FOR COMMON PATTERNS\nexport class BaseConversationalTask extends TaskProviderHelper {\n    constructor(provider, baseUrl, clientSideRoutingOnly = false) {\n        super(provider, baseUrl, clientSideRoutingOnly);\n    }\n    makeRoute() {\n        return \"v1/chat/completions\";\n    }\n    preparePayload(params) {\n        return {\n            ...params.args,\n            model: params.model,\n        };\n    }\n    async getResponse(response) {\n        if (typeof response === \"object\" &&\n            Array.isArray(response?.choices) &&\n            typeof response?.created === \"number\" &&\n            typeof response?.id === \"string\" &&\n            typeof response?.model === \"string\" &&\n            /// Together.ai and Nebius do not output a system_fingerprint\n            (response.system_fingerprint === undefined ||\n                response.system_fingerprint === null ||\n                typeof response.system_fingerprint === \"string\") &&\n            typeof response?.usage === \"object\") {\n            return response;\n        }\n        throw new InferenceClientProviderOutputError(\"Expected ChatCompletionOutput\");\n    }\n}\nexport class BaseTextGenerationTask extends TaskProviderHelper {\n    constructor(provider, baseUrl, clientSideRoutingOnly = false) {\n        super(provider, baseUrl, clientSideRoutingOnly);\n    }\n    preparePayload(params) {\n        return {\n            ...params.args,\n            model: params.model,\n        };\n    }\n    makeRoute() {\n        return \"v1/completions\";\n    }\n    async getResponse(response) {\n        const res = toArray(response);\n        if (Array.isArray(res) &&\n            res.length > 0 &&\n            res.every((x) => typeof x === \"object\" && !!x && \"generated_text\" in x && typeof x.generated_text === \"string\")) {\n            return res[0];\n        }\n        throw new InferenceClientProviderOutputError(\"Expected Array<{generated_text: string}>\");\n    }\n}\nexport class AutoRouterConversationalTask extends BaseConversationalTask {\n    constructor() {\n        super(\"auto\", \"https://router.huggingface.co\");\n    }\n    makeBaseUrl(params) {\n        if (params.authMethod !== \"hf-token\") {\n            throw new InferenceClientRoutingError(\"Cannot select auto-router when using non-Hugging Face API key.\");\n        }\n        return this.baseUrl;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}